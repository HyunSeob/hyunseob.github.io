<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DailyEngineering</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyunseob.github.io/"/>
  <updated>2019-05-08T20:36:35.365Z</updated>
  <id>https://hyunseob.github.io/</id>
  
  <author>
    <name>HyunSeob</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Google I/O 2019: Day 1 후기</title>
    <link href="https://hyunseob.github.io/2019/05/09/google-io-2019-day-1/"/>
    <id>https://hyunseob.github.io/2019/05/09/google-io-2019-day-1/</id>
    <published>2019-05-09T04:30:30.000Z</published>
    <updated>2019-05-08T20:36:35.365Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/google-io/badge.jpg"/><p>GDG Korea WebTech Organizer로서 Google Korea로부터 숙소 비용 및 티켓 비용을 전액 지원받아 Google I/O 2019에 참가하게 되었다. 사실 Google I/O에는 이번에 처음으로 참가하는 것이다. Google I/O 행사 뿐만 아니라 이런 글로벌 규모의 컨퍼런스에 참가하는 것 자체가 처음이다. 후기에서는 이번에 공개된 모든 기술에 대해 내 해석을 남기는 것보다는 (사실 이건 다른 미디어에서 잘 하고 있기 때문에) 전반적인 행사의 느낌을 공유하는데 초점을 맞추려고 한다.</p><h2 id="입장-amp-Keynote-Pre-show"><a href="#입장-amp-Keynote-Pre-show" class="headerlink" title="입장 &amp; Keynote Pre-show"></a>입장 &amp; Keynote Pre-show</h2><p>아침 일찍 우버를 타고 Google I/O 행사장에 도착했다. 여덟 시쯤 도착한 것 같은데 입장 줄이 길어서 입장하는데 30분 정도 걸린 것 같다.</p><p>도착해보니 행사장은 약간 놀이공원 같았다. 실제로 전체 행사장 크기도 작은 놀이공원 사이즈는 되고, 뭔가 사람들이 약간 텐션 오른 것도 놀이공원과 비슷했다. 행사장에서는 아침으로 베이글과 커피 등을 제공하고 있었는데, 간단하게 아침식사를 해결하고 키노트를 듣기 위해서 키노트 장소로 이동했다.</p><p>이번 Google I/O에는 약 5000명의 사람이 참여했다고 들었는데, 과연 키노트 장소에도 사람은 많았다. 키노트 장소에는 크게 맨 앞 쪽 스테이지와 가장 가까운 좌석들(콘서트 같은 걸로 비유하면 R석)이 가장 중심이었고 바로 그 뒤 프레스 좌석, 일반좌석, 잔디좌석이 있었다. 나는 GDG 커뮤니티 오거나이저로서 참석하는 것이어서 감사하게도 앞쪽 좌석에 갈 수 있었다.</p><p>보통 개발자 행사라고 하면 약간 정적이고 조용한 사람들이 가득한 공간에서 키보드만 두드리는 이미지를 상상하게 되는데 Google I/O는 입장할 때부터 분위기가 개발자 행사라기보다는 뭐랄까, 콘서트나 스포츠 경기장에 가까운 분위기였다. 스테이지에서는 무려 “AI” DJ가 믹싱하는 음악이 나오고 있고 행사장에는 환호소리가 끊임없이 들렸다. 이렇게 큰 행사에 참여하는 것은 처음이라서 이것이 일반적인 건지 특이한 케이스인건지는 모르겠지만 이런 축제 분위기는 좋았다. 진정한 개발자 축제가 이런 것이 아닐까 하는 생각이 들었다.</p><h2 id="Building-more-helpful-Google-for-everyone"><a href="#Building-more-helpful-Google-for-everyone" class="headerlink" title="Building more helpful Google for everyone"></a>Building more helpful Google for everyone</h2><p><img src="/images/google-io/keynote.jpg" alt="키노트 스테이지"></p><p>키노트의 MC는 Google의 CEO인 순다 피차이였다. 이번 키노트를 관통하는 키워드는 “Helpful”이다. 기술들을 사용자에게 진짜 도움이 되는 방법으로 쓰는 것이라고 이해하면 되려나? 이런 주제와 함께 여러가지 구글의 새로운 기술과 컴퓨터 과학적 성취들이 공개되었다.</p><p>키노트에서 공개된 새로운 기술 중에서 Google Assistant의 성능 향상, AR 관련 구글 렌즈의 새로운 기능이나 안드로이드 Q에 새로 들어갈 기능들에게도 관심이 갔지만, 내게 가장 흥미로웠던 것은 Duplex on the Web 이었다. Duplex는 작년 Google I/O에서 가장 화제가 되었던 AI가 미용실에 전화를 걸어 예약하는 바로 그 기능이다. Duplex on the Web은 이미 서비스를 운영하고 있는 웹페이지(예를 들어 항공권 결제 웹페이지)에 들어가서 이미 여러가지 앱에 들어있는 정보들을 이용해서 복잡한 회원가입과 구매절차를 자동으로 진행하는 기능이다. 더욱 놀라웠던 건 각 웹페이지들을 수동으로 Duplex에 통합하는 것이 아니라 ML을 적용해서 자동으로 통합할 수 있다는 부분이었다. 실제 사용이 가능할 때 어느정도 수준으로 통합될 지, 정말 대부분의 웹사이트에 자동으로 통합될 것인지, 사실 웹 개발자로서 약간은 회의적인 입장이라 궁금하다. 토스도 미친 유저 경험을 추구하기 위해 비슷한 기능이 들어가 있는데 공개된 시점에 참고할 부분이 많을 거라고 예상하고 있다.</p><p>요즘 소프트웨어 기술 업계에 관심이 많은 사람이라면 공감할 수 있겠지만, 많은 오프라인 비즈니스가 온라인으로 옮겨가면서, 한 사용자가 다양한 소프트웨어를 사용해야 하기 때문에 이런 상황에 대해서 피로감을 느끼는 사람이 적지 않을 거라고 생각한다. 이번에 공개된 Google의 기술들은 이런 피로감을 해소하는데 초점을 맞추고 있다는 생각이 들었다. 더불어, 이런 소프트웨어에 접근 자체가 어려웠던 사용자, 가령 문맹이라던지, 장애를 가지고 있는 사람들에게 도움이 되기 위해 노력하고 있다는 생각도 들었다. 이번에 공개된 기술 중 Google Assistant 관련 내용이 특히 많다고 느껴진 것도 같은 맥락에서 해석이 가능할 것 같다.</p><p>전반적인 느낌에 대해 표현하자면, 키노트를 듣는 내내 흥분을 감추기 어려웠다. 물론 Google이 이번에 공개한 기술 자체도 놀라운 부분이 적지 않았다. 하지만, 내가 솔직히 이걸 그냥 페이스북에서 기사로 봤을 때를 상상해 보면, “오 역시 구글”하고 짧게 한 마디하고 끝났을 것을, 그 현장의 열광적인 분위기를 온전히 느낄 수 있었기 때문에 “내가 역사의 한 순간에 서있다”라는 생각을 벅차오르는 감정과 함께 느낄 수 있었다. 동시에 Google I/O에 참가할 수 있어서 다행이라는 생각이 들었다.</p><p>여기에 소개하지 않은 기술들이나 새로 공개된 기기에 대해서는 <a href="https://www.theverge.com/2019/시/7/18531198/google-io-summary-keynote-news-highlights-recap-2019" target="_blank" rel="noopener">The Verge의 기사</a>를 참고하면 좋을 것 같다.</p><h2 id="Developer-Keynote"><a href="#Developer-Keynote" class="headerlink" title="Developer Keynote"></a>Developer Keynote</h2><p><img src="/images/google-io/v8-performance.jpg" alt="V8 성능 개선 슬라이드"></p><p>점심으로 제공되는 샌드위치를 가볍게 먹고나니 개발자 키노트가 시작됐다. 개발자 키노트에서는 개발자에게 중요할 만한 내용을 압축해서 전달했다.Android Studio를 포함해 Android Q의 새로운 API와 Chrome에서 제공하는 (물론 웹 표준인) 새로운 API, V8 엔진의 성능개선, Tensorflow 등 Google의 대표적인 기술들의 업데이트들을 소개하는 자리였다. 사진은 열심히 찍었는데 사실 이 키노트에서는 요약된 자료만 보여줬고, 자세한 내용들은 별도로 마련된 세션에서 소개되었기 때문에 이 부분에서 다루지 않겠다.</p><h2 id="What’s-new-with-Chrome-and-the-Web"><a href="#What’s-new-with-Chrome-and-the-Web" class="headerlink" title="What’s new with Chrome and the Web"></a>What’s new with Chrome and the Web</h2><p>이 세션에서는 새로운 Chrome의 API들이 자세하게 소개되었다. 크게 세 가지 분류로 소개되었다.</p><ul><li>Instant (성능적인 개선)</li><li>Powerful (영역의 확장)</li><li>Safe (프라이버시, 보안)</li></ul><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>“Instant” 분류에서는 늘 그렇듯이 Chrome이 사용하는 V8 엔진의 성능적인 개선이 먼저 소개되었고 다음으로 웹 개발자가 웹 사이트의 성능을 최적화하기 위한 다양한 도구들이 소개되었다. 다행히도 꽤 많은 부분이 바로 적용 가능해보였다. 가령 Image lazy load를 Chrome에서 지원하기 시작했는데, 단순히 <code>&lt;img loading=&quot;lazy&quot; /&gt;</code> 라고만 써도 적용되고, 지원하지 않는 브라우저에서는 무시될 것이기 때문에 바로 적용가능할 것으로 보인다.</p><h3 id="Powerful"><a href="#Powerful" class="headerlink" title="Powerful"></a>Powerful</h3><p><img src="/images/google-io/new-apis-on-chrome.jpg" alt="네이티브 접근 API들"></p><p>“Powerful”에서는 웹 영역의 확장, 기존에서는 Native만 접근 가능했던 곳에 Web이 접근할 수 있도록 새로운 API들이 소개되었다. 예를 들어, 안드로이드 디바이스의 Native 공유 API가 웹에서 접근가능하게 되었다. 물론 이런 종류의 변화가 늘 그렇듯이 해당 기능은 Chrome에만 구현되어 있으므로 프로덕션에 바로 실제로 적용하기는 많이 어려울 것이다. 하지만 PWA와 결합한다면 상당부분 네이티브 앱의 역할을 가져올 수 있고, 이런 개선이 계속된다면 결국에는 웹(+ PWA)이 네이티브 앱들을 대체하는 수단으로 활용될 수도 있겠다는 생각이 든다. 이미 데스크탑 앱은 상당 부분 대체되기도 했고.</p><h3 id="Safe"><a href="#Safe" class="headerlink" title="Safe"></a>Safe</h3><p>“Safe”에서는 Chrome의 보안 정책의 변화를 소개했다. 가장 흥미로웠던 부분은 <a href="https://webauthn.guide/" target="_blank" rel="noopener">Webauthn</a>이었다. Webauthn은 웹에서 일반적으로 사용되는 인증방식인 ID/비밀번호 방식을 제거하기 위해, 모바일에서 주로 사용되는 인증방식인 생체인식등을 웹에서도 사용할 수 있게 만들어주는 API다. 이번에 처음 알게된 개념인데 알고보니 Safari를 제외하고 대부분의 모던 브라우저에서는 지원이 이미 되고있었던 API였다. 아직은 당장 사용이 어려워보이긴 했지만, iOS, Safari 등에서 구현된다면 도전적인 서비스에서는 사용할만 하겠다는 생각이 들었다.</p><h2 id="Building-Successful-Websites-Case-Studies-for-Mature-and-Emerging-Markets"><a href="#Building-Successful-Websites-Case-Studies-for-Mature-and-Emerging-Markets" class="headerlink" title="Building Successful Websites: Case Studies for Mature and Emerging Markets"></a>Building Successful Websites: Case Studies for Mature and Emerging Markets</h2><p><img src="/images/google-io/twitter-times-hulu.jpg" alt="트위터, 타임즈 인터넷, 훌루 로고ㄴ"></p><p>사실 큰 기대를 하고 들어간 세션은 아니었는데 의외로 꿀잼이었던 세션이다. 이 세션에서는 세 가지 실제 사례를 들어 각각 겪고있던 문제를 소개하고, 해당 문제를 해결하는데 어떻게 했는지, 그리고 그걸로 얼마나 비즈니스적 성과를 나타냈는지 소개했다.</p><p>발표에 연사자로 트위터와 Hulu에서 Product Manager 롤을 가지고 있는 분이 나왔는데, 엔지니어가 아닌 매니저가런 기술을 잘 알고 또 관심을 가지고 있다는 사실이 개인적으로 놀라웠다.</p><h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><p>가장 첫 번째 사례는 트위터였다. 트위터 유저라면 최근에 데스크톱 웹 디자인이 깔끔하게, 그리고 모바일과 유사하게 상당히 바뀌었다는 걸 알고 있을 것이다. 사실 트위터는 원래 “Twitter Lite”라는 가벼운 앱을 만들기 위해 2017년에 이미 웹 기술과 PWA를 이용해 모바일 앱을 만든 사례가 있었고 이것은 트위터의 모바일 웹으로도 사용되고 있었다. 하지만 데스크톱 UI는 모바일과 꽤 다른, 유저인 내가 봤을 때도 상당히 이질적인 느낌이었는데, 실제로도 다른 코드 베이스 위에서 운영되고 있었다. 결국 트위터는 새로운 기능을 추가하기 위해서는 데스크톱용 웹과 모바일 웹 두 가지의 코드 베이스에 모두 기능을 추가해야 했던 것이다.</p><p>그래서 트위터는 기존에 운영되던 모바일 웹 기반으로 반응형 웹 디자인을 적용해 새롭게 데스크톱 UI를 만들게 되었다. 다양한 환경을 대응하기 위해서 리액트를 사용해 Component Based Design을 적용했다. 간단하게 설명하면 하나의 컴포넌트가 다양한 플랫폼에 대응되게끔 설계하는 것이다. 이를 통해 트위터는 데스크톱 부터 피처폰까지 넓은 범위를 소화할 수 있었다.</p><h3 id="Times-Internet"><a href="#Times-Internet" class="headerlink" title="Times Internet"></a>Times Internet</h3><p>타임즈 인터넷은 인도의 테크 기업이다. 인도는 인터넷 속도도 느리고, 대부분의 디바이스 사양이 좋지 않기 때문에 이 세션에서는 그런 환경적 한계를 어떻게 소프트웨어로 극복할 수 있었는지에 대해서 다뤘다. 타임즈 인터넷은 웹을 통해 뉴스를 서비스하고 있는데, 인터넷 속도가 느렸기 때문에 PWA가 중요하게 작용했다.</p><p>먼저 느린 인터넷 속도를 극복하기 위해 PWA의 오프라인 캐싱, Lighthouse의 <a href="https://web.dev/performance-budgets-101" target="_blank" rel="noopener">Performance Budgets</a>을 사용했다. Lighthouse의 Performance Budgets은 개발자 키노트에서도 소개되었는데, JavaScript, CSS 혹은 이미지 리소스등의 애셋 크기를 제한하는 도구다.</p><p>이런 도구를 통해 오프라인 혹은 인터넷 속도가 낮은 상황에서도 유저 경험을 크게 해치지 않을 수 있었고 그로 인해 가장 중요한 광고 매출을 59% 증대시켰다고 한다.</p><h3 id="Hulu-Desktop"><a href="#Hulu-Desktop" class="headerlink" title="Hulu Desktop"></a>Hulu Desktop</h3><p>Hulu는 Netflix와 비슷한 OTT 서비스다. Hulu는 원래 유저들에게 데스크톱 앱을 제공했는데 이 데스크톱 앱을 PWA를 이용한 웹앱으로 전환한 사례를 발표했다. Hulu는 가지고 있던 “레거시” 데스크톱 앱을 Fade out 시키고 유저들을 웹으로 전환시키려고 했지만 유저들의 피드백이 좋지 않았다. 가장 큰 이유는 “설치가능성”. 그러니까, 웹에서 제공하는 서비스였기 때문에 설치할 수 없다는 점이 좋지 않은 피드백을 받았다고 한다. 이를 해결하기 위해 Hulu는 데스크톱 PWA를 적용했다. 이를 적용하는데 개발자 1명이 2주밖에 들이지 않았다는 PWA 칭찬인지 엔지니어 자랑인지 알 수 없는 말을 했다.</p><p>Hulu의 사례는 사실 PWA 데스크톱을 적용하기 이상적인 케이스라는 생각이 들었다. 사실 PWA가 아닌 Electron을 사용하는 케이스는 대부분 Native 자원에 접근하기 위해서인데 Hulu의 경우 단순한 동영상 OTT 서비스이므로 Native 자원에 접근해야할 니즈가 거의 없기 때문이고 기존에도 웹 서비스를 잘 제공했고, 단순히 Install 가능성만 추가로 충족시키면 되었기 때문이다.</p><hr><p>첫 날 들은 세션은 이 정도다. 현재 2일차 Google I/O가 진행중인데 여기에 대한 후기는 Day 2 후기에 이어서 남길 예정이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/google-io/badge.jpg&quot;/&gt;&lt;p&gt;GDG Korea WebTech Organizer로서 Google Korea로부터 숙소 비용 및 티켓 비용을 전액 지원받아 Google I/O 2019에 참가하게 되었다. 사
      
    
    </summary>
    
      <category term="Log" scheme="https://hyunseob.github.io/categories/Log/"/>
    
    
      <category term="Log" scheme="https://hyunseob.github.io/tags/Log/"/>
    
      <category term="Google I/O" scheme="https://hyunseob.github.io/tags/Google-I-O/"/>
    
      <category term="GDG" scheme="https://hyunseob.github.io/tags/GDG/"/>
    
  </entry>
  
  <entry>
    <title>2018년 돌아보기</title>
    <link href="https://hyunseob.github.io/2018/12/31/2018-year-in-review/"/>
    <id>https://hyunseob.github.io/2018/12/31/2018-year-in-review/</id>
    <published>2018-12-31T11:41:09.000Z</published>
    <updated>2018-12-31T12:01:33.637Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/elijah-hail-729630-unsplash.jpg"/><p>올해도 어김없이 회고 시즌이 돌아왔다. 매년 느끼는 거지만 시간이 너무 빨리 흘러간다. 다른 개발자 분들의 회고를 페이스북이나 트위터 등에서 보면서 나도 늦지 않게 빨리 써야지라고 생각하다 2018년이 정말로 얼마 남지 않은 지금 이제서야 키보드를 두들기기 시작했다.</p><p>내가 삶에서 중요하게 여기는 가치 중에서 “성장”과 “변화”가 있다. 2017년까지의 나는 대부분 성장에만 포커스를 맞추고 살아왔다고 생각한다. 올해는 의도적으로 그런 건 아니지만, 성장보다는 여러가지 변화를 거듭한 한 해가 된 것 같다. 물론 2018년에도 분명 성장하긴 했지만 작년보다는 좀 부족하다고 생각한다.</p><h1 id="이직"><a href="#이직" class="headerlink" title="이직"></a>이직</h1><p><blockquote class="instagram-media" data-instgrm-captioned="" data-instgrm-permalink="https://www.instagram.com/p/Bqzi8MMlHgC/?utm_source=ig_embed&amp;utm_medium=loading" data-instgrm-version="12" style=" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:540px; min-width:326px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);"><div style="padding:16px;"> <a href="https://www.instagram.com/p/Bqzi8MMlHgC/?utm_source=ig_embed&amp;utm_medium=loading" style=" background:#FFFFFF; line-height:0; padding:0 0; text-align:center; text-decoration:none; width:100%;" target="_blank"> <div style=" display: flex; flex-direction: row; align-items: center;"> <div style="background-color: #F4F4F4; border-radius: 50%; flex-grow: 0; height: 40px; margin-right: 14px; width: 40px;"></div> <div style="display: flex; flex-direction: column; flex-grow: 1; justify-content: center;"> <div style=" background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; margin-bottom: 6px; width: 100px;"></div> <div style=" background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; width: 60px;"></div></div></div><div style="padding: 19% 0;"></div><div style="display:block; height:50px; margin:0 auto 12px; width:50px;"><svg width="50px" height="50px" viewbox="0 0 60 60" version="1.1" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="translate(-511.000000, -20.000000)" fill="#000000"><g><path d="M556.869,30.41 C554.814,30.41 553.148,32.076 553.148,34.131 C553.148,36.186 554.814,37.852 556.869,37.852 C558.924,37.852 560.59,36.186 560.59,34.131 C560.59,32.076 558.924,30.41 556.869,30.41 M541,60.657 C535.114,60.657 530.342,55.887 530.342,50 C530.342,44.114 535.114,39.342 541,39.342 C546.887,39.342 551.658,44.114 551.658,50 C551.658,55.887 546.887,60.657 541,60.657 M541,33.886 C532.1,33.886 524.886,41.1 524.886,50 C524.886,58.899 532.1,66.113 541,66.113 C549.9,66.113 557.115,58.899 557.115,50 C557.115,41.1 549.9,33.886 541,33.886 M565.378,62.101 C565.244,65.022 564.756,66.606 564.346,67.663 C563.803,69.06 563.154,70.057 562.106,71.106 C561.058,72.155 560.06,72.803 558.662,73.347 C557.607,73.757 556.021,74.244 553.102,74.378 C549.944,74.521 548.997,74.552 541,74.552 C533.003,74.552 532.056,74.521 528.898,74.378 C525.979,74.244 524.393,73.757 523.338,73.347 C521.94,72.803 520.942,72.155 519.894,71.106 C518.846,70.057 518.197,69.06 517.654,67.663 C517.244,66.606 516.755,65.022 516.623,62.101 C516.479,58.943 516.448,57.996 516.448,50 C516.448,42.003 516.479,41.056 516.623,37.899 C516.755,34.978 517.244,33.391 517.654,32.338 C518.197,30.938 518.846,29.942 519.894,28.894 C520.942,27.846 521.94,27.196 523.338,26.654 C524.393,26.244 525.979,25.756 528.898,25.623 C532.057,25.479 533.004,25.448 541,25.448 C548.997,25.448 549.943,25.479 553.102,25.623 C556.021,25.756 557.607,26.244 558.662,26.654 C560.06,27.196 561.058,27.846 562.106,28.894 C563.154,29.942 563.803,30.938 564.346,32.338 C564.756,33.391 565.244,34.978 565.378,37.899 C565.522,41.056 565.552,42.003 565.552,50 C565.552,57.996 565.522,58.943 565.378,62.101 M570.82,37.631 C570.674,34.438 570.167,32.258 569.425,30.349 C568.659,28.377 567.633,26.702 565.965,25.035 C564.297,23.368 562.623,22.342 560.652,21.575 C558.743,20.834 556.562,20.326 553.369,20.18 C550.169,20.033 549.148,20 541,20 C532.853,20 531.831,20.033 528.631,20.18 C525.438,20.326 523.257,20.834 521.349,21.575 C519.376,22.342 517.703,23.368 516.035,25.035 C514.368,26.702 513.342,28.377 512.574,30.349 C511.834,32.258 511.326,34.438 511.181,37.631 C511.035,40.831 511,41.851 511,50 C511,58.147 511.035,59.17 511.181,62.369 C511.326,65.562 511.834,67.743 512.574,69.651 C513.342,71.625 514.368,73.296 516.035,74.965 C517.703,76.634 519.376,77.658 521.349,78.425 C523.257,79.167 525.438,79.673 528.631,79.82 C531.831,79.965 532.853,80.001 541,80.001 C549.148,80.001 550.169,79.965 553.369,79.82 C556.562,79.673 558.743,79.167 560.652,78.425 C562.623,77.658 564.297,76.634 565.965,74.965 C567.633,73.296 568.659,71.625 569.425,69.651 C570.167,67.743 570.674,65.562 570.82,62.369 C570.966,59.17 571,58.147 571,50 C571,41.851 570.966,40.831 570.82,37.631"/></g></g></g></svg></div><div style="padding-top: 8px;"> <div style=" color:#3897f0; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:550; line-height:18px;"> Instagram에서 이 게시물 보기</div></div><div style="padding: 12.5% 0;"></div> <div style="display: flex; flex-direction: row; margin-bottom: 14px; align-items: center;"><div> <div style="background-color: #F4F4F4; border-radius: 50%; height: 12.5px; width: 12.5px; transform: translateX(0px) translateY(7px);"></div> <div style="background-color: #F4F4F4; height: 12.5px; transform: rotate(-45deg) translateX(3px) translateY(1px); width: 12.5px; flex-grow: 0; margin-right: 14px; margin-left: 2px;"></div> <div style="background-color: #F4F4F4; border-radius: 50%; height: 12.5px; width: 12.5px; transform: translateX(9px) translateY(-18px);"></div></div><div style="margin-left: 8px;"> <div style=" background-color: #F4F4F4; border-radius: 50%; flex-grow: 0; height: 20px; width: 20px;"></div> <div style=" width: 0; height: 0; border-top: 2px solid transparent; border-left: 6px solid #f4f4f4; border-bottom: 2px solid transparent; transform: translateX(16px) translateY(-4px) rotate(30deg)"></div></div><div style="margin-left: auto;"> <div style=" width: 0px; border-top: 8px solid #F4F4F4; border-right: 8px solid transparent; transform: translateY(16px);"></div> <div style=" background-color: #F4F4F4; flex-grow: 0; height: 12px; width: 16px; transform: translateY(-4px);"></div> <div style=" width: 0; height: 0; border-top: 8px solid #F4F4F4; border-left: 8px solid transparent; transform: translateY(-4px) translateX(8px);"></div></div></div></a> <p style=" margin:8px 0 0 0; padding:0 4px;"> <a href="https://www.instagram.com/p/Bqzi8MMlHgC/?utm_source=ig_embed&amp;utm_medium=loading" style=" color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;" target="_blank">The seat that I loved.</a></p> <p style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;"><a href="https://www.instagram.com/hyunseob.lee/?utm_source=ig_embed&amp;utm_medium=loading" style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px;" target="_blank"> HyunSeob</a>(@hyunseob.lee)님의 공유 게시물님, <time style=" font-family:Arial,sans-serif; font-size:14px; line-height:17px;" datetime="2018-11-30T13:01:23+00:00">2018 11월 30 5:01오전 PST</time></p></div></blockquote> <script async src="//www.instagram.com/embed.js"></script></p><p>약 2년 2개월 정도를 다닌 스튜디오씨드를 퇴사하고 토스에 합류한지 이제 막 1개월 정도가 되었다. 올해 나에게는 가장 큰 변화 아닐까 싶다. 이 블로그를 통해서는 공식적으로 밝힌 적이 없지만 개인적으로 나를 아시는 분이나 페이스북에 친구가 되어있는 분이라면 이미 알고 계실 것이다.</p><p>2년 2개월이 그리 길지는 않은 시간인데, 그 사이에 형성된 이미지가 있는지 지인 분들께 말씀드리면 대부분 놀라는 반응이었다. 주변 지인에게도 알리지 않고 조용하게 준비하기도 했었고. 이직 동기에 대해서 묻는 질문이 많았는데, 너무 진부하게 들리기는 하지만 “새로운 도전을 해보고 싶었다”가 나의 대답이다. 스튜디오씨드를 떠나고 싶어서 이직한 것이 아니라 토스의 문화를 경험하고 다른 방식의 성장을 이루고 싶었기에 이직했다. 또 성장을 경험하기에 환경의 변화만큼 좋은 해법이 없다고도 생각하고. 덕분에 2년 만에 <a href="https://hyunseob.github.io/resume">이력서</a>를 업데이트 했다.</p><p>스튜디오씨드에서도 너무 좋은 사람들을 만났고, 나름대로 허물없이 친하게 지냈던 동료들이 많아서 내색은 안 했지만 마음이 많이 아프기도 했다. 나오는 날에는 쓸쓸함과 함께 많은 감정이 교차했다.</p><h1 id="일"><a href="#일" class="headerlink" title="일"></a>일</h1><h2 id="스튜디오씨드"><a href="#스튜디오씨드" class="headerlink" title="스튜디오씨드"></a>스튜디오씨드</h2><p>작년에는 새로운 기술을 많이 접하면서 견문을 넓혔었다면, 올해는 넓이보다는 깊이에 조금 더 집중했던 것 같다.이미 조금씩 알고만 있었던 스킬들의 성숙도를 높여가면서 과거에 짰던 코드도 리팩토링하고 재미있게 일했다. 특히 올해 중순쯤 같은 포지션으로 안도형님이 입사하면서 한층 긴장할 수 있는 계기가 되었고 서로 좋은 영향도 많이 주고받았던 것 같다.</p><p>2017년 말부터 내가 맡아서 하고 있던 새로운 프로젝트도, 결국 1차적으로 개발 완료한 후 납품도 되었다. 그 전까지는 나 스스로에 대한 확신이 없었는데, 나도 시작부터 끝까지 맡아서 딜리버리할 수 있다는, 내가 처음부터 끝까지 디자인해서 짠 앱도 멀쩡히 돌릴 수 있다는, 소중한 자신감과 경험을 얻었던 순간이기도 했다. 나에게는 스튜디오씨드에서 했던 가장 큰 도전이기도 했다.</p><p>하지만 도전의 시간은 길지 않았다. 새로운 프로젝트를 시작할 때, 전반적인 구조를 디자인하고 재미있는 기술을 가져다 쓰면서 느꼈던 즐거움도 잠시, 곧 유지보수가 시작되면서 지루함이 느껴졌고, 일도 더디게 했다. 즐거움을 다른 곳에서 찾기 시작했다. 자기계발을 접어두고 술도 자주 마시고 사람들도 많이 만났다. 결국 이 지루함도 내가 이직한 원인이 되었던 것 같다.</p><h2 id="페스타"><a href="#페스타" class="headerlink" title="페스타"></a><a href="https://festa.io" target="_blank" rel="noopener">페스타</a></h2><p>지금은 더 이상 참여하고 있지 않지만, 작년 12월 즈음 페스타팀에 프론트엔드 엔지니어로 합류했다. 그리고 페스타 초기버전의 프론트엔드의 대부분을 내가 작업했었다. 현재 내 코드가 얼마나 남아있는지는 잘 모르겠지만 아직 문제없이 되고 있는 걸 보니 그래도 내가 제 몫은 한 것 같아 뿌듯한 마음이 있다. 위에서 언급한 새로운 프로젝트와 작업기간이 겹쳐서, 사실상 기술스택이 거의 똑같았다. 사이드 프로젝트였지만 일하는 방식도 애자일하게 스프린트도 만들고, 회고도 하고, 스토리 포인트도 정하면서 재밌게 일했다.</p><p>관두게 된 이유는 심플하다. 재미가 없어졌다. 처음에는 재미로 시작했는데 중간에 업무랑 같이하면서 체력적으로 힘들기도 했지만, 그래도 새로운 서비스를 만들어가는 재미, 새로운 기술 써보는 재미가 있어서 그럭저럭 할만하다고 느꼈다. 페스타의 첫 버전을 런칭하고 나서는 급격히 그 재미가 줄어들었다. 사실 사용하는 기술조차 회사에서 하던 것과 거의 같아서, 퇴근하고 회사일을 또 하는 기분이 들면서 점점 코드를 짜는 시간이 줄어들었다. 당시 이곳저곳에서 스트레스를 많이 받고 있었던지라 정리해야겠다는 마음이 들었고, 정리하게 됐다.</p><p>팀에서 나오기는 했지만 여전히 애정이 남아있고 잘 되기를 바라는 서비스 중 하나다. 실제로 이벤트를 많이 열어야하는 입장에서 사용하기가 편리하기도 하고.</p><h1 id="블로그"><a href="#블로그" class="headerlink" title="블로그"></a>블로그</h1><p>올해 블로그 성적은 정말이지 처참하다. 매년 “작년보다 더!”를 외쳤지만 블로그를 시작한 이래 연도별 포스팅 갯수가 늘어난 적이 없었다. 올해는 (이 글을 제외한다면) 겨우 다섯 개의 포스팅을 했다. 글 하나하나를 나름대로 정성스럽게 써서 각 포스팅의 질이 상대적으로 높았다고는 생각하지만, 그래도 솔직히 너무 놀지 않았나.. 싶기는 하다. 자기 변호를 좀 하자면, 쓰다만 글도 꽤 있다. 이제 이것보다 적게 쓰기도 어려우니 내년에는 그래도 올해보다는 글을 많이 쓰지 않을까 싶다.</p><p>그나마 잘했던 걸 하나 꼽아보자면 <a href="https://hyunseob.github.io/2018/08/12/do-you-need-to-use-ts/">“타입스크립트, 써야할까?”</a>라는 글을 쓴 것. 이 글 자체도 꽤 많이 언급되었고 잘 됐지만, 정말 예전부터 타입스크립트를 쓰면서 꼭꼭 말하고 싶었던 주제였는데 그걸 글로 다 정리하고 설득력있게 풀어 냈다는 게 지금도 꽤 만족스럽다. 그리고 놀랍게도, 블로그 방문자 수는 꾸준히 성장 중이다.</p><h1 id="커뮤니티-활동"><a href="#커뮤니티-활동" class="headerlink" title="커뮤니티 활동"></a>커뮤니티 활동</h1><h2 id="GDG-Korea-WebTech"><a href="#GDG-Korea-WebTech" class="headerlink" title="GDG Korea WebTech"></a>GDG Korea WebTech</h2><p>GDG Korea WebTech 오거나이저로 합류했다. 구글 웹 기술과는 별로 친하지 않은 편이라서 공부와 노력을 많이 해야 할 것 같다. <a href="https://festa.io/events/81" target="_blank" rel="noopener">Chrome Dev Meetup #2</a>와 <a href="https://festa.io/events/140" target="_blank" rel="noopener">DevFest WebTech 2018</a>을 기획하고 주최했다. 사실 이전부터 TypeScript Korea 운영진을 하면서 이벤트를 준비한 경험이 없지는 않지만 내가 주체적으로 기획하고 운영했던 경험은 부족해서 쉽지 않았다. 그래도 좋은 사람들도 많이 만나고 재미있는 행사도 많아서 즐거웠다. 내년에도 재미있는 이벤트 많이 기획해보고 싶다.</p><h2 id="TypeScript-Korea"><a href="#TypeScript-Korea" class="headerlink" title="TypeScript Korea"></a>TypeScript Korea</h2><p>2018년에는 두 번의 <a href="https://festa.io/events/113" target="_blank" rel="noopener">밋업</a>을 열었는데 두 번째 밋업 때 여러가지 운영미스가 있어서 좀 안타까웠다. 올해 활동을 열심히 하지는 못했는데, 내년엔 노력해야겠다.</p><h2 id="Naver-FE-DevTalk"><a href="#Naver-FE-DevTalk" class="headerlink" title="Naver FE DevTalk"></a>Naver FE DevTalk</h2><p>Naver FE DevTalk에서 MobX와 MobX State Tree를 주제로 발표했다. 부끄럽지만 영상도 첨부한다.</p><iframe width="700" height="320" src="https://www.youtube.com/embed/4yUgM7SaYUU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>발표는 나름 열심히 준비했다. 다른 곳도 아니고 현업 네이버 엔지니어 분들이 보는 곳이라서 긴장이 많이 됐다.</p><h1 id="조금-개인적인-것들"><a href="#조금-개인적인-것들" class="headerlink" title="조금 개인적인 것들"></a>조금 개인적인 것들</h1><h2 id="졸업"><a href="#졸업" class="headerlink" title="졸업"></a>졸업</h2><p>졸업이 자잘한 이벤트라고 할 수는 없지만 2018년에 딱히 졸업을 위해 한 것이 없기 때문에 큰 사건은 아닌 것 같다. 졸업장이 생겼고, 뭔가 서류를 써야할 때 대졸이라고 적는 정도. 뭐, 고졸이던 때와 비교해서 일상에 차이는 없다.</p><h2 id="운전"><a href="#운전" class="headerlink" title="운전"></a>운전</h2><p>2018년의 소소한 목표 중 하나가 운전면허 따기였는데, 무난하게 운전면허를 땄다. 그리고 남들처럼 장롱으로 직행할 뻔 했다가 우연히 아빠가 차를 새로 사셔서 원래 아빠가 쓰던 옛날 차를 얻게 되었다. 덕분에 장롱면허 신세는 면했다. 다만 그 사이 접촉사고를 세 번이나 내서 마음이 많이 힘들었다.</p><h2 id="이사"><a href="#이사" class="headerlink" title="이사"></a>이사</h2><p>전세자금대출을 받아 자취방을 역삼동으로 옮겼다. 학자금을 제외하면 대출도 처음해보는 경험이었고 전세계약도 처음이라서 순탄치가 않은데다가 돈도 정말 아슬아슬해서 너무 정신이 없었고 불안했다. 다행히도 결국 계약을 마무리 잘해서 성공적으로 이사도 했다. 하지만 집이 문제가 많아서 다시 이사하고 싶다..</p><h2 id="임플란트"><a href="#임플란트" class="headerlink" title="임플란트"></a>임플란트</h2><p>치과를 작년 말부터 다니기 시작해서, 여러가지 치료를 받고 올해 임플란트 시술을 받았다. 딱히 치아에 문제가 없어도 치과는 주기적으로 방문해야 한다는 걸 깨달았다.</p><h2 id="영어"><a href="#영어" class="headerlink" title="영어"></a>영어</h2><p>전 직장에서 외국인 친구와 급격히 친해지면서 영어가 많이 늘었다. 일단 자신감 자체가 전과는 비교할 수 없을 정도로 많이 늘었다. 이직으로 인해 앞으로 영어로 대화할 일이 많이 없어져서 안타깝고 조금 슬프다.</p><h2 id="다이어트"><a href="#다이어트" class="headerlink" title="다이어트"></a>다이어트</h2><p>올해 중순 쯤 다이어트를 시작해서 9kg 정도 몸무게를 감량했다. 토스가 밥을 너무 잘 먹여서 살이 1kg 정도 도로 찌기는 했지만.. 아직은 유지 중이다.</p><h1 id="2019년-목표"><a href="#2019년-목표" class="headerlink" title="2019년 목표"></a>2019년 목표</h1><p>분명히 이 리스트에 있는 것들 다 안 지킬 건 알지만 그래도 백로그처럼 써봐야겠다.</p><ul><li>블로그 Gatsby 이관 (가급적이면 테마도 마이그레이션)</li><li>GDG Korea 웹 사이트 만들기</li><li>토스 멤버로서 성장하기</li><li>블로그 올해보단 많이 하기</li><li>헬스장 꾸준히 나가기</li></ul><h1 id="2018년은"><a href="#2018년은" class="headerlink" title="2018년은.."></a>2018년은..</h1><p>그래도 나에게는 특별하고 만족스러운 한 해였다. 생각해보면 내 선택이나 행동에 전반적으로 운이 따라 줬던 것 같다. 그래서 운이 나의 게으름을 어느 정도 상쇄시킨 것 같다. 이직도 그렇고, 커뮤니티 활동도 그렇고, 기회도 자주 찾아왔고, 좋은 사람들을 많이 만날 수 있었다. 2018년에 도와주신 모든 분들께 감사드리고, 2019년도 모두 같이 성장하는 한해가 되었으면 좋겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/elijah-hail-729630-unsplash.jpg&quot;/&gt;&lt;p&gt;올해도 어김없이 회고 시즌이 돌아왔다. 매년 느끼는 거지만 시간이 너무 빨리 흘러간다. 다른 개발자 분들의 회고를 페이스북이나 트위터 등에서 보면서 나도
      
    
    </summary>
    
      <category term="Log" scheme="https://hyunseob.github.io/categories/Log/"/>
    
    
      <category term="Year in review" scheme="https://hyunseob.github.io/tags/Year-in-review/"/>
    
  </entry>
  
  <entry>
    <title>[번역] TypeScript at Google</title>
    <link href="https://hyunseob.github.io/2018/11/27/typescript-at-google/"/>
    <id>https://hyunseob.github.io/2018/11/27/typescript-at-google/</id>
    <published>2018-11-27T10:45:49.000Z</published>
    <updated>2018-12-31T10:15:02.276Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript-at-google.png"/><blockquote><p>이 포스트는 <a href="http://neugierig.org/" target="_blank" rel="noopener">Evan Martin</a>의 글, <a href="http://neugierig.org/software/blog/2018/09/typescript-at-google.html" target="_blank" rel="noopener">TypeScript at Google</a>을 원 저자의 동의하에 번역한 것이다. 의역이 매우 많고 오역이 있을 수 있으니 가급적 원문도 같이 참고하길 바란다.</p></blockquote><p>나는 이제 TypeScript를 2년 넘게 써왔다. 따라서 이에 대해 리뷰하는 글을 하나 둘 정도 써야겠다고 생각했다. 나는 전형적인 면책선언(Disclaimer)와 함께 글을 시작하려고 한다. 나는 그냥 Google에서 일하는 수 만 명 중에 한 명의 엔지니어 일뿐이고, 여기에 적힌 의견에 완전히 동의하지 않는 사람들도 있다.</p><p>Google은 웹 어플리케이션을 일찌감치 채택했다. Gmail이 벌써 14년이 되었다고 하면 믿을 수 있겠는가? 그 당시의 JavaScript는 완전히 미쳤었다(madness). Gmail 엔지니어들은 Internet Explorer의 구린 가비지 컬렉션 알고리즘에 대해 매우 걱정이 많았다. 따라서 엔지니어들은 가비지 컬렉션이 중지되는 상황을 피하기 위해서 for 루프 밖으로 문자열(String) 표현을 직접 호이스팅 시킬 필요가 있었다. 나는 최근 그 시절의 설계 문서를 찾았는데, 그 문서에서는 우리가 JavaScript를 “미니파이(Minifying)” 한다고 부르는 작업을 고려하고 있었다. 그러나 그 중 몇몇 후보 도구는 Windows 전용이었다. 요즘에는 상상할 수도 없는 일이다.</p><p>그 후 몇 년 간, Google은 큰 JavaScript 앱을 개발하는 데 쓰일 수 많은 기반 기술을 개발했다. 예를 들면, 소스 파일이 상호의존성을 표기하도록 만드는 모듈 시스템이 있다. 소스 파일을 합치고 미니파이해서 브라우저에 호환되는 결과물로 만드는 번들러도 있다. 또 다른 어떤 도구는 동적으로 로드할 수 있는 진입점과 서빙을 위한 공통 부분 요소를 통해 앱의 의존성 그래프를 분석한다. 서버 사이드 렌더링은 일반적이다. 모든 이러한 개념들은 요즘의 웹 개발자들에게는 친숙한 것들이지만, Google의 기술 스택의 발전은 오늘날의 발전과 병렬적이지만 더 앞서서 개발되어왔기 때문에, 결과적으로 개념상으로는 비슷하지만 구체적으로는 달라졌다. 프로세스, 도구, 심지어는 이러한 개념들의 이름까지도 완전히 다르다.</p><p>병렬적인 진화의 다른 예는, Google, Facebook, Microsoft가 JavaScript에 정적 체크를 더한 컴파일러를 각각 비슷하지만 서로 호환되지 않게 만들었다는 것이다. 그 중 Google의 컴파일러는 구어체로 Closure라고 한다. (Clojure 언어와 헷갈리지 말자. 더 헷갈리는 건 ClojureScript가 Closure 컴파일러를 쓴다는 것이다.)</p><p>Google의 JavaScript 스택은 너무나 뛰어났고, Google이 인터넷의 얼굴을 바꾸어버린 웹 앱을 만들고 유지보수할 수 있게 해주었다. (Google 지도가 릴리즈된 시점이 얼마나 놀라운지 기억하는가? 이제는 위젯 형태의 드래그 가능한 지도를 만드는 것은 너무나 당연하다.) 어떤 부분들은 오늘날의 기술을 능가한다. 예를 들면, Closure 컴파일러는 타입 정보를 사용해서 코드를 최적화하고, 핫 로딩 청크 바운더리를 가로지르는 인라인 함수를 사용하고, 사용하지 않는 코드를 제거해 <a href="https://bit.ly/2KA9LSo" target="_blank" rel="noopener">개별적인 심볼</a>로 만들 수 있는, 여전히 가장 세련된 JavaScript 최적화 도구일지도 모른다.</p><p>Google의 JavaScript 스택은 문제 또한 안고있다. Closure가 린터에서부터 출발해 점진적으로 진화해왔다는 사실은 Closure가 정적 타입 문법을 주석에서 사용해야 한다는 것을 의미한다. Closure는 예측하기 어려운 시맨틱을 가졌고 느리며, 버그가 많다. 그리고 코드를 정확하게 작성하지 않으면 맹글링(Mangling)하는 경향이 있다. 오픈 소스임에도 불구하고, 이러한 이유들 때문에 업계 전반적으로 사용되지 않았다. Closure에 익숙한 구글러들을 고용한 회사들을 빼고 말이다. 나는 Google 내에서 JavaScript가 낮은 평가를 받고 있다고 생각하는데, 우리의 까다로운 도구 Closure가 정적 언어의 수다스러움(verbosity)을 동적인 언어의 예측불가능성과 결합했기 때문이라고 생각한다.</p><p>그 사이 Google 밖에서도, JavaScript는 진화를 계속했고 점점 더 많은 인기를 얻었다. 앞서 말한 IE 가비지 컬렉션 버그를 우회하기 위해, 우리는 Chrome을 만들었고 Chrome은 v8을, v8은 Node.js를 낳았다. 이는 요즘 대부분의 웹 도구가 그 자체로 JavaScript로 만들어졌다는 걸 의미한다. 과거에 이러한 도구를 만드는데 쓰였었던 Java와는 달리 말이다. 모듈 시스템(UMD, AMD, CommonJS)은 급격히 늘어났다. (ES6가 등장해서 자체 모듈 시스템을 개발했지만, 다른 시스템들과는 어떤 이유로 호환되지 않는다. 에휴.) npm은 도구들과 라이브러리가 공유되는 방식을 통합했다. Webpack은 개발자가 개발하는 동안 실행되고 있는 앱에 <a href="https://webpack.js.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">동적으로 모듈을 교체</a>할 수 있는 기능을 제공했다.</p><p>Google은 이 중 어떤 것도 쓰지 않는다. 숙련된 웹 개발자가 Google에 나타났지만, 그가 다른 시간대에 방문한 것과 같다. Google에는 SASS 같은 CSS 전처리 언어가 있지만 이는 SASS가 아니며 누구도 그것을 좋아하지 않는다. 어떤 팬시한 청크 스플리터도 있지만 이 도구는 써드 파티 JavaScript 라이브러리를 지원하지 않는다. 왜냐하면 이 도구는 JavaScript 라이브러리 생태계가 갖춰지기 전에 만들어졌기 때문이다.</p><p>이건 모두 역사에 불과하다. 누군가 Google이 그런 길을 가지 말았어야 했다고 주장할 수 있지만, 그렇게 한다고 우리가 이러한 상황에 있다는 사실을 바꾸지는 않는다. 대신, 흥미로운 질문을 해보자. “우리는 이제 어디로 가야하는가?” 몇 가지의 옵션이 있다. 내 관점은 물론 내 선호에 따라 편향되어 있다.</p><p>첫번째 매력적인 옵션은 이 망가진 행성을 버리고 JavaScript를 아예 포함하지 않는 새로운 행성에 정착하는 것이다. 만약 우리가 GWT(Java를 JavaScript로 컴파일 하는 Google의 프로젝트) 혹은 Dart(새로운 언어를 JavaScript로 컴파일 하는 Google의 프로젝트) 혹은 WASM 혹은 당신이 좋아하는 언어 무엇이든, Clojure? Haxe? Elm?..  등에 더 투자했다면 우리는 JavaScript에 대해 아예 걱정할 필요도 없을 것이다.</p><p>PL의 팬으로서 나는 이 옵션을 꽤 좋아한다. 그 언어들의 자격에 대해 신중하게 분석한 자료를 주고 싶지만, 이 포스팅은 충분히 길고, 그에 대한 토론은 별도의 포스팅이 되어야 한다고 생각한다. 그 토론 전에, 몇 가지 고려해야 할 사항이 있다. 만약 다른 언어를 채택하게 된다면, (1) 말 그대로, 우리가 가진 수백만 줄의 코드를 재활용 할 수 없다. “새로운 언어로 처음부터 다시 작성”하는 것은 어떤 상황에서는 적절한 선택이지만, 그게 Gmail 엔지니어들의 시간을 적절히 사용하는 방식인지에 대해서는 논쟁의 여지가 있다. 그리고 (2) 앞서 언급한, 우리가 고용하고자 하는 경험 있는 프론트엔드 프로그래머에게도 거의 도움이 되지 않는다.</p><p>모든 것을 새로 쓰는 것을 바꿔 말하면 아무것도 바꾸지 않는 것이다. 오픈된 JavaScript 세계는 아마추어 코드와 left-pad<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>같은 재앙으로 가득 차 있다고 지적할 수 있다. 좋은 엔지니어는 Google이 프론트엔드를 구축하는 특이한 방식에 적응할 수 있기 때문에, 우리는 언제나 우리의 자체 도구를 개선하고 만들 수 있다.  Google이 만들고 있는 앱의 요구사항은 다른 회사들이 만드는 웹 앱들과 성격이 다르다(Google 검색 페이지는 하루에 수십억 회 조회된다)는 점은 우리의 자체 도구가 더 우월하며 실제로 필요하다는 것을 뜻한다. 나는 이러한 관점에도 호의적이다. 여기에는 두 가지 트레이드오프 지점이 있다고 생각한다. 하나는 우리의 자체 도구를 만드는 것이 합리적인 지점이고, 다른 하나는 우리가 자체 도구를 만듦으로서 주류로부터 갈라지도록 만드는 지점이다. 논쟁은 이제 우리가 그 사이 어디에 있느냐는 것이다. 나는 Google이 후자 쪽으로 너무 멀리 왔다고 생각한다. 우리는 C++에 의존하기 때문에 LLVM과 Clang에 기여하여 도움이 될 수 있지만, 우리의 자체 LLVM을 만드는 것으로부터는 많은 부가가치를 얻을 수 없을 것이다.</p><p>이러한 사실은 나의 소규모 팀이 추구하고 있던 중간 지점으로 이끌었다. 그것은 점진적으로 적절한 외부 도구를 도입하고 우리의 기존 코드 기반과 연동하는 방법을 찾아내는 것이다. 이 작업은 별로 즐겁지는 않지만, (우리는 그냥 우리의 레거시 코드를 던져버리고 “맞는 방법으로 바로 하지”는 않았다.) 나는 겸허하게 수용하려고 하고, 내적인 요소보다는 외부적인 요소를 보고 싶다.</p><p>Google의 JavaScript 갈라파고스 섬으로부터 본토로 돌아가는 여정의 첫 번째는 잘 지원되는 정적 체커를 도입하는 것이었다. 그건 (1) 회사 내에서만 성장한 것이 아니고 (2) 우리의 기존 코드와 유사한 문법을 사용하지만 이미 유명했고 (3) JavaScript로 연결되도록 설계되었으며 (4) 맨 처음 Closure의 동기가 되었던, 대규모의 개발을 위해서 설계 되었다. 그리고 그 도구가 바로 TypeScript다. Closure 컴파일러의 장점은 최적화된 결과물인 반면, TypeScript는 훌륭한 유저 인터페이스를 가지고 있고, 최적화를 전혀 하지 않는다. 이 두 도구는 상호보완적이고, (특정 작업에서는) 같이 사용할 수 있다.</p><p>TypeScript는 이미 대부분의 프로젝트에서 잘 사용되고 있었기 때문에 (결국 이것도 채택한 이유 중 하나다.) 우리는 자리를 잡은 언어를 도입함으로서 많은 장점 그러니까, IDE 스타일의 코드 자동완성부터, StackOverflow 답변을 쉽게 찾을 수도 있는 등의 장점을 얻을 수 있다. 우리에게 남은 자작업은 기본적으로 통합이었다. 즉, 앱을 완전히 새로 다시 쓰지 않고 점진적으로 TypeScript로 옮기는 것이었다. 점진적으로 컴파일 하기 위해서 <a href="https://github.com/bazelbuild/rules_typescript" target="_blank" rel="noopener">Google 전체 빌드 시스템과의 통합</a>은 신중해야 했다. 이는 대규모 앱에 있어서 치명적일 수 있다. 한 모듈에서 내보내는 API에 영향을 주지 않는 변화는 하위 모듈의 재컴파일을 일으키지 않는다. Closure 타입/모듈 시스템으로의 통합은 ES6 TypeScript 모듈이 대부분의 타입 정보를 보존하면서 <a href="https://github.com/angular/clutz" target="_blank" rel="noopener">Google의 모듈 시스템을 가진 모듈을 임포트</a> 할 수 있다는 걸, 그리고 그 <a href="https://github.com/angular/tsickle" target="_blank" rel="noopener">반대</a>도 가능하다는 걸 의미한다. <a href="https://www.lucidchart.com/techblog/2017/11/16/converting-600k-lines-to-typescript-in-72-hours/" target="_blank" rel="noopener">한 회사는 우리가 만든 도구를 사용</a>하여 그들의 전체 코드 기반을 미니파이된 결과물을 보존하면서도 TypeScript로 자동으로 변환하는데 성공했다.</p><p>Google 내에서 TypeScript는 이제 어디에서나 가지각색으로 사용되고 있다. 누군가 Google의 제품을 사용한다면 그 사람은 약간의 TypeScript 코드와 상호작용한다고 말할 수 있다. TypeScript 그 자체로도 정적 타입 프로그래밍과 이제 관성이 붙은 JavaScript 생태계와 잘 균형을 이룬 흥미로운 절충안이다. 이는 우리 엔지니어들이 하는 일이기도 하다. 우리는 서로 다른 관심사 간의 균형을 맞추기 위해 흥미로운 타협을 한다. 나는 우리가 지난 몇 년 간 발견한 몇 가지 흥미로운 점들에 대해서 앞으로 좀 더 글을 쓰고 싶다. <a href="http://neugierig.org/software/blog/2016/02/revisiting-typescript.html" target="_blank" rel="noopener">처음으로 이 길로 들어섰을 때 내가 썼던 것</a>처럼, TypeScript는 좋은 트레이드오프를 만들고 있는 것 같다.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><strong>역자 주</strong>: left-pad 사건을 말한다. <a href="http://www.bloter.net/archives/253447" target="_blank" rel="noopener">링크</a> 참조.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/typescript-at-google.png&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;이 포스트는 &lt;a href=&quot;http://neugierig.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Evan Mart
      
    
    </summary>
    
      <category term="Opinion" scheme="https://hyunseob.github.io/categories/Opinion/"/>
    
    
      <category term="Opinion" scheme="https://hyunseob.github.io/tags/Opinion/"/>
    
      <category term="Translate" scheme="https://hyunseob.github.io/tags/Translate/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>타입스크립트, 써야할까?</title>
    <link href="https://hyunseob.github.io/2018/08/12/do-you-need-to-use-ts/"/>
    <id>https://hyunseob.github.io/2018/08/12/do-you-need-to-use-ts/</id>
    <published>2018-08-12T08:39:21.000Z</published>
    <updated>2018-12-31T10:15:02.261Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/do-you-need-to-use-ts.jpg"/><p><img src="/images/ts-survey.jpg" alt="TypeScript 설문조사 스크린샷"></p><p>최근 페이스북의 프론트엔드 개발그룹에 <a href="https://www.facebook.com/groups/webfrontend/permalink/1366303896847675/" target="_blank" rel="noopener">설문</a>이 있었다. 타입스크립트를 도입하지 않는 이유에 대해서 묻는 설문이었는데, 한 사람의 타입스크립트 유저로서 보고있기가 정말 괴로운 설문이었다. 그 글을 보고 예전부터 쓰다가 말고를 여러 번 반복한 주제를 꺼냈다. 주제는 바로 타입스크립트를 써야할, 혹은 쓰지 말아야 할 이유. 사실 이 글은 타입스크립트를 써야할 이유에 더 가까울 것이다. 타입스크립트를 좋아하시는 분들이 많이 계시지만 거부감을 가지고 계신 분들도 많이 보았기에 한 번 쯤은 글로서 설득해보고 싶었다.</p><p>본론을 시작하기에 앞서, 이 글은 일개 타입스크립트 유저가 작성한 매우 <strong>주관적인 의견</strong>이라는 점을 확실히 해두고 싶다. 기술에 절대적인 선이나 악은 존재하지 않으며, 마찬가지로 기술적인 선택에 있어 정답이나 왕도는 없다. 이 글의 논조 자체가 타입스크립트 우호적으로 작성되었기 때문에 이 글을 보는 독자 입장에서는 마치 타입스크립트를 사용하는게 답이라는 듯 말하는 것처럼 느껴질 수 있지만, 실제로는 절대 그렇게 생각하지 않는다고 밝혀두고 싶다. 개인의 선택을 존중한다.</p><p>본문에서는 크게 다섯 가지로 나눠 <em>러닝커브와 도입, 생산성, 안정성, 함수형 프로그래밍, 커뮤니티</em> 측면에서 타입스크립트를 살펴볼 것이다. 이 글에서는 타입스크립트만 콕 집어 다루고 있지만, Flow등의 다른 정적 타입 도구도 상황은 크게 다르지 않을 것이라 예상된다.</p><h2 id="📝-러닝커브-도입"><a href="#📝-러닝커브-도입" class="headerlink" title="📝 러닝커브, 도입"></a>📝 러닝커브, 도입</h2><p>사실 나는 아직도 타입스크립트를 주저하는 이유로 러닝커브를 꼽는 사람이 있다는 것에 놀랐다. 물론 타입스크립트가 쉽냐는 질문에는 쉽지 않다고 대답할 것 같다. 그렇지만 자바스크립트에 비해서 러닝 커브가 심하게 가파르다고 할 수도 없다. 더구나 ES2015, 그 이후의 문법에 익숙한 사용자라면 큰 어려움 없이 시작할 수 있다. 그 이유는 자바스크립트의 수퍼셋이라는 타입스크립트의 특성 때문이다.</p><p>타입스크립트의 가장 기본적인 기능은 단순히 자바스크립트에 타입 표기법을 추가하는 것이기 때문에, 만약 <code>string</code>이나 <code>number</code>등의 자료형을 잘 모르는 사람이 아니라면, 타입스크립트를 단순히 도입하는 것은 별로 어렵지 않다. 더구나 기존 자바스크립트 기반의 프로젝트에서도 일부 파일만 타입스크립트로 바꿔서 부분적으로 사용하는 것도 가능하기 때문에 점진적 도입도 할 수 있다.</p><p>“잘 쓰고싶다”는 얘기가 조금 다르다. 자바스크립트와 마찬가지로 타입스크립트에는 수 많은 기능들이 있고, 개 중에는 배우기 어렵고 난해한 기능들도 있다. 특히 그 전 정적 타입 언어를 사용했던 유저라면 금방 이해할 수 있겠지만 그렇지 않은 사람에게는 배우기 어려운 개념들도 있다. 이런 기능들은 처음부터 당장 잘 사용해야되는 것들은 아니다. 분명히 자바스크립트를 사용했을 때보다는 알아야 할 게 늘어난다. 하지만 그 어느 누구가 그 모든 기능들을 다 사용하고 있을까? 프로그래밍 언어라는 특성상 사용자의 역량에 따라 응용도가 크게 차이나고, 그 한계가 명확히 존재하지 않는다. 시간이 지남에 따라 커뮤니티가 성숙하고 언어를 사용하는 법 역시 성숙한다. 타입스크립트는 심지어 다른 언어에 비해 릴리즈도 자주 일어나기 때문에 더욱더 마스터에 근접하기는 어려운 언어다. 그런 상황에서 이 언어의 모든 걸 알아야 한다고 생각한다면 타입스크립트는 어려운 언어가 될 수 밖에 없다. 이 글을 쓰는 나도 잘 쓰고 있다고 말하기는 어렵다. 지속적인 개선이 있을 뿐이다.</p><p>결론적으로 배우기 어려워서, 도입 비용이 커서 타입스크립트를 선택하지 않는다는 것은 섣부른 걱정이라는 생각이다. 프로그래밍 언어를 처음 배웠을 때로 되돌아가보자. <code>printf(&quot;Hello, world!&quot;);</code> 컴파일러, 타입은 물론이고 세미콜론이 뭘 의미하는지도 모르는 시절에도 일단 코드부터 쳤다. 처음부터 다 하려고 하면 당연히 포기가 더 가깝다. 차근차근히 일단은 내가 할 수 있는 작은 것부터 시작하면 되는 거고, 타입스크립트는 점진적으로 나아가기에 좋은 언어다.</p><p>더 읽기: <a href="https://scotch.io/tutorials/why-you-shouldnt-be-scared-of-typescript" target="_blank" rel="noopener">Why You Shouldn’t Be Scared of TypeScript</a></p><h2 id="🔥-생산성"><a href="#🔥-생산성" class="headerlink" title="🔥 생산성"></a>🔥 생산성</h2><p>정적 타이핑과 동적 타이핑의 생산성에 관한 논쟁은 상당히 오래된 떡밥이고 이 역시도 아직 모든 상황에서 “타이핑을 하는 것이 우위다.” 혹은 “타이핑을 안하는 것이 우위다.”라고 절대적인 결론이 나지는 않았다. 단순히 더 많은 코드를 작성해야하니 생산성이 떨어지게 된다는 주장은 너무 일차원적인 의견이다. 상황에 따라, 사용자에 따라, 보다 적절한 선택이 있을 것이다. 이 주제에 대한 일반적인 의견은, 동적 타이핑은 단기적으로 사용할 경우에 뛰어난 생산성을 보여주지만, 다수의 사람들이 장기적으로 유지보수 할 때에는 어려움을 느낄 가능성이 높다는 것이다. 물론 정적 타이핑은 이 반대의 우위를 가지고 있다. 자바스크립트와 타입스크립트의 관계도 마찬가지다. 타입스크립트는 장기적으로 생산성에 나은 선택이 될 가능성이 높다.</p><p>최근 자바스크립트가 활용되는 영역에 한계가 거의 없다시피 하지만 여전히 가장 많이 사용되는 곳은 프론트엔드 프로젝트다. 과거 웹이 Multi Page Application(MPA) 기반으로 작성되었던 것과는 달리 요즘 웹페이지는 대부분 React와 Vue, Angular등을 사용한 Single Page Application(SPA)으로 작성된다. 두 가지 타입의 웹에서는 프론트엔드에 기대하는 바도 다르다. 과거 MPA의 프론트엔드에서는 (사실 예전에는 프론트엔드라고 부르는 영역자체가 없었다) HTML 렌더링을 백엔드에서 했기 때문에, 단순한 AJAX 처리 후 DOM 조작을 이용한 극히 부분적 렌더링 정도만을 JavaScript로 처리했었다. 반면, 요즘 SPA에서는 대부분의 HTML 렌더링을 프론트엔드에서 처리한다. 그 결과, 프론트엔드가 백엔드의 역할을 상당히 많이 흡수하게 되었다. HTML 렌더링, 페이지 라우팅, 일부 비즈니스 로직, 어플리케이션 상태 저장 등등. 더구나 예전에는 프론트엔드가 굳이 알 필요 없었던 DB 모델링 스키마도 이제는 프론트엔드에서 당연히 알아야 하는 부분이 되어버렸다. 따라서 요즘 SPA 프론트엔드 프로젝트는 과거 MPA 프로젝트보다 규모가 훨씬 커졌고, 더 많은 사람들이 더 오랜기간 만들고 유지보수해야할 가능성이 높아졌다. 최근 타입스크립트의 가파른 성장도, SPA 프로젝트가 점점 많아지고 있는 현 트렌드와 무관하지 않다는 것이 내 생각이다.</p><p>생산성 부분에 있어서 내 결론적인 의견은, 프로젝트 규모에 따라 타입스크립트는 도움이 될 수도, 안 될 수도 있다는 것이다. 프론트엔드에서는 SPA의 코드 규모가 MPA보다 크기 때문에 정적 타이핑에 유리하며, 프로젝트가 더 대규모일수록, 그리고 더 장기간 유지보수할 가능성이 높아질 수록 타입스크립트의 장점이 부각된다.</p><p>더 읽기: <a href="https://softwareengineering.stackexchange.com/questions/122205/what-is-the-supposed-productivity-gain-of-dynamic-typing" target="_blank" rel="noopener">What is the supposed productivity gain of dynamic typing? (Stack Exchange)</a></p><h2 id="✅-안정성"><a href="#✅-안정성" class="headerlink" title="✅ 안정성"></a>✅ 안정성</h2><p>정적 타이핑과 안정성 얘기하면 항상 링크가 걸리는 글이 있다. <a href="https://labs.ig.com/static-typing-promise" target="_blank" rel="noopener">The broken promise of static typing</a>이라는 상당히 자극적인 제목을 가지고 있는 이 글에서는 정적/동적 타이핑 여부와 버그의 발생 빈도 사이에는 큰 관계가 없다는 결론을 상당히 설득력있는 근거와 함께 설명하고 있다.</p><p>타입스크립트 유저로서 이 글의 결론이 썩 마음에 들지는 않지만, 근거가 분명하기 때문에 충분히 동의할 수 있다. 타입은 런타임에서의 에러 발생 확률을 줄여주지만, 그것이 반드시 버그 감소로 귀결되지는 않는다. 마찬가지로 어플리케이션의 안정성으로 이어지지도 않는다. 물론 여전히 안정성을 이유로 들어 타입스크립트를 선택하는 사람이 있지만, 나는 생각이 다르다. 정말로 버그를 줄이고 싶다면 타이핑에 만족하지 말고, 테스트를 더 잘 짜는데 주력해야한다. 게다가 타입스크립트를 쓴다고해서 테스트를 안짜도 되는 것도 아니다.</p><p>그럼 타입스크립트를 쓸 이유가 없지 않느냐고 반문 할 수도 있는데, 정적 타이핑의 진짜 강점은 런타임 에러 감소에서 오는 것보다는 빠른 에러 발견과 해결에 있다. 같은 타입 에러라고 하더라도 런타임에 발견하는 것과 컴파일 타임에 발견하는 것은 개발자가 보고 판단하고 수정하는 데 걸리는 시간이 다르다. 컨텍스트 스위칭 비용도 없다. 리팩토링할 때 이 장점은 더욱 빛나는데, 리팩토링 이후 Find &amp; Replace 해놓고 런타임에서 에러를 일일히 확인하지 않으면 안심할 수 없는, 결국 리팩토링의 영향이 닿는 모든 기능을 확인하기 전에는 확신하기 어려운 자바스크립트와는 달리, (타이핑을 잘했다는 가정하에) 타입스크립트는 컴파일 타임에 어느 부분이 깨지는지 빠짐없이 알려주기 때문에 리팩토링하기 편해지고, 리팩토링에 대해서 열린 마음을 갖게 된다. 결론적으로 타입 에러를 컴파일 타임에 발견해서 얻는 이득은 런타임에서의 안정성보다는 더 좋은 개발경험과 생산성, 그리고 그로 인해 얻게 될 더 좋은 코드에 가깝다.</p><p>더 읽기: <a href="https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3" target="_blank" rel="noopener">The Shocking Secret About Static Types</a></p><h2 id="🤔-함수형-프로그래밍"><a href="#🤔-함수형-프로그래밍" class="headerlink" title="🤔 함수형 프로그래밍"></a>🤔 함수형 프로그래밍</h2><p>현재까지 이 부분은 확실한 결론이 나지 않은 주제라는 생각이 든다. 확실히 함수형 프로그래밍을 할 때 주로 사용되는 lodash나 Ramda등의 라이브러리에서 제공하는 커링, 컴포지션 그리고 맵, 필터 등의 함수를 타입스크립트로 사용할 때, 들어가는 파라미터와 리턴 타입이 자동으로 타입 추론이 되지 않기 때문에 일일이 제네릭으로 타입을 넘겨줘야하는 불상사가 일어난다. 그리고 이건 확실히 번거롭다. 결론적으로 타입스크립트는 딱히 자바스크립트에 비해 함수형 프로그래밍하기가 더 좋은 언어는 아니다. 그렇지만 함수형 프로그래밍을 하기에 좋지 않은 언어인가에 대해서는 아직 토론할 여지가 남아있다. 어쨌든 타입스크립트는 자바스크립트의 확장이기 때문에 자바스크립트로 할 수 있는 것을 할 수 없는 것은 아니다. 문제가 되는 함수형 프로그래밍 부분의 번거로움을 감수한다면 함수형 프로그래밍의 장점과 타입스크립트의 장점을 동시에 가져갈 수 있으며, 그런 번거로움을 감수하기 싫다면 타입스크립트의 장점을 해당 부분에서만 버리면 된다. 그리고 타입스크립트는 그걸 허용할만큼 관대한 언어다.</p><p>만약 타입스크립트에서의 함수형 프로그래밍이 아쉽게 느껴질정도로 함수형 아이디어를 자주, 많이 사용하고 있다면, 다른 언어를 찾아보는 것도 합리적인 대안이 될 수 있다. 자바스크립트를 지원하는 함수형 프로그래밍 언어는 <a href="http://elm-lang.org/" target="_blank" rel="noopener">Elm</a>, <a href="https://reasonml.github.io/" target="_blank" rel="noopener">Reason</a>, <a href="https://clojurescript.org/" target="_blank" rel="noopener">ClojureScript</a> 등이 있다.</p><p>더 읽기: <a href="https://react-etc.net/entry/functional-programming-with-typescript" target="_blank" rel="noopener">Functional Programming with TypeScript</a></p><h2 id="🌱-커뮤니티"><a href="#🌱-커뮤니티" class="headerlink" title="🌱 커뮤니티"></a>🌱 커뮤니티</h2><p>타입스크립트의 사용자는 해마다 가파르게 상승하고 있다. 스택오버플로우에서 해마다 실시하는 <a href="https://insights.stackoverflow.com/survey/2018/" target="_blank" rel="noopener">Developer Survey 2018년</a> 결과를 보면 타입스크립트는 Most Popular Technologies 12위에 랭크되어있다. <a href="https://octoverse.github.com/" target="_blank" rel="noopener">GitHub Octoverse 2017</a>에서는 11위에 올랐다. 그만큼 사용자가 많고 그만큼 커뮤니티가 크다. 커뮤니티가 크다는 것은 당연하지만, 내가 참고할 자료가 많다는 것, 디테일한 부분에서 언어 자체에 대한 지원이 잘되어있다는 걸 의미한다. 후술하겠지만 이런 타입스크립트의 커뮤니티가 크다는 것을 반증하는 가장 좋은 예가 바로 <a href="(https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>)라는 레포지토리다. 여기에는 우리가 알고 있는 웬만한 메이저 라이브러리, 프레임워크의 타이핑이 거의 모두 정의되어 있다. 또한 2017년에 가장 많은 리뷰를 받은 GitHub 레포지토리이기도 하다.</p><h3 id="d-ts"><a href="#d-ts" class="headerlink" title="d.ts"></a><code>d.ts</code></h3><p><code>d.ts</code>는 단점이다. <code>d.ts</code> 그 자체가 단점이라기 보다는, <code>d.ts</code> 파일의 존재 여부에 따라 라이브러리 선택이 갈리는 것, 의존성에 <code>@types/***</code> 패키지를 추가해야하고 그 역시 유지관리가 필요하다는 것. 자바스크립트와 npm을 사용하는 강점을 상당히 까먹는 부분이다. 처음 타입스크립트를 시작한 사람에게는 큰 진입장벽이다. 일단 <code>d.ts</code> 파일은 일반 타입스크립트 파일에서 보기 힘든 문법을 가지고 있어서 몇 번 정의해본 사람이 아니면 쉽게 정의하기도 어렵다. DefinitelyTyped에 많은 라이브러리의 타이핑이 정의되어 있긴 하지만, 마이너한 라이브러리의 <code>d.ts</code> 파일은 종종 정의되어있지 않은 경우가 있어서 사용을 포기한 적도 있고 직접 만들어 사용한 적도 꽤 많은 만큼, 타입스크립트 유저라면 대부분이 맞닥뜨리는 상황이다.</p><p><code>d.ts</code>도 제공을 안하고 DefinitelyTyped에도 없는 패키지라면 선택은 두 가지다. 타입스크립트를 지원하는 다른 라이브러리를 찾아보거나, 직접 <code>d.ts</code> 파일을 만드는 것이다. 나는 반드시 사용하고 싶은 라이브러리가 있는 경우 무조건 <code>d.ts</code> 파일을 만들어두고 쓰는데, 처음엔 사용하는 API 몇 개 정도만 타이핑을 해두다가 차차 타이핑을 늘려나가는 방식을 선호한다. 그리고 어느정도 타이핑이 안정적이라는 생각이 들면 해당 라이브러리 레포지토리나 DefinitelyTyped에 PR을 날려볼 수도 있다. 이 문제를 정말 신경쓰기가 싫다면 <code>noImplicitAny</code> 옵션을 켜두면 된다.</p><p>때로는 이 때문에 리서치에 시간을 잡아먹기도 하는 만큼 가벼운 단점은 아니라고 생각한다. 하지만 타입스크립트 커뮤니티가 커지는 만큼 맞닥뜨릴만한 상황은 앞으로 점점 적어질 것이라고 예상한다.</p><h2 id="👌-결론"><a href="#👌-결론" class="headerlink" title="👌 결론"></a>👌 결론</h2><p>나는 사실 지금까지 순수 자바스크립트를 사용해서 코딩한 경험이 많지 않다. 지금 다니는 회사에 들어오기 전까지는 쭉 커피스크립트만 썼었고(그걸 <a href="https://hyunseob.github.io/2016/05/01/thoughts-about-coffeescript-and-es2015/">까는 글</a>도 썼었고), 지금 회사에 들어온 이후로는 쭈욱 타입스크립트만 써왔다. 따라서 정당한 비교는 되지 않을지 모르겠지만, ES2015이후의 자바스크립트와 타입스크립트 중에 뭐가 더 개발자의 경험적인 측면에서 나은 언어였냐고 물어본다면 무조건 타입스크립트를 꼽을 것이다. 프로그래밍 언어가 제공하는 가치 중에서 개발자의 경험보다 중요한 것이 있을까? 그 면에서 타입스크립트는 개발자의 경험을 거의 만족에 가깝게 끌어올려주는 언어고, 좋은 언어라고 자신있게 말할 수 있다. 타입스크립트의 깃허브 레포지토리에는 <a href="https://github.com/microsoft/typescript/issues/10011" target="_blank" rel="noopener">Love for TypeScript</a>라는 이슈가 있을 정도로 사용자의 만족도가 높은 언어다. 물론 당장 사용하지 않으면 큰일날 것도 아니고, 현재 자바스크립트로 충분히 만족하고 있다면 굳이 사용할 필요가 없는 것도 사실이다. 하지만 새로운 프로젝트에 한 번 쯤 시도해봐도 나쁘지 않을 정도로 가치있는 언어이기도 하다. 만약 타입스크립트에 대한 선입견이 있었다면, 이 글을 통해 선입견이 조금이라도 줄었기를 바란다.</p><h2 id="👀-더-읽어볼-만한-글"><a href="#👀-더-읽어볼-만한-글" class="headerlink" title="👀 더 읽어볼 만한 글"></a>👀 더 읽어볼 만한 글</h2><p>아래 목록은 읽기를 추천하는 타입스크립트에 관한 글들이다. 이 글을 쓰면서 참고한 부분이 많기 때문에 이 글을 재밌게 보았다면 아래 글들도 반드시 보기를 추천한다.</p><ul><li><a href="https://codeburst.io/strict-types-typescript-flow-javascript-to-be-or-not-to-be-959d2d20c007" target="_blank" rel="noopener">Strict Types: Typescript, Flow, Javascript — to be or not to be?</a></li><li><a href="https://medium.freecodecamp.org/when-should-i-use-typescript-311cb5fe801b" target="_blank" rel="noopener">When should I use TypeScript?</a></li><li><a href="https://itnext.io/why-use-typescript-good-and-bad-reasons-ccd807b292fb" target="_blank" rel="noopener">Why use TypeScript, good and bad reasons</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/do-you-need-to-use-ts.jpg&quot;/&gt;&lt;p&gt;&lt;img src=&quot;/images/ts-survey.jpg&quot; alt=&quot;TypeScript 설문조사 스크린샷&quot;&gt;&lt;/p&gt;
&lt;p&gt;최근 페이스북의 프론트엔드 개발그룹에 &lt;a
      
    
    </summary>
    
      <category term="Opinion" scheme="https://hyunseob.github.io/categories/Opinion/"/>
    
    
      <category term="Opinion" scheme="https://hyunseob.github.io/tags/Opinion/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Component Typing in React</title>
    <link href="https://hyunseob.github.io/2018/07/15/component-typing-in-react/"/>
    <id>https://hyunseob.github.io/2018/07/15/component-typing-in-react/</id>
    <published>2018-07-15T09:06:05.000Z</published>
    <updated>2018-12-31T10:15:02.256Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/component-typing-in-react.jpg"/><p>TypeScript는 React에서의 컴포넌트 타이핑을 강력하게 할 수 있도록 돕는다. 이번 글에서는 TypeScript를 이용한 React 컴포넌트 타이핑 방법을 다양하게 알아본다.</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><script src="https://gist.github.com/HyunSeob/4ef6d6c956f5ebefd201040c819a2666.js"></script><p>가장 기본적인 형태의 클래스 React Component 타입 정의다. <code>React.Component</code>라는 클래스에 제네릭을 사용해서 React에서 사용하는 Props와 State의 타입 정의를 할 수 있다. Props와 State는 각각 생략이 가능하며, 생략할 경우 디폴트 값은 <code>{}</code> 타입이다. </p><script src="https://gist.github.com/HyunSeob/eb34be2945eeb9fda5c6186249247b6d.js"></script><p>다음은 Stateless Component(SFC)의 타입 정의다. SFC는 문자 그대로 State를 가지지 않기 때문에 State의 타입 정의를 할 필요가 없다. 따라서 <code>React.StatelessComponent</code>라는 인터페이스에 Props를 표현하는 제네릭만 넣어주면 된다. 이 때  <code>React.StatelessComponent</code>는 <code>React.SFC</code>로 대체해도 된다. 취향에 맞게 사용하면 된다.</p><h2 id="Spreading-Props"><a href="#Spreading-Props" class="headerlink" title="Spreading Props"></a>Spreading Props</h2><p>기본 JSX Element인 <code>&lt;button/&gt;</code>에 몇가지 스타일을 정의해, 새로운 컴포넌트 <code>&lt;Button/&gt;</code>을 만든다고 가정해보자. 이 경우 당연히 <code>onClick</code> 이나 <code>type</code> 등, 기본적으로 JSX Element가 내장하고 있는 프로퍼티를 사용해야 할 것이다. 정적 타입 검사를 하지 않는 JavaScript에서는 Spreading Operator(<code>...</code>)를 이용해서 내려오는 props를 그대로 아래 컴포넌트에 복사해주면 되었다.</p><script src="https://gist.github.com/HyunSeob/aa733c48058cd559b8135b65870024c9.js"></script><p>이 방법은 <a href="https://reactjs.org/docs/jsx-in-depth.html#spread-attributes" target="_blank" rel="noopener">React 공식 문서</a>에도 잘 나와있다. 하지만 TypeScript를 사용하면 이 방법을 그대로 쓸 수 없다.</p><script src="https://gist.github.com/HyunSeob/445c7412717d0c7100eaaf0138bc159a.js"></script><p>그 이유는 우리가 정의한 <code>ButtonProps</code>에 <code>onClick</code>이 정의되어있지 않기 때문이다. 이 경우 그냥 <code>ButtonProps</code>에 <code>onClick</code> 메소드를 추가로 정의해서 해결할 수도 있지만 모든 문제가 완전히 해결되지는 않는다. 만약 <code>type</code>을 쓰고 싶다면? <code>id</code>는? <code>disabled</code>는? <code>aria-label</code>은? 그 때마다 쓰고싶은 프로퍼티를 추가해주는 건 여간 귀찮은 일이 아닐 것이다.</p><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts" target="_blank" rel="noopener">Definitely Typed의 React 타입 정의</a>(<code>@types/react</code>)에는 여기에 필요한 모든 타입 정의가 포함되어 있다. 필요한 타입 정의가 버튼이라면, <code>ButtonHTMLAttributes</code>를 사용하면 되고, 인풋이라면 <code>InputHTMLAttributes</code>를 쓰면 된다. 결국 다음과 같이 수정할 수 있다.</p><script src="https://gist.github.com/HyunSeob/64e45981398c770db69867f556e64c20.js"></script><p>위처럼 <code>ButtonProps</code>는 내장된 타입정의를 <code>extends</code>로 상속하고 추가로 필요한 프로퍼티를 정의하면 된다. 제네릭으로 넘겨준 <code>HTMLButtonElement</code>는 <code>onClick</code>등의 이벤트 핸들러로 넘어올 실제 DOM 객체의 타입이다.</p><p>하지만 이렇게 타입 정의를 상속하는 경우 내가 예상하지 못했던 프로퍼티가 넘어올 가능성도 생각해야 한다. 예를 들어, <code>&lt;Button/&gt;</code> 컴포넌트에는 <code>style</code> 프로퍼티를 넘길 수 있게 되었다. 이 때 <code>color</code>와 <code>style</code> 프로퍼티를 동시에 넘기는 경우 <code>color</code>는 무시당하게 될 것이다. 따라서, 이렇게 프로퍼티를 Spreading할 경우에는 컴포넌트 내부에서 프로퍼티를 다룰 때 세심한 주의를 기울여야 한다.</p><h3 id="Omit으로-이벤트-핸들러-다시-정의하기"><a href="#Omit으로-이벤트-핸들러-다시-정의하기" class="headerlink" title="Omit으로 이벤트 핸들러 다시 정의하기"></a><code>Omit</code>으로 이벤트 핸들러 다시 정의하기</h3><p><code>Omit</code>은 TypeScript 2.8 버전에 들어간 Conditional Types 기능을 조금 확장하여 사용하는 타입 헬퍼다. 특정 인터페이스에서 원치 않는 프로퍼티를 제외할 수 있으며 더 자세한 내용은 <a href="https://adhrinae.github.io/posts/helper-types-in-typescript/#diff-omit-%ED%83%80%EC%9E%85" target="_blank" rel="noopener">안도형님이 쓰신 글</a>을 참조하자. 이 문단에서는 <code>Omit</code>을 사용하여 기본 이벤트 핸들러의 타입을 내가 원하는대로 재정의하는 방법을 알아본다.</p><p>다음과 같은 케이스를 고려해보자.</p><script src="https://gist.github.com/HyunSeob/c508e629f8b0802d6017c6a2cbff0b9d.js"></script><p>위 코드에서 <code>&lt;Button/&gt;</code> 컴포넌트는 기본 <code>onClick</code> 이벤트를 재정의했다. 본래 <code>onClick</code> 이벤트는 이벤트 핸들러에 이벤트 객체를 전달하도록 되어있지만 위 코드에서는 중간에서 <code>handleClick</code>으로 <code>onClick</code> 이벤트를 가로채고 프로퍼티에 저장되어 있는 값을 대신 전달했다. 이런 패턴은 React에서는 매우 흔히 쓰이는 패턴이다.</p><p>위 코드에 TypeScript를 적용하는 경우, 그리고 아까 언급한 Spreading Props를 적용하는 경우 문제가 생긴다. 기본 <code>onClick</code> 이벤트와 재정의한 <code>onClick</code> 이벤트의 타입이 서로 맞지 않기 때문이다.</p><script src="https://gist.github.com/HyunSeob/bb25fc446d36dcea964f8bf7d64641b3.js"></script><p>앞서 말했던 대로, <code>onClick</code> 이벤트의 이벤트 핸들러로는 이벤트 객체가 넘어가야 하지만, 위에 새로 만든 <code>&lt;Button/&gt;</code>에서는 <code>value</code>를 넘기고 있고, 이 <code>value</code>의 타입이 이벤트 객체의 타입과는 맞지 않으므로 타입 에러를 발생시킨다.</p><p><code>Omit</code>을 사용해서 이런 문제를 해결할 수 있다. 정확히는 <code>Omit</code>으로 재정의할 이벤트의 타입 정의를 빼준 다음, 내가 원하는 대로 새로 타입 정의를 넣어주면 되는 것이다.</p><script src="https://gist.github.com/HyunSeob/74368d6e6dc4c7f5ed36142675390dca.js"></script><p>여기서는 이벤트 핸들러를 다시 정의하는 유즈케이스를 다루었지만, 이벤트 핸들러 뿐만이 아니라 사용자 본인이 원하는 대로 기본 프로퍼티를 다시 정의할 수 있다. 예를 들면 <code>value</code>를 내가 원하는 데이터 형태만 받도록 변경할 수도 있다.</p><h2 id="Component-Namespace-합성"><a href="#Component-Namespace-합성" class="headerlink" title="Component / Namespace 합성"></a>Component / Namespace 합성</h2><p>TypeScript에서 클래스나 함수에 <code>namespace</code>를 합성하는 건 꽤 흔한 패턴이다. <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" target="_blank" rel="noopener">TypeScript 공식 문서</a>에서도 이를 다루고 있다. </p><p>React의 컴포넌트는 크게 보아 두 가지, 클래스이거나 함수이기 때문에 마찬가지로 <code>namespace</code>를 결합할 수 있다. 예를 들어 다음과 같은 패턴으로 결합할 수 있다.</p><script src="https://gist.github.com/HyunSeob/673291d9f778c1a8ae6b791616cbf62a.js"></script><p>이 패턴은 위처럼 해당 컴포넌트의 <code>Props</code>나 <code>Type</code> 따위의 타입을 외부에서 사용해야할 때 유용하다. 이렇게 하면 컴포넌트에서 사용하는 각종 인터페이스나 타입들을 모아서 한 번에 하나의 엔트리로 모아서 내보낼 수 있다. 일일이 <code>export</code> 해주는 것과 코드량에 큰 차이는 없지만, <code>import</code>를 일일이 해줄 필요가 없다는 점에서 편의성이 크게 개선된다. 특히 컴포넌트 별로 <code>index.ts</code> 파일을 가지는 패턴의 경우, 두 번 <code>export</code> 하는 불편함이 줄어든다.</p><p><code>enum</code>의 경우는 특히, 값과 타입이 동시에 정의되는 문법이므로, <code>type</code>으로 타입을 내보내는 동시에, 컴포넌트 내부에 <code>static</code> 키워드를 이용해서 값도 내보내야 한다는 점에 유의하자.</p><p>다음은 함수형 컴포넌트의 결합방법이다.</p><script src="https://gist.github.com/HyunSeob/076e046c3a2e1f2f2f0bda07c10ce1b9.js"></script><p>TypeScript의 <code>namespace</code>는 변수와의 합성을 지원하지 않는다. 따라서 함수 표현식을 사용할 수 없고, 함수 선언식을 사용하여 함수를 선언해야만 <code>namespace</code>와의 합성을 할 수 있다. 보통은 React에서 컴포넌트를 만들 때는 함수 표현식을 많이 사용하기 마련인데, <code>namespace</code> 합성을 해야 할 때는 함수 선언식이 강제되므로 아쉬운 부분이라고 할 수 있다.</p><p>React에서는 기본적으로 컴포넌트 하나당 대부분 하나의 인터페이스(Props)가 따라가기 때문에 막상 <code>namespace</code>를 쓰기로 마음 먹으면 대부분의 컴포넌트에 적용할 수 있게 된다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>개인적인 의견이지만, React에 TypeScript가 어울리지 않는다는 것은 이제 옛말인 것 같다. 아직은 부족한 점이 남아있지만, TypeScript 커뮤니티는 React를 강력하게 지원하고 있다는 사실 하나만큼은 분명해보인다. 얼마전에 릴리즈된 TypeScript 3.0 RC에서는 React의 <code>defaultProps</code>의 <a href="https://blogs.msdn.microsoft.com/typescript/2018/07/12/announcing-typescript-3-0-rc/#default-props-support" target="_blank" rel="noopener">지원</a>이 추가되었다. 그 전에도 요즘 TypeScript 릴리즈 개선사항을 보면 거의 React에 대한 직접적인 지원이 하나 정도는 포함이 되어있다. 따라서 앞으로도 컴포넌트 타이핑이 더욱 개선될 수 있을거라 기대해 볼 수 있다.</p><p>현재의 TypeScript만으로도 PropTypes를 사용할 때보다는 더욱 강력한 타이핑을 해 볼 수 있다. 앞서 다룬 방법들만 적용해도 기본적인 컴포넌트 타이핑을 개선하는데 도움이 될 것이다. 또한 React에 대한 지원이 강화되고있기 때문에 앞으로는 그 차이가 더욱 벌어질 것이다. React에 TypeScript가 안 어울린다고 생각했던 개발자라면 지금부터라도 시도해보는 것은 어떨까?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/component-typing-in-react.jpg&quot;/&gt;&lt;p&gt;TypeScript는 React에서의 컴포넌트 타이핑을 강력하게 할 수 있도록 돕는다. 이번 글에서는 TypeScript를 이용한 React 컴포넌트 타이핑
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="React" scheme="https://hyunseob.github.io/categories/JavaScript/React/"/>
    
    
      <category term="React" scheme="https://hyunseob.github.io/tags/React/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>[React] Debounce SyntheticEvent</title>
    <link href="https://hyunseob.github.io/2018/06/24/debounce-react-synthetic-event/"/>
    <id>https://hyunseob.github.io/2018/06/24/debounce-react-synthetic-event/</id>
    <published>2018-06-24T08:37:54.000Z</published>
    <updated>2018-12-31T10:15:02.259Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/debounce-react-synthetic-event.png"/><p>React에서 사용하는 <code>onClick</code>, <code>onChange</code> 등을 통해서 핸들링할 수 있는 이벤트 객체는 브라우저 네이티브 이벤트 객체가 아니다. 브라우저 네이티브 이벤트 객체를 감싼 React 고유의 이벤트 객체인데, 이를 React에서는 <em>SyntheticEvent</em>라고 부른다. SyntheticEvent는 브라우저 네이티브 이벤트와 매우 비슷한 API를 갖고 있기 때문에 네이티브 이벤트로 착각하기가 쉽지만, 실제로는 여러가지 차이점을 가진다.</p><h2 id="Event-Pooling"><a href="#Event-Pooling" class="headerlink" title="Event Pooling"></a>Event Pooling</h2><p>그중 가장 큰 차이점은 Event Pooling이다. SyntheticEvent는 이벤트 객체를 재활용하기 때문에, 해당 이벤트가 발생하고 그 이벤트 핸들러가 실행된 이후에는 SyntheticEvent의 모든 프로퍼티가 <code>null</code>로 변한다.</p><iframe src="https://stackblitz.com/edit/debounce-react-synthetic-event-1?embed=1&file=index.js&view=editor" style="margin: auto; width:100%; height: 500px;"></iframe><p>위의 예제에서 버튼을 클릭해보면 이벤트 핸들러에서 <code>setTimeout</code>을 실행하기 전의 이벤트 객체(Before)에는 프로퍼티에 데이터가 잘 들어가 있었지만, <code>setTimeout</code>을 실행한 이후의 이벤트 객체(After)에서는 모든 프로퍼티가 <code>null</code>로 변했다는걸 확인할 수 있다. 이걸 두고 Event Pooling이라고 부른다. 특정 이벤트의 이벤트 객체는 단 한 번, 해당 이벤트 핸들러가 실행되는 동안에만 사용할 수 있다. 성능적인 이유로 이렇게 한다고 설명되어있는데, 구체적으로 어떻게 성능이 나아지는지는 잘 모르겠다. 이벤트 객체를 하나만 사용하니 확실히 메모리는 적게 먹겠지만.</p><h2 id="Asynchronous-Problem"><a href="#Asynchronous-Problem" class="headerlink" title="Asynchronous Problem"></a>Asynchronous Problem</h2><p>문제는 종종 이벤트 핸들러에서 비동기적인 동작을 수행해야하는 경우가 생긴다는 것이다. 비동기 동작을 수행한 이후에 이벤트 객체가 들고있는 정보가 필요한 경우 어떻게 해야할까? 가장 간단한 해결방법은 그냥 해당 이벤트 객체가 가지는 특정 데이터를 다른 변수에 복사해두고 비동기 동작의 수행이 끝난 뒤 사용하는 것이다. 코드를 몇 줄 더 써야되기는 해도 꽤 괜찮은 해결방법이다.</p><p>React에서는 이 해결책 말고도 한 가지 특별한 해결책을 제시한다. 바로 <code>event.persist()</code>다. </p><iframe src="https://stackblitz.com/edit/debounce-react-synthetic-event-2?embed=1&file=index.js&view=editor" style="margin: auto; width:100%; height: 500px;"></iframe><p>위의 예제는 첫번째 예제에 <code>event.persist()</code>를 적용한 예제다. 버튼을 눌러보면 좀 전과는 달리 이벤트 객체의 프로퍼티들이 제대로 보존되어있는 것을 확인할 수 있다. <code>event.persist()</code>를 사용하면 비동기적인 동작을 수행한 이후에도 데이터가 남아있어서 이벤트 객체를 활용할 수 있다. 물론 이렇게 하면 아까도 언급했던 성능적인 이점이 줄어들 것이다.</p><h2 id="Debounce-SyntheticEvent"><a href="#Debounce-SyntheticEvent" class="headerlink" title="Debounce SyntheticEvent"></a>Debounce SyntheticEvent</h2><p><a href="/2016/04/24/throttle-and-debounce/">예전</a>에 Lodash의 <code>debounce</code>와 <code>throttle</code> 함수를 소개하면서 말했듯이, <code>onmousemove</code>, <code>onscroll</code> 등의 이벤트는 1초 안에도 수십번씩 발생할 수 있는 이벤트이기 때문에 Throttle을 걸어주거나 Debounce 처리해주어야 하는 경우가 종종 있다. 물론 React를 사용하더라도 해당되는 얘기다.</p><p>하지만 Lodash의 <code>throttle</code>과 <code>debounce</code>는 기본적으로 이벤트 핸들러의 동기적인 실행을 막는 메소드이기 때문에 React의 Synthetic 이벤트와 궁합이 잘 맞지 않는다. 다음 예제를 보자.</p><iframe src="https://stackblitz.com/edit/debounce-react-synthetic-event-3?embed=1&file=index.js&view=editor" style="margin: auto; width:100%; height: 500px;"></iframe><p>이 예제에서 <code>&lt;input/&gt;</code>의 이벤트 핸들러는 Debounce 처리 되었다. 다시 말해 <code>&lt;input/&gt;</code>에 무언가를 입력해도 바로 이벤트 핸들러가 실행되는게 아니라, 무언가를 입력한 이후에 500ms 동안 타이핑을 멈춰야 이벤트 핸들러가 실행된다. 입력창에 실제로 무언가를 입력해보고 이벤트를 실행시켜보면 에러가 발생하는 것을 볼 수 있다. 왜냐하면 이벤트 핸들러가 마지막 이벤트의 500ms 이후에 실행되기 때문이다. SyntheticEvent의 특성상 이미 모든 프로퍼티가 <code>null</code>로 바뀐지 오래일 것이다. 결과적으로, Debounce된 이벤트 핸들러 내부에서 SyntheticEvent 객체에 접근하는 경우 항상 <code>null</code>로 모든 프로퍼티가 도배된 객체만을 얻을 수 있다.</p><p>이 문제는 어떻게 해결할 수 있을까? 가장 쉽게 떠올릴 수 있는 방법은 위에서 잠깐 소개한 <code>event.persist()</code>를 사용하는 것이다. 하지만 이 방법은 해결책이 되지 않는다. <code>event.persist()</code>는 이벤트 핸들러 내부에서만 호출할 수 있다. 이벤트가 일어나기 전에 호출할 수 없다는 말이다. 결국은 이 케이스에서 사용할 수는 없는 방법이다.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>해결방법은 간단하다. 이벤트 핸들러를 두 개로 쪼개면 된다. React의 SyntheticEvent를 동기적으로 핸들링할 Debounce되지 않은 이벤트 핸들러 하나, 필요한 데이터를 받아 무거운 동작을 수행할 Debounce된 이벤트 핸들러 하나.</p><iframe src="https://stackblitz.com/edit/debounce-react-synthetic-event-4?embed=1&file=index.js&view=editor" style="margin: auto; width:100%; height: 500px;"></iframe><p>위의 예제에서는 <code>onChange</code> 이벤트에 대한 핸들러로 <code>handleChange</code>와 <code>debouncedHandleChange</code> 이렇게 두 가지를 사용하고 있다. <code>handleChange</code>에서는 온전히 SyntheticEvent를 받은 뒤에 필요한 데이터를 이벤트 객체로부터 추출해서 Debounce된 <code>debouncedHandleChange</code>로 넘겨주고 있다. 이제 <code>debouncedHandleChange</code>에서 얻어진 데이터를 가지고 실질적인 동작을 수행하면 될 것이다.</p><p>이 때 주의할 점은, SyntheticEvent 객체를 그대로 Debounce된 이벤트 핸들러에 넘겨주면 안된다는 것이다. JavaScript에서 함수에 객체를 넘길 때는 항상 Call by reference이므로 그냥 SyntheticEvent 객체의 참조가 넘어가고 결국 다시 모든 프로퍼티가 <code>null</code>인 이벤트 객체를 다시 보게 될 것이다. 귀찮더라도 필요한 프로퍼티를 적당히 추출해서 넘기는게 좋은 방법이다.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://reactjs.org/docs/events.html#event-pooling" target="_blank" rel="noopener">SyntheticEvent - React</a></li><li><a href="https://arianacosta.com/js/react/easy-event-throttling-in-react/" target="_blank" rel="noopener">Easy Event Throttling in React</a></li><li><a href="https://stackoverflow.com/questions/23123138/perform-debounce-in-react-js" target="_blank" rel="noopener">Perform debounce in React.js - StackOverflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/debounce-react-synthetic-event.png&quot;/&gt;&lt;p&gt;React에서 사용하는 &lt;code&gt;onClick&lt;/code&gt;, &lt;code&gt;onChange&lt;/code&gt; 등을 통해서 핸들링할 수 있는 이벤트 객체는 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="React" scheme="https://hyunseob.github.io/categories/JavaScript/React/"/>
    
    
      <category term="React" scheme="https://hyunseob.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Storybook 입문 가이드</title>
    <link href="https://hyunseob.github.io/2018/01/08/storybook-beginners-guide/"/>
    <id>https://hyunseob.github.io/2018/01/08/storybook-beginners-guide/</id>
    <published>2018-01-07T16:51:48.000Z</published>
    <updated>2018-12-31T10:15:02.274Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/storybook-beginners-guide/storybook.png"/><p>페이지 단위의 개발이 이루어지던 과거와 달리 요즘의 프론트엔드 개발은 주로 컴포넌트 단위로 이루어진다. 이 컴포넌트라는 개념은 사용하는 라이브러리나 프레임워크에 따라 구현 방식이 다르지만, 철학은 거의 동일하다. 원래 컴포넌트는 외부 상태의 영향을 받지않는 독립된 개체로서, 고립된 환경에서도 자신만의 스타일과 상태를 가질 수 있어야 한다. <a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React의 컴포넌트 정의</a>에 따르면, 컴포넌트가 UI를 독립적이고 재사용 가능한 단위로 분리하고 각 단위를 고립해서 생각할 수 있게 해준다고 설명한다.</p><p>이렇게 프론트엔드 개발의 패러다임이 컴포넌트로 넘어오면서 개발자들은 일종의 모순에 봉착했다. 개발은 컴포넌트 단위로 진행하지만 실제 개발환경은 항상 페이지 단위로 만들어진다는 점이다. 현재 개발하고 있는 서비스에서 사용하는 수 많은 버튼의 상태를 의존성과 환경변수가 걸려있는 페이지에서 일일이 코드를 변경해가며 테스트해야 했었고 여전히 그렇게 진행하고 있는 케이스도 있다. 이렇게 개발을 진행하게 되면 개발자는 온전히 뷰에 집중하기 어려워지고 컴포넌트의 의존성을 쉽사리 파악하기가 어려워진다. 컴포넌트를 진짜로 고립시키지 못하게 되는 것이다. 이는 당연히 컴포넌트의 재사용성을 감소시킨다.</p><p>Storybook은 이런 문제를 해결할 수 있는, 컴포넌트 단위의 개발 환경을 지원하는 도구다. 개발자가 뷰를 개발할 때 고립된 환경을 제공해서 관심사를 의존성과 환경으로부터 분리시켜 준다. 그리고 개발자는 비로소 뷰에 집중할 수 있게 되고, 외부 상태에 의존하지 않으면서 고립된 상태로 스스로를 표현하는 컴포넌트를 개발할 수 있게 된다.</p><p>이 글에서는 Storybook을 한 번도 사용해본 적 없는 사람을 대상으로 기본적인 사용법을 안내한다.</p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>요즘 충분한 사용자를 갖추고 있는 여러가지 프론트엔드 프레임워크, 그러니까 React, Vue, Angular 등은 컴포넌트 단위의 개발을 기본으로 한다. Storybook은 React 뿐만 아니라 Vue도 지원하며, 최근에는 Angular도 지원하게 되었다. 이 글에서는 React로 예제를 진행할 것이다.</p><p>babel이나 webpack 관련 자잘한 설정을 하기에는 설명할 부분이 너무 많기도 하거니와 사실 글의 주제에도 맞지는 않으니, <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a>을 통해 프로젝트 스캐폴딩을 먼저 진행한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ create-react-app storybook-playground</span><br></pre></td></tr></table></figure><p>스캐폴딩이 완료되었다면 본격적으로 Storybook을 설치한다. Storybook은 고유의 커맨드라인 인터페이스를 갖추고 있다. CLI를 설치하자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g @storybook/cli</span><br></pre></td></tr></table></figure><p>그리고 다음의 명령어를 사용하여 Storybook을 프로젝트 내에 설치하면 된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getstorybook</span><br></pre></td></tr></table></figure><p>그러면 CLI가 알아서 적당히 필요한 의존성을 설치해주고, <code>package.json</code>에도 Storybook 실행 및 빌드 관련 명령어가 추가된다. 이제 실행 스크립트만 사용하면 Storybook이 실행된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run storybook</span><br></pre></td></tr></table></figure><p><img src="/images/storybook-beginners-guide/storybook-1.png" alt="Storybook 개발환경"></p><h1 id="Story-작성하기"><a href="#Story-작성하기" class="headerlink" title="Story 작성하기"></a>Story 작성하기</h1><p>프로젝트 내 <code>src</code> 폴더를 잘 살펴보면 <code>stories</code>라는 폴더가 새로 생긴 걸 확인할 수 있다. 이 폴더가 바로 Storybook에 실제로 올라가는 컴포넌트들을 정의하는 파일들이 있는 폴더다. 그 안의 <code>index.js</code> 파일을 잘 살펴보면 아까 웹 페이지에서 봤던 페이지의 사이드바에 있었던 컴포넌트를 정의하는 코드가 보일 것이다.</p><script src="https://gist.github.com/HyunSeob/9d6b7fed7588675835df766c82d45960.js"></script><p>보면 알겠지만, 문법은 컴포넌트를 <code>storiesOf</code> 함수로 감싼 뒤에, <code>add</code>로 여러가지 스토리를 추가하는 형태로 사용한다. 여기에서 스토리는 어떠한 환경일 수도 있고, 컴포넌트의 상태일 수도 있다. 예제에서는 <code>Button</code> 컴포넌트는 주입받는 데이터, 그러니까 텍스트와 이모지를 기준으로 스토리를 나누었는데, 뷰가 다르게 보일 수 있는 상태라면 무엇이든 스토리로 써도 된다. 여기에 딱히 엄격한 규칙은 없다. 버튼이라면 일반적으로 사이즈나 컬러, 혹은 <code>:hover</code> 나 <code>:disabled</code> 같은 상태도 별도의 스토리로 써도 된다.</p><p>먼저 Storybook을 경험해보기 위해서 새롭게 아주 간단한 컴포넌트와 스토리를 작성해보자.</p><script src="https://gist.github.com/HyunSeob/2f585754045a87b0107c73de60c21647.js"></script><p>아주 간단한 <code>Input</code> 컴포넌트를 작성하고, <code>index.js</code> 파일에 관련된 스토리를 추가했다. 이제 저장해서 웹페이지를 확인해보면 새로운 컴포넌트가 생긴 걸 확인해볼 수 있을 것이다.</p><h2 id="Action-작성하기"><a href="#Action-작성하기" class="headerlink" title="Action 작성하기"></a>Action 작성하기</h2><p><code>index.js</code>를 다시보면 Button의 <code>onClick</code> 이벤트에 <code>action</code>이라는 함수가 바인딩 되어있는 걸 볼 수 있다. 다시 웹페이지로 돌아가서 버튼을 클릭해보면 아래에 있는 Action Logger에 버튼을 클릭할 때마다 로그가 올라오는 것을 확인할 수 있다. <code>action</code>은 Storybook에서 사용하는 일종의 로깅용 함수다. 각종 이벤트와 함께 날아오는 데이터를 쉽게 볼 수 있다.</p><p>마침 우리가 만든 <code>Input</code> 컴포넌트는 이런 데이터를 확인하기에 아주 적합한 컴포넌트다. <code>Input</code>의 <code>onChange</code> 이벤트에 <code>action</code>을 걸어주자.</p><script src="https://gist.github.com/HyunSeob/748065c8326afcdd8b3d4c3a9a789aab.js"></script><p>그리고 다시 웹으로 돌아가서 <code>&lt;input&gt;</code> 요소 안에 타이핑을 해보면 로그가 계속해서 찍히는 걸 확인해 볼 수 있다. <code>action</code>은 이런 네이티브 이벤트 뿐만이 아니라 프로그래머가 직접 짠 이벤트에도 반응하도록 만들 수 있다.</p><p>주의할 점은, <code>action</code> 자체는 함수를 반환하는 함수이므로 이벤트에 바인딩해도 로그를 남기지 않는다는 것이다. 항상 문자열과 함께 함수를 실행시킨 결과를 이벤트에 바인딩하자.</p><h2 id="데코레이터-Decorator-추가하기"><a href="#데코레이터-Decorator-추가하기" class="headerlink" title="데코레이터(Decorator) 추가하기"></a>데코레이터(Decorator) 추가하기</h2><p>Storybook에서 말하는 데코레이터는 현재 Stage 2에 있는 ECMA 데코레이터 스펙과 무관하다. Storybook을 계속해서 사용하다보면 <code>width: 100%</code>인 컴포넌트들은 실제 페이지에 들어갈 때랑 다르게 보이거나, 컴포넌트가 좌상단에 너무 가까이 붙어있어서 전체적인 뷰를 보기에 좋지 않은 경우가 많다. 이 문제를 해결하기 위해서 가장 쉽게 사용할 수 있는 솔루션은 <code>margin</code>이나 <code>padding</code> 값을 가지고 있는 래핑 컴포넌트를 만들어서 테스트할 컴포넌트를 감싸주는 것이다. 이 방법의 문제는 모든 스토리에 래핑 컴포넌트를 번거롭게 일일이 추가시켜줘야 한다는 것이다.</p><p>데코레이터는 이러한 불편함을 해결해주는 기능이다. Story를 추가하기 전에 <code>addDecorator</code>라는 메소드를 통해 손쉽게 모든 스토리에 래핑 컴포넌트를 추가할 수 있다.</p><script src="https://gist.github.com/HyunSeob/021352d49c1e2425405be602bf932e88.js"></script><p><code>story</code>는 뒤에 나오는 스토리에서 선언한 컴포넌트를 렌더링하는 함수다. 적절한 래핑 컴포넌트 아래에서 <code>story</code> 함수를 실행시키는 식으로 선언해주면 된다.</p><p><code>addDecorator</code>는 스토리 사이에도 껴넣을 수 있는데, 그러면 <code>addDecorator</code>의 뒤에 있는 스토리들만 그 데코레이터의 영향을 받는다.</p><h2 id="애드온-설치하기-Background"><a href="#애드온-설치하기-Background" class="headerlink" title="애드온 설치하기: Background"></a>애드온 설치하기: Background</h2><p>실제 작업할 페이지의 배경색깔이 흰색인 경우 상관 없는데, 만약 회색이거나 혹은 뭔가 다른 색이라면 컴포넌트를 작성했을 때의 룩앤필이 페이지에 실제로 들어갔을 때와 좀 다르다고 느끼게 된다. 이런 문제를 개선하기 위해서 Storybook에 별도의 플러그인인 애드온(Add-on)을 설치할 수 있다. 위에서 다뤘던 <code>action</code>도 기본적으로 설치되어있는 애드온이다.</p><p>배경 색깔을 지원하기 위한 유틸리티는 크게 두 가지가 있는데, 하나는 데코레이터 형태의 <a href="https://github.com/jakelazaroff/react-storybook-decorator-background" target="_blank" rel="noopener">react-storybook-decorator-background</a>이고, 다른 하나는 <a href="https://www.npmjs.com/package/@storybook/addon-backgrounds" target="_blank" rel="noopener">Storybook Addon Backgrounds</a>이다. 둘 다 사용할 수 있지만 둘 중 후자를 추천한다. 전자는 <a href="https://github.com/jakelazaroff/react-storybook-decorator-background/issues/5" target="_blank" rel="noopener">HMR이 깨지는 버그</a>를 가지고 있고 유지보수도 중지된 것으로 보인다. 후자는 Storybook 레포에 포함되어있는 공식 애드온이라 유지보수가 중단될 일은 없을 것으로 예상된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install @storybook/addon-backgrounds --dev</span><br></pre></td></tr></table></figure><p>지금도 애드온을 설치하고 쉽게 까먹게 되는 것이, <code>.storybook/addons.js</code> 파일을 수정하는 것이다. Storybook에 설치하는 모든 애드온은 해당 파일에 등록되어야 한다.</p><script src="https://gist.github.com/HyunSeob/176df2434ee1f57d9f899d0009b00b17.js"></script><p>보이는 것처럼 <code>addon-actions</code>가 이미 등록되어있고 이 글에서 다루지 않은 <code>addon-links</code>도 등록되어있다. 추가로 <code>addon-backgrounds</code>를 등록해주면 사용 준비가 끝난다.</p><p>그리고 아까 데코레이터를 추가했던 것처럼 데코레이터를 추가하면 된다.</p><script src="https://gist.github.com/HyunSeob/0f2de2dbd9804054a7d8fbe7fa35f64d.js"></script><p>그러면 아래처럼 애드온 메뉴가 하나 추가가 되고, 컴포넌트에서 배경화면을 선택할 수 있다.</p><p><img src="/images/storybook-beginners-guide/storybook-backgrounds.gif" alt="Storybook Backgrounds Addon"></p><p>모든 컴포넌트에 이 배경화면 데코레이터를 적용하고 싶다면, <code>.storybook/config.js</code> 파일을 수정할 수도 있다.</p><script src="https://gist.github.com/HyunSeob/4c4f10dc6bf5b23ebbd4af817e707aa3.js"></script><p>이 글에서는 예제로 Background 애드온을 설치했지만 Storybook에는 유용한 애드온들이 많다. 그런 <a href="https://storybook.js.org/addons/addon-gallery/" target="_blank" rel="noopener">애드온들을 모아둔 페이지</a>도 있으니 한 번 구경해보고 자신의 프로젝트에 맞는 애드온을 선택해 설치하면 더 좋을 것이다.</p><h1 id="Storybook을-실제로-도입하기"><a href="#Storybook을-실제로-도입하기" class="headerlink" title="Storybook을 실제로 도입하기"></a>Storybook을 실제로 도입하기</h1><p>이렇게 앞에서 스토리를 쓰는 방법에 대해서 알아봤지만 이것만으로 실제 프로젝트에 도입하기는 충분치는 않다. 각 프로젝트 별로 사용하는 기술스택이나 요구사항이 서로 다를 수 있기 때문이다. 만약 모든 스토리들을 <code>index.js</code>에 써야한다면, 제 아무리 Storybook이 좋은 툴이라고 하더라도 도입하기가 매우 망설여질 것이다. 여기서는 Storybook을 실제로 프로젝트에 도입하면서 필요한 작업들을 간단하게 알아본다.</p><h2 id="Story-파일-로드-설정"><a href="#Story-파일-로드-설정" class="headerlink" title="Story 파일 로드 설정"></a>Story 파일 로드 설정</h2><p>편의상 지금까지는 스토리를 구분하지 않고 <code>index.js</code>에만 작성했으나, 스토리는 <code>index.js</code> 파일에만 작성할 수 있는 것이 아니다. 아까 잠시 살펴본 <code>.storybook/config.js</code> 파일을 다시 보면, <code>loadStories</code>라는 함수 안에 있는 <code>require</code> 구문을 확인할 수 있을 것이다. 즉, <code>loadStories</code>에서 로드하는 모든 파일에 있는 스토리들을 추가한다. 기본적으로 <code>stories/index.js</code> 파일만 로드할 뿐이다.</p><p>흔히 React에서 폴더 구조를 짤 때 흔히 접근하는 방법 중에 컴포넌트 별로 폴더를 따로 만들고 그 컴포넌트에 필요한 여러가지 파일들을 만드는 방식이 있다. 아래처럼,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── Input</span><br><span class="line">|   ├── index.js</span><br><span class="line">|   ├── Input.js</span><br><span class="line">|   ├── Input.scss</span><br><span class="line">|   └── Input.test.js</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>Storybook도 컴포넌트 하나하나 스토리가 별도로 필요하기 때문에 <code>stories</code> 폴더 하나에 관리했다가는 곧 <code>stories</code> 폴더가 열기도 싫어지는 불상사가 일어날 것이다. 따라서 스토리 파일도 컴포넌트 별로 폴더에 관리하는 것을 추천한다. 아래처럼,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── Input</span><br><span class="line">|   ├── index.js</span><br><span class="line">|   ├── Input.js</span><br><span class="line">|   ├── Input.scss</span><br><span class="line">|   └── Input.stories.js</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p>이때 확장자는 <code>stories.js</code> 혹은 <code>story.js</code> 가 주로 사용되는 것 같다. 나는 보통 <code>stories.js</code>를 사용한다.</p><p>이렇게 하려면 위에서 말했던 것처럼, <code>loadStories</code> 함수를 수정해주면 된다.</p><script src="https://gist.github.com/HyunSeob/2b15a9031b222594728d84239c8a32cc.js"></script><p><a href="https://webpack.js.org/guides/dependency-management/#require-context" target="_blank" rel="noopener">require.context</a>는 webpack에서 지원하는 함수다. Storybook은 내부적으로 webpack을 사용하기 때문에 쓸 수 있다. 이렇게 하면 <code>src/components</code> 아래에 있는 폴더란 폴더는 다돌면서 <code>*.stories.js</code> 파일을 찾아 모두 로드시킨다.</p><h2 id="TypeScript-설정"><a href="#TypeScript-설정" class="headerlink" title="TypeScript 설정"></a>TypeScript 설정</h2><p>앞서 말했듯 Storybook은 webpack을 사용하며, 설정이 Customize 가능하다. 이 말은 물론 TypeScript를 지원한다는 말이 된다. ts-loader를 쓰면 되니까. TypeScript 설정 방법은 <a href="https://storybook.js.org/configurations/custom-webpack-config/#full-control-mode--default" target="_blank" rel="noopener">공식 사이트</a>에도 나와있다. 단지 <code>.storybook/webpack.config.js</code> 파일을 만들어서 아래와 같이 써주면 된다.</p><script src="https://gist.github.com/HyunSeob/4603b4055477aee47e184b90e84fa08c.js"></script><p>마찬가지로 Absolute Import 같은 것이 필요하다거나 하는, webpack의 설정을 건드려야 하는 상황이 있다면 다시 webpack.config.js를 수정하면 된다.</p><h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><p>Storybook은 컴포넌트 단위로 쪼개서 개발할 수 있는 개발환경이지만, 결국은 그 자체로 컴포넌트들의 카탈로그 혹은 말 그대로 책자가 된다. 이렇게 모아놓은 컴포넌트들은 약간의 문서화를 더한다면<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 그 자체로도 인터랙티브한 문서가 되고, 디자이너 혹은 기획자와 협업하는 도구로 사용할 수도 있게 된다. 물론 이렇게 협업하는 도구로 사용하고 싶다면 배포가 필요하다.</p><p>Storybook은 기본적으로 서버가 없고, 완전한 정적 애셋만으로 구동이 가능하므로 어디에나 쉽게 배포할 수 있다. 흔히 알고 있는 정적 사이트 호스팅 서비스, GitHub Pages 혹은 AWS S3에도 물론 배포할 수 있고, 가볍게 쓰기에 좋은 Heroku나 now에도 올려놓을 수 있다.</p><p>가장 간편한 건 공식 지원이 있는 GitHub Pages다. Storybook에서는 <a href="https://github.com/storybooks/storybook-deployer" target="_blank" rel="noopener">storybook-deployer</a>라는 배포 툴을 지원한다. 하지만 오픈 소스가 아닌이상, GitHub Pages에 배포하기는 조금 꺼려지기 마련이다.</p><p>AWS S3도 쉬운 선택지 중에 하나지만, AWS 계정도 있어야되고 셋업하기 귀찮은 면도 있으므로 상대적으로 간단한 솔루션인데다 무료인 <a href="https://zeit.co/now" target="_blank" rel="noopener">now</a>를 사용해서 예제를 진행할 것이다. now도 다루자면 세부적인 설정이 많기 때문에 필요한 부분만 간단히 다루겠다.</p><p>먼저 now CLI를 설치한다. now는 별도의 바이너리가 있어서 Node.js 없어도 구동이 가능하지만 이 글을 보고있는 사람들은 모두 Node.js가 설치되어 있을테니, npm으로 설치하는 게 가장 간단하다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g now</span><br></pre></td></tr></table></figure><p>now가 설치되었으면 본격적으로 Storybook을 빌드한다. 빌드 명령어는 이미 <code>package.json</code>에 포함되어있으니 그냥 실행만 하면 된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build-storybook</span><br></pre></td></tr></table></figure><p>빌드된 파일은 <code>storybook-static</code> 폴더에 모두 들어간다. 이제 빌드된 파일을 디플로이하면 된다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ now deploy storybook-static</span><br></pre></td></tr></table></figure><p>회원가입이 아직 안되어있는 상태라면 회원가입이 필요할 것이다. 회원가입이 어렵지는 않으니 여기서 다루지는 않겠다. 디플로이가 완료되면 <code>.now.sh</code>로 끝나는 URL이 표시되며, 실제 그 URL로 접속하면 Storybook이 잘 나오는 걸 볼 수 있다.</p><p>하지만 now로 배포하면 URL에 랜덤하게 문자열이 붙는데, 매번 배포할 때마다 주소가 바뀌기 때문에 다른 사람들과 공유하기가 상당히 번거로워진다. 이걸 고정하기 위해서 alias 설정을 할 수 있다.</p><script src="https://gist.github.com/HyunSeob/5f786d0d4a12630e7e7276a01e4cc184.js"></script><p>위에서 이름이나 alias 필드 같은 경우는 프로젝트에 맞게 수정하면 된다. 그리고 아래처럼 명령어를 입력한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ now deploy storybook-static --<span class="built_in">local</span>-config=now.json</span><br></pre></td></tr></table></figure><p>name이나 public 설정이 안먹는 경우가 있는데 만약 그런 경우를 만난다면 다음과 같이 강제로 지정해주면 된다. 깊게 안봐서 그런지 아직 왜 그런지 모르겠는데.. 이 부분 아는 분 댓글 좀..</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ now deploy storybook-static --<span class="built_in">local</span>-config=now.json --public --name=&#123;프로젝트명&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 alias 명령어도 입력해주면 고정된 주소로 배포할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ now <span class="built_in">alias</span> --<span class="built_in">local</span>-config=now.json</span><br></pre></td></tr></table></figure><p>성공한다면 <code>{프로젝트명}.now.sh 라는</code> 주소로 배포될 것이다. 이를 모아서 npm 스크립트로 만들어두면 간단하게 배포할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build-storybook &amp;&amp; now deploy storybook-static --<span class="built_in">local</span>-config=now.json &amp;&amp; now <span class="built_in">alias</span> --<span class="built_in">local</span>-config=now.json</span><br></pre></td></tr></table></figure><h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap up"></a>Wrap up</h1><p>해외에서 널리 알려진 것에 비해서 우리나라에서는 아직까지는 주위에서 사용사례가 흔치는 않은 것 같다. 사실 별로 어렵지도 않고, 이렇다 할 사용방법도 딱히 필요없는 Storybook을 굳이 이렇게 글까지 써가면서 설명한 건, 내가 Storybook을 도입 후 사용하면서 큰 만족감을 느꼈고 다른 개발자들도 쓰길 바라는 마음에서였다. 물론 나도 그렇게 오랫동안 사용하지는 않았지만. 나 같은 경우는 전혀 알지도 못하고 있다가 작년에 React Seoul에서 진겸님의 발표를 보고 뽕맞아서 시작하게 되었는데 그 <a href="https://www.youtube.com/watch?v=KnROzZ5Vszg" target="_blank" rel="noopener">발표영상</a>과 <a href="http://seoul.reactjs.kr/assets/slides/storybook_driven_development.pdf" target="_blank" rel="noopener">슬라이드</a>도 있으니 한 번 참고하시면 좋겟다.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">마크다운으로 문서화를 할 수 있는 애드온도 있다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/storybook-beginners-guide/storybook.png&quot;/&gt;&lt;p&gt;페이지 단위의 개발이 이루어지던 과거와 달리 요즘의 프론트엔드 개발은 주로 컴포넌트 단위로 이루어진다. 이 컴포넌트라는 개념은 사용하는 라
      
    
    </summary>
    
      <category term="FrontEnd" scheme="https://hyunseob.github.io/categories/FrontEnd/"/>
    
    
      <category term="React" scheme="https://hyunseob.github.io/tags/React/"/>
    
      <category term="Storybook" scheme="https://hyunseob.github.io/tags/Storybook/"/>
    
  </entry>
  
  <entry>
    <title>2017년 회고</title>
    <link href="https://hyunseob.github.io/2017/12/30/2017-year-in-review/"/>
    <id>https://hyunseob.github.io/2017/12/30/2017-year-in-review/</id>
    <published>2017-12-30T14:04:30.000Z</published>
    <updated>2018-12-31T11:59:04.035Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/2017-year-in-review.png"/><p>2017년도 끝이 다가왔다. 나는 어떤 형태로든 매년 말마다 회고를 해왔다. 지금까지는 회고를 할 때마다 항상 내 스스로 “잘했다” 혹은 “많이 발전했다”라는 생각을 주로 했던 것 같다. <a href="/2016/12/10/a-look-back-on-blog-in-2016/">작년 회고</a>를 다시 돌아봐도 그렇다. 글 전체에서 “이 정도면 꽤 잘했지”라는 뉘앙스가 느껴진다. 뭐 작년에 내가 잘했다는 게 사실이더라도, 올해는 그렇게 생각할 수가 없다. 내가 명백히 작년보다 게을러졌기 때문이다.</p><h1 id="일"><a href="#일" class="headerlink" title="#일"></a>#일</h1><p>작년 10월에 블로그에 남겼던 것처럼 지금 다니고 있는 회사인 스튜디오 씨드로 이직을 했었고 물론 지금도 계속 일하고 있다. 처음 입사했을 때 예상했던 것과는 달리 일렉트론은 맛만 봤고, 내내 계속 새로운 프로젝트에 뛰어들면서 질릴 틈도 없이 재미있게 일했다. 연초에는 프로토파이를 유료로 팔기 위해서 결제연동 등을 진행했었는데 혼자서 처음부터 끝까지 결제연동을 구현한 건 처음이라 힙한 기술 쓴 것 하나 없지만 좋은 경험이 되었다. 중간에 AWS Lambda를 사용할 기회도 있었고 배포를 위해서 Docker와 ECS 등도 경험해보면서, 아직 잘 안다고 할 수준은 못되지만 그나마 조금은 AWS에 익숙해지기도 했다. 최근에는 ProtoPie와 연동되는 웹 기반의 새로운 서비스를 위해서 그동안 써보고 싶었던 건 다 쓰면서 프론트 개발에 집중하고 있다.</p><h1 id="학교"><a href="#학교" class="headerlink" title="#학교"></a>#학교</h1><p><blockquote class="instagram-media" data-instgrm-captioned="" data-instgrm-permalink="https://www.instagram.com/p/BRU1Mt8jIrH/" data-instgrm-version="8" style=" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);"><div style="padding:8px;"> <div style=" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;"> <div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div></div> <p style=" margin:8px 0 0 0; padding:0 4px;"> <a href="https://www.instagram.com/p/BRU1Mt8jIrH/" style=" color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;" target="_blank">ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 스물여덟에 학교도 다니고.. ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ #시밤 #세상에 일하면서 학교 다닐라니까 앞날이 깜깜 #복학</a></p> <p style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;"><a href="https://www.instagram.com/hyunseob.lee/" style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px;" target="_blank"> HyunSeob</a>(@hyunseob.lee)님의 공유 게시물님, <time style=" font-family:Arial,sans-serif; font-size:14px; line-height:17px;" datetime="2017-03-07T05:39:37+00:00">2017 3월 6 9:39오후 PST</time></p></div></blockquote> <script async defer src="//www.instagram.com/embed.js"></script></p><p>마침내 졸업이 다가오고 있다. 아직까지 마지막 학기 성적이 나온 건 아니라서 확정은 아니지만, 일단 학점을 제외한 요건은 모두 갖췄기 때문에 F가 없다면 졸업이다. 학업과 일을 병행한 올해 1년을 돌아볼 때, 사실 전혀 쉽지는 않았다는 생각이 든다. 1학기에는 취업계를 적용할 수 없어서 매주 멀고 먼 학교로 내려갔다 와야 했었다. 수업은 물론이고 과제, 졸업 작품까지 병행해야 했기 때문에 주말이고 평일이고 퇴근하면 코딩이랑 레포트 쓰기 바빴던 것 같다. 최악이었던 건, 지난 2년간 거의 켤 필요가 없었던 한글 오피스로 문서작업을 해야 했던 것이었다. 사실 졸업 작품도, 코딩하는 시간보다는 보고서 작성하는 시간이 훨씬 길었다. 2학기에는 취업계가 적용되었기 때문에 매주마다 학교로 갈 필요는 없었지만 퇴근 후 시간을 사용해야 했던 과제는 여전히 부담스러웠다. 사실 2학기에 신청한 학점이 더 많았기도 하고.. 이제 졸업 여부는 내년이 되어야 알 수가 있지만, 작년까지 자퇴를 진지하게 고려하고 있었다는 걸 상기해본다면 주변 분들의 많은 배려 덕분에 여기까지 올 수 있었던 것 같다.</p><h1 id="블로그"><a href="#블로그" class="headerlink" title="#블로그"></a>#블로그</h1><p>블로그는 여전히 나에게 가장 중요한 매체다. 하지만 올 한 해 작성한 글은 이 글까지 포함해도 총 14개. 약 한 달에 한 번 포스팅한 꼴이다. 작년에 27개의 포스트를 작성했으니 약 반수 이하로 줄어든 셈이다. 줄어든 이유는, 위에도 써 둔 것처럼 학교라는 좋은 핑계 거리가 있긴 하지만서도 결국, 내가 게을렀다는 결론에 이를 수 밖에 없다. 지금 가지고 있는 글감도 꽤 많은 편인데 그걸 실행에 옮기지 못했다. 특히나 올해는 새로운 기술을 많이 접했고 좋은 경험도 얻어서 기술적으로는 넓게 알게 되었던 해이기 때문에 새로 배운 것들을 단단하게 내것으로 만들기 위해서 더욱 글을 많이 썼어야 했는데, 그러지 못했다. 그나마 꾸준히 했다는 것으로 위안을 삼아야 겠다. 내년 목표는 작년 수준으로 글 쓰는 횟수를 다시 회복하는 것이다.</p><h1 id="번역"><a href="#번역" class="headerlink" title="#번역"></a>#번역</h1><p>연초에 <a href="https://hyunseob.github.io/solved-by-flexbox-kr/">solved-by-flexbox</a>라는 flexbox를 활용하는 방법을 소개한 프로젝트를 번역했고, 5월 쯤에 “함수형 프로그래밍이 뭔가요?”라는 글을 번역했었으나 원저자가 글을 내려달라고 요청해서 글을 삭제해야만 했다. 원래 번역 허락을 구해놓고 기다리면서 번역을 하다가 답변이 오랫동안 안와서 올렸던 글인데, 저자에게서 삭제요청이 와서 삭제를 하게 됐다. 그리고 9월에 <a href="https://github.com/HyunSeob/project-guidelines/blob/master/README-ko.md" target="_blank" rel="noopener">Project Guidelines</a> 라는 흔히 회사에서 사용할 법한 가이드라인을 다루는 프로젝트를 번역했다. 전체적으로 작년에 비해서 번역양이 적었다. 내가 게을렀기도 했고, 번역하고 싶다는 욕구가 적어지기도 했다. 사실 번역은 꼭 해야 좋은 거라는 생각이 들지는 않는다.</p><h1 id="오픈소스"><a href="#오픈소스" class="headerlink" title="#오픈소스"></a>#오픈소스</h1><p>여러가지 정말 작은 규모로 레포지토리도 만들고 npm 모듈도 배포하고 했으나 모두 큰 의미는 없는 것들이었다. 올해 그나마 가장 많이 커밋했던 건 역시 내가 작년에 만들었던 hexo 테마인 <a href="https://github.com/HyunSeob/hexo-theme-overdose" target="_blank" rel="noopener">hexo-theme-overdose</a>다. 버전 1.0.0을 배포하면서 나름대로 리팩토링도 하고 소스코드에도 변경사항이 꽤 많았지만, 그래도 이걸 바닥부터 시작해서 다 만들어서 배포까지 했었던 작년에 비해서는 아쉬운 수준이다.</p><p>다른 오픈소스에 공헌한 것도 별로 많지 않다. 번역을 제외한다면, 실질적으로 의미가 있었던 건 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/19112" target="_blank" rel="noopener">DefinitelyTyped의 multer에 PR</a> 날린 것과, <a href="https://github.com/postcss/autoprefixer/issues/899" target="_blank" rel="noopener">autoprefixer에 사소한 이슈</a>를 제보했던 것, 그리고 최근에 날렸던 PR 두개 정도.</p><iframe src="https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fhyunseob.lee.7%2Fposts%2F1444235505684862&width=500" width="500" height="373" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe><p>전체적으로 작년보다 잘했느냐 하면 그냥저냥 비슷한 수준인 것 같다. 뭐 꼭 오픈소스를 잘해야 뛰어난 개발자는 아니지만, 많은 도움을 받고 있는 만큼 공헌하는 것에도 노력을 기울여야 겠다.</p><h1 id="컨퍼런스-밋업"><a href="#컨퍼런스-밋업" class="headerlink" title="#컨퍼런스/밋업"></a>#컨퍼런스/밋업</h1><p>작년까지는 한 번도 발표 경험이 없었지만 그래도 올해는, 뭔가 하기는 했다. 2월에 기술적인 내용이 아니긴 했으나 9XD에서 <a href="/2017/02/26/blog-for-developers/">개발자라면 블로그</a>라는 주제로, 4월에는 <a href="https://www.slideshare.net/hyunseoblee7/type-system-in-typescript-74548710" target="_blank" rel="noopener">TypeScript의 Type System</a>에 관해서, 그리고 6월에는 <a href="http://slides.com/hyunseob/react-router#/" target="_blank" rel="noopener">React Router v4</a>에 대해서도 발표를 했었다. 발표 경험이 그다지 많지 않아서 잘못했던 기억이 많이 나고, 올해 정말 훌륭한 발표를 많이 봐서 그런지, 내가 발표했던 건 부끄럽기만 하다.</p><p>그냥 참가자로서 참가했던 것도 많았는데, 후기를 전혀 남기지 않아서 최근 걸 제외하면 기억이 잘 남지 않는다. 앞으로는 좀 필기하는 버릇을 들이려고 한다. 타이핑 말고 필기. <a href="https://academy.realm.io/kr/posts/droidcon-boston-chiu-ki-chan-how-to-be-an-android-expert/#%EC%8A%A4%EC%BC%80%EC%B9%98%EB%85%B8%ED%8A%B8-%EC%B6%94%EA%B0%80" target="_blank" rel="noopener">이 글</a>에서 나온 것처럼 스케치 노트를 쓰는 게 내 스스로에게도, 물론 남에게 공유할 때에도 더 도움이 많이 될 거라는 생각이 들어서 이제부터 실천을 해볼 생각이다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>올해 나는 학교와 직장을 병행했기 때문에 분명, 작년에 비해 시간이 많이 부족했던 게 사실이다. 그럼에도 불구하고 내가 게을렀기 때문에 잃은 시간이 훨씬 많다. 시간이 남으면 유튜브나 넷플릭스 보기 바빴으며, 모바일 게임에 하루 3시간씩 투자하던 때도 있었고, 해야할 일이 많을 때도 애써 회피하면서 그냥 웹서핑이나 할 때가 많았다. 물론, 사람이 24시간, 365일 생산적인 일에만 몰두하는 건 불가능하고, 그럴 필요도 없다고 생각한다. 내 진짜 문제점은 사실 게으른 게 아니라, 뭘 하는데 있어서 계획이 없었고 모든 일과 결정을 충동적으로 했었다는 것이다. 내년은 좀 더 계획성있게 쓰는 시간을 컨트롤할 수 있는 해가 될 수 있도록, 개인적으로 회고를 좀 더 자주하고, 조금 더 많이 메모와 기록을 하면서, 구체적인 계획을 만들어 보고자 한다. 2018년 회고는 올해보다는 잘한 걸로 내용을 채울 수 있었으면 좋겠다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/2017-year-in-review.png&quot;/&gt;&lt;p&gt;2017년도 끝이 다가왔다. 나는 어떤 형태로든 매년 말마다 회고를 해왔다. 지금까지는 회고를 할 때마다 항상 내 스스로 “잘했다” 혹은 “많이 발전했다”라는 생각을 
      
    
    </summary>
    
      <category term="Log" scheme="https://hyunseob.github.io/categories/Log/"/>
    
    
      <category term="Year in review" scheme="https://hyunseob.github.io/tags/Year-in-review/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: 타입 추론과 타입 단언</title>
    <link href="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/"/>
    <id>https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/</id>
    <published>2017-12-12T13:11:24.000Z</published>
    <updated>2018-12-31T10:15:02.280Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이 있을 때 타입을 정의하는 일은 정적 타이핑 환경에서는 피할 수 없는 문제지만 타입 선언에 대한 압박은 타입 추론이 얼마나 잘 되느냐에 따라 그 정도가 매우 다르다.</p><p>전통적인 정적 타입 언어에서는 모든 변수나 파라미터, 프로퍼티 등의 타입을 모두 선언해야하기 때문에, 타입 추론 같은 기능이 필요없다. 하지만 TypeScript 에서는 모든 변수에 항상 타입을 선언할 필요가 없으므로 컴파일러가 타입 추론을 잘해주기만 해도 타입 선언 비용이 상당히 줄어든다.</p><h2 id="타입-추론-Type-Inference"><a href="#타입-추론-Type-Inference" class="headerlink" title="타입 추론(Type Inference)"></a>타입 추론(Type Inference)</h2><p>타입 추론의 기본적인 동작을 간단한 예제를 통해서 알아보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="literal">true</span>, <span class="number">1</span>];</span><br><span class="line">bool = <span class="number">1</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>위의 예제에서 각 변수의 타입은 적절하게 추론되므로 다시 사용할 때 Type Safe 하게 사용할 수 있다. <code>bool</code>의 타입은 <code>boolean</code>으로 추론되므로 <code>number</code> 타입인 <code>1</code>을 할당하려고 하면 에러가 발생한다. <code>arr</code> 변수는 <code>number[]</code>, 즉 <code>number</code> 타입의 배열로 추론된다. 이 때 배열의 길이는 항상 고정이 아닌 것으로 추론한다. 즉, 투플이 아니다. 아래의 <code>tuple</code> 변수도 마찬가지로 배열로 추론된다. 만약 투플로 사용하고 싶다면 별 수 없이 타입 선언을 해주어야 한다. 다만 배열의 요소가 각각 <code>boolean</code>과 <code>number</code>이기에 최종적으로 추론되는 타입은 <code>boolean</code>과 <code>number</code>의 <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" target="_blank" rel="noopener">유니온</a> 타입의 배열, 코드로 나타내면 <code>(boolean | number)[]</code>이다.</p><p>여기에서 배열에서 사용된 요소들의 타입을 각각 추론하여 유니온 타입으로 만들어 내는 방식을 TypeScirpt 에서는 <a href="https://www.typescriptlang.org/docs/handbook/type-inference.html#best-common-type" target="_blank" rel="noopener">Best common type</a>이라고 부른다.</p><h3 id="Best-common-type"><a href="#Best-common-type" class="headerlink" title="Best common type"></a>Best common type</h3><p>Best common type 은 말 그대로 가장 일반적인 타입이다. 여러가지 자료형이 배열 내부에서 사용되고 있을 때, 그 여러가지 자료형을 포괄할 수 있는 가장 일반적인 자료형을 추론하는 것이다. 그 결과로 위의 예제에서는 <code>true</code>와 <code>1</code>을 포괄할 수 있는 자료형인, <code>(boolean | number)</code>가 추론된 것이다.</p><p>Best common type 은 대부분의 경우에 유니온 타입으로 추론되지만 예외적인 케이스도 몇 가지 있다. 먼저 특정 클래스가 다른 클래스를 상속한 경우.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  foo = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="keyword">new</span> Parent(), <span class="keyword">new</span> Child()];</span><br></pre></td></tr></table></figure><p>위의 예제에서 <code>arr</code> 변수의 타입은 <code>Parent[]</code>로 추론된다. <code>Parent</code> 타입이 <code>Child</code> 타입을 포괄할 수 있는 타입이므로 그렇게 추론되는 것이다. 하지만 다음의 예제에서는 조금 다르다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  foo = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child1 <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child2 <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  baz = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="keyword">new</span> Child1(), <span class="keyword">new</span> Child2()];</span><br></pre></td></tr></table></figure><p>여기에서도 분명 <code>Parent</code> 타입은 <code>Child1</code> 타입과 <code>Child2</code> 타입을 포괄할 수 있는 타입이다. 따라서 마찬가지로 <code>Parent[]</code>로 타입이 추론되는 것이 타당해 보이지만, 실제로는 다시 유니온 타입으로, <code>(Child1 | Child2)[]</code>로 추론된다. 이유는 모르겠지만 아마 약간의 기술적인 어려움이 있는 것이 아닐까 예상된다.</p><p>함수가 상황에 따라 여러가지 타입의 값들을 리턴하는 경우에서도 리턴 값이 위와 동일한 룰을 따라 추론된다. 다만 상수를 리턴하면 그 값 자체가 타입으로 인식되는 리터럴 타입으로 추론된다.</p><h2 id="타입-단언-Type-Assertion"><a href="#타입-단언-Type-Assertion" class="headerlink" title="타입 단언(Type Assertion)"></a>타입 단언(Type Assertion)</h2><p>TypeScript 의 타입 추론 기능은 매우 강력하지만 어쩔 수 없는 한계가 존재한다. 타입 단언은 TypeScript 컴파일러가 타입을 실제 런타임에 존재할 변수의 타입과 다르게 추론하거나 너무 보수적으로 추론하는 경우에 프로그래머가 수동으로 컴파일러한테 특정 변수에 대해 타입 힌트를 주는 것이다.</p><p>다음 예제를 살펴보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Character &#123;</span><br><span class="line">  hp: <span class="built_in">number</span>;</span><br><span class="line">  runAway() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  isWizard() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  isWarrior() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Wizard <span class="keyword">extends</span> Character &#123;</span><br><span class="line">  fireBall() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Warrior <span class="keyword">extends</span> Character &#123;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    character.fireBall(); <span class="comment">// Property 'fireBall' does not exist on type 'Character'.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    character.attack(); <span class="comment">// Property 'attack' does not exist on type 'Character'.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 컴파일 에러를 낸다. <code>Character</code> 클래스에는 <code>fireBall</code>, <code>attack</code> 메소드가 선언조차 되어있지 않기 때문이다. 하지만 프로그래머 입장에서 바라보면 <code>isWizard</code>라는 메소드를 통해 확실히 그 캐릭터가 <code>Wizard</code> 인스턴스라는 걸 보장할 수 있다면, <code>if</code> 블록 안에서는 당연히 <code>fireBall</code>이라는 메소드를 사용할 수 있어야 한다.</p><p>이 때, 타입 단언으로 적절한 타입을 다시 선언해줄 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    (character <span class="keyword">as</span> Wizard).fireBall(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    (character <span class="keyword">as</span> Warrior).attack(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 변수가 실제로 Wizard 인스턴스가 아니더라도 <code>as</code> 키워드를 통해서 타입 단언을 해줄 수 있기 때문에, 타입 단언은 주의해서 사용해야 한다. 실제로도 <code>as any</code> 라는 치트키로 대부분의 컴파일 에러를 해결할 수 있다. 하지만 이런 키워드가 코드 베이스에 득시글 거릴 수록 TypeScript 를 사용해서 얻는 장점이 점차 사라져가기 때문에, 기왕 TypeScript 를 사용하기로 마음 먹었다면 <code>as</code>와 <code>any</code>는 가능한 적게 사용하는 것이 좋다. 물론, 아예 사용하지 않기는 어렵다.</p><h3 id="타입-단언이-타입-캐스팅이-아닌-이유"><a href="#타입-단언이-타입-캐스팅이-아닌-이유" class="headerlink" title="타입 단언이 타입 캐스팅이 아닌 이유"></a>타입 단언이 타입 캐스팅이 아닌 이유</h3><p>타입 단언은 타입을 변경한다는 사실 때문에 타입 캐스팅과 비슷하게 느껴질 수 있다. 타입 단언이 타입 캐스팅이라고 불리지 않는 이유는 런타임에 영향을 미치지 않기 때문이다. 타입 캐스팅은 컴파일타임과 런타임에서 모두 타입을 변경시키지만 타입 단언은 오직 컴파일타임에서만 타입을 변경시킨다.</p><h3 id="lt-Type-gt-vs-as-Type"><a href="#lt-Type-gt-vs-as-Type" class="headerlink" title="&lt;Type&gt; vs as Type"></a><code>&lt;Type&gt;</code> vs <code>as Type</code></h3><p>타입 단언 문법은 <code>&lt;Type&gt;</code> 과 <code>as Type</code> 으로 두 종류다. 아래처럼 사용할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;Wizard&gt;character).fireBall();</span><br><span class="line">(character <span class="keyword">as</span> Wizard).fireBall();</span><br></pre></td></tr></table></figure><p>그냥 보기에는 <code>&lt;Type&gt;</code> 키워드가 좀 더 깔끔해보이지만, 대개 <code>as Type</code> 키워드가 추천된다. React 와 React 에서 빼놓을 수 없는 문법인 JSX 를 사용하는 경우 <code>&lt;Type&gt;</code> 키워드는 JSX 의 문법과 겹치기 때문에 불편한 면이 있다.</p><h3 id="타입-가드-Type-Guard"><a href="#타입-가드-Type-Guard" class="headerlink" title="타입 가드(Type Guard)"></a>타입 가드(Type Guard)</h3><p>타입 가드는 타입 단언을 좀 더 깔끔하게 할 수 있도록 도와준다. 앞서 타입 단언에서 소개한 예제에서는 <code>isWizard</code>라는 메소드로 해당 인스턴스가 해당 타입이라는 사실을 확정했다. 하지만 이건 런타임에서만 알 수 있는 사실이고 TypeScript 컴파일러는 알 수 없었다. 타입 가드는 이러한 런타임에서의 타입 체크를 컴파일러에게 알려주는 기능이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Character &#123;</span><br><span class="line">  isWizard(): <span class="keyword">this</span> is Wizard &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> Wizard;</span><br><span class="line">  &#125;</span><br><span class="line">  isWarrior(): <span class="keyword">this</span> is Warrior &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> Warrior;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 런타임에서 실제 타입검사를 하는 메소드의 리턴타입으로 <code>{variable} is {Type}</code> 같은 문법을 사용해 선언해주면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    character.fireBall(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    character.attack(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 별도의 타입 단언 문법 없이도 <code>if</code> 블록 안에서 <code>character</code>가 <code>Wizard</code>나 <code>Warrior</code>로 잘 추론된다. 그리고 사실 <code>instanceof</code> 와 <code>typeof</code> 같은 오퍼레이터가 일종의 타입 가드이기도 하다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    val.toFixed(); <span class="comment">// Pass, val은 number 타입으로 추론</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Union 타입에서 `number`는 이미 통과했으므로 자동으로 `string`으로 추론됨</span></span><br><span class="line">    val.toLowerCase(); <span class="comment">// Pass, val은 string 타입으로 추론</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사족-타입-선언은-언제하는가"><a href="#사족-타입-선언은-언제하는가" class="headerlink" title="사족: 타입 선언은 언제하는가?"></a>사족: 타입 선언은 언제하는가?</h2><p>별도의 선언이 없어도 추론이 잘 되는 경우에는 타입 선언을 하지 않고, 그렇지 않은 경우에만 선언하는 것이 편리하고 자연스럽다. 예를 들면,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex: <span class="built_in">RegExp</span> = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/pattern/</span>);</span><br></pre></td></tr></table></figure><p>위와 같은 상황에서 <code>: RegExp</code> 라는 코드는 불필요한 선언으로 간주하고 지운다. 하지만 다음처럼 변수 생성과 동시에 값을 할당하지 않는 경우,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="literal">null</span>;</span><br><span class="line">regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/pattern/</span>);</span><br></pre></td></tr></table></figure><p>이런 상황에서는 <code>regex</code> 변수의 타입 추론이 제대로 되지 않으므로 타입을 같이 선언해준다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>[책] 애자일 &amp; 스크럼 프로젝트 관리</title>
    <link href="https://hyunseob.github.io/2017/10/26/understanding-agile-scrum-project-management/"/>
    <id>https://hyunseob.github.io/2017/10/26/understanding-agile-scrum-project-management/</id>
    <published>2017-10-26T11:59:09.000Z</published>
    <updated>2018-12-31T10:15:02.281Z</updated>
    
    <content type="html"><![CDATA[<p>처음 애자일이나 스크럼 등의 개념을 접한 건 아마 전 직장을 다닐 때 였을 것이다. 당시 나에게는 첫 직장이었기 때문에 전통적인 개발 방법론도 제대로 겪어본 적이 없었던 나에겐, 이런 방식이 딱히 신기하다거나 특이하달 것도 없었다. 그냥 원래 일을 그런 식으로 하는 가보다 하면서 받아들였던 것 같다(잘 실천되었는가는 차치하고서라도).</p><p>사실 애자일이나 스크럼, 칸반, 이런 용어는 이 쪽 업계에 발만 담구고 있어도 귀에 딱지가 앉도록 들을 수 있다. 나도 원래부터 지나가는 트렌드에 관심이 많고, 한창 성장하고 싶은 시기기 때문에 관련 글도 나름 많이 읽었지만, 애자일이나 스크럼에 대해 설명해보라고 하면 한 마디도 제대로 꺼낼 수 없는, 뭐랄까 느낌적인 느낌의 무언가였다. 지난 2년동안 서서히 나에게 스며들고 있었던 이 개념에 대해서 좀 더 제대로 알고 싶었고, 애자일 문화에서 말하는 좋은 팀원이 되고 싶기도 했다. 그래서 <a href="https://www.linkedin.com/pulse/agile-dead-matthew-kern/" target="_blank" rel="noopener">애자일은 죽었다</a>라는 소리도 나오는 마당에 다소 뒤처진 감이 없진 않지만, 이 책을 읽게 되었다.</p><p><img src="/images/understanding-agile-scrum-project-management.jpg" alt="애자일 &amp; 스크럼 프로젝트 관리"></p><p>이 책은 사실 나 같은 팀원보다는 관리자의 직책을 가진 사람을 대상독자로 쓰여진 책이라는 느낌이다. 물론 그렇다고 내가 참고할 부분이 전혀 없는 것은 아니었다. 사실 이 책에서 강조하는 키워드는 익히 우리가 가치있는 것으로 이미 받아들이고 있는 것들이다. 책임과 자율성, 수직보다는 수평적인 관계, 경쟁보다는 협력.. 같은 가치들. 이 책에서는 이런 가치들을 강조하는 것에서 끝나지 않고 실질적으로 어떻게 해야되는가를 주로 다루고 있다. 이를테면 자기조직화된 팀으로 만들기 위해서는 팀원 개개인에게 의사결정권을 부여해야 한다, 던가.</p><p>내가 이 책을 읽기 전에 기대했었던, 좋은 팀원이란 어떤 사람인가에 대해서도 다루고 있다. 책 내용 중 아마도 가장 나에게 의미가 있을만한 부분, ‘애자일 팀원이 가져야 할 팀 스피릿’을 발췌했다.</p><ol><li>개인에게 주어진 업무를 팀 전체의 책임으로 받아들인다.</li><li>잘 모르는 부분이 있으면 언제든지 서로에게 도움을 요청하거나 돕는다.</li><li>상대방을 항상 존중하고 배려한다.</li><li>자신이 약속한 것은 최선을 다해 지키려고 노력한다.</li><li>업무상황을 솔직하게 이야기 한다.</li><li>동료, 이해관계자와 적극 대화하고 협력한다.</li></ol><p>개인적으로는 위 항목을 내가 다 실천하고 있지는 않고 있다는 생각이다. 특히 나는 아직도 2,3번을 잘 못할 때가 많은 것 같다. 갈 길이 멀다는 걸 다시 느끼게 되었다. 내가 지금 일하고 있는 회사가 애자일을 잘 실천하고 있는 사례인가에 대해서는, 확실하지는 않지만, 지금까지 일하면서 동기가 무너지거나 일하는 게 고통스러웠던 적은 없으므로 베스트 프랙티스는 아닐지언정 나름대로 잘 실천하고 있는 조직이 아닐까 한다. “아 이랬던 게 애자일에서 프랙티스로 다루고 있던 부분이구나” 하는 것들도 있었고.</p><hr><p>이 책에서 아쉬웠던 부분은, 애자일이 성공했던 사례와 애자일을 적용하기 적합한 상황에 대해서만 다루었다는 것이다. 물론 저자의 이력을 생각해보면 이해할 수 있지만, 그런 상황일 수록 더욱 한계에 주목하고 그것을 극복할 방법에 대해서 고민해보는 것도 필요할 것이다. 책에서도 종종 강조한 부분이지만, 애자일은 모든 상황에 있어서 만능이 아니며 상황에 맞게 적절히 소화해서 적용해야 한다. 하지만 실제로 책에서는 애자일의 한계가 어떤 것인지, 그리고 그걸 해결하기 위해 실제로 어떤 것들을 할 수 있는지에 대해서는 전혀 다루고 있지 않다. 물론 나에게 애자일의 한계가 무엇이냐고 물어본다면, 뭐 솔직히 나도 잘 모르겠다.</p><p>이 책을 다 읽고나니, 애자일은 단순한 소프트웨어 개발 방법론을 넘어, 조직문화까지도 만들어가는 것이라는 걸 알게 되었다. 이제 나는 애자일에 대해서 나만의 정의를 내렸다. 애자일은 “모든 조직 구성원들이 회사가 회사라기보다는 우리 팀이라고 느낄 수 있게 하는 것”이 아닐까?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;처음 애자일이나 스크럼 등의 개념을 접한 건 아마 전 직장을 다닐 때 였을 것이다. 당시 나에게는 첫 직장이었기 때문에 전통적인 개발 방법론도 제대로 겪어본 적이 없었던 나에겐, 이런 방식이 딱히 신기하다거나 특이하달 것도 없었다. 그냥 원래 일
      
    
    </summary>
    
      <category term="Book" scheme="https://hyunseob.github.io/categories/Book/"/>
    
    
      <category term="Agile" scheme="https://hyunseob.github.io/tags/Agile/"/>
    
  </entry>
  
  <entry>
    <title>MobX with React</title>
    <link href="https://hyunseob.github.io/2017/10/18/mobx-with-react/"/>
    <id>https://hyunseob.github.io/2017/10/18/mobx-with-react/</id>
    <published>2017-10-17T17:08:52.000Z</published>
    <updated>2018-12-31T10:15:02.270Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/mobx-with-react.jpg"/><p>이전 글에서는 React를 배제한 채로 MobX만 사용했었고, Angular 혹은 jQuery와 연계해서 사용할 수도 있지만 MobX는 React랑 함께 사용되는 게 가장 일반적이다. 이번 글에서는 MobX와 React를 연계해서 사용하는 내용에 대해서 다룬다. 만약 이전 글을 읽지 않았다면, 먼저 이 글을 읽기 전에 <a href="/2017/10/07/hello-mobx/">읽기</a>를 권한다.</p><p>MobX와 React를 같이쓰려면 물론, MobX와 React 모듈이 필요하고, 추가로 <a href="https://github.com/mobxjs/mobx-react" target="_blank" rel="noopener">mobx-react</a>라는 모듈을 설치하면 시작할 수 있다. 이 mobx-react라는 라이브러리는 API도 별로 없고 하는 일도 간단하다. React 컴포넌트를 Observable 데이터에 반응하도록 만들어주는 것이다.</p><h2 id="observer"><a href="#observer" class="headerlink" title="observer"></a><code>observer</code></h2><p>그 몇 안되는 API 중에 가장 자주 사용하게 될 것은 <code>observer</code>이다. 코드를 통해 간단히 어떻게 동작하는지 알아보자.</p><iframe src="https://stackblitz.com/edit/mobx-with-react-1?embed=1&file=index.js" style="width:100%; height: 500px;"></iframe><p>결과를 확인해보면 이전 글에서 <code>autorun을</code> 사용했을 때 처럼 데이터가 변경될 때마다 뷰가 업데이트되고 있는 것을 확인할 수 있다. 실제로 MobX 문서의 설명에도, “<code>mobx.autorun</code>에 컴포넌트의 렌더 메소드를 래핑해서 컴포넌트를 렌더링 할 때 사용되는 데이터가 변경되었을 때 다시 렌더링하게 만든다”고 설명하고 있다. 즉 간단히 <code>observer</code>만 선언해주면 <code>render</code> 메소드가 <code>autorun(render)</code> 되는 것이다.</p><h3 id="어떤-컴포넌트에-observer를-사용해야-하는가"><a href="#어떤-컴포넌트에-observer를-사용해야-하는가" class="headerlink" title="어떤 컴포넌트에 observer를 사용해야 하는가?"></a>어떤 컴포넌트에 <code>observer</code>를 사용해야 하는가?</h3><p>실제로 어플리케이션을 구현하다보면 <code>observer</code>를 상당히 많이, 거의 모든 컴포넌트에 선언하게 되는데, 이게 렌더링 성능에 악영향을 끼치지 않을까 걱정이 되기도 한다. MobX에서는 <code>observer</code>라는 함수 혹은 데코레이터를, Observable 데이터를 렌더하는 모든 컴포넌트에 선언하는 걸 추천한다. MobX에서 이를 최적화하기 때문이다. 만약 자식 컴포넌트에서 Observable 값을 표시하면서 자식 컴포넌트와 부모 컴포넌트가 동시에 <code>observer</code>를 가지고 있다고 해도, 해당 데이터는 자식 컴포넌트에만 다시 렌더링된다. 그러니까 정말 필요한 컴포넌트만 반응(렌더)을 하도록 만든다고 한다.</p><p>Dumb Component에 <code>observer</code>를 선언하게 되면 더 이상 Dumb하지 않지 않는가? 라는 의견도 있었는데, MobX의 창시자인 Michel Weststrate의 의견에 따르면 <code>observer</code>를 선언하는 것이 Dumb와 Smart를 가르는 기준은 아니라고 한다. 이 <a href="https://www.reddit.com/r/reactjs/comments/4vnxg5/free_eggheadio_course_learn_mobx_react_in_30/d61oh0l/" target="_blank" rel="noopener">스레드</a>를 참조.</p><h3 id="Stateless-Functional-Component와의-사용"><a href="#Stateless-Functional-Component와의-사용" class="headerlink" title="Stateless Functional Component와의 사용"></a>Stateless Functional Component와의 사용</h3><p>위의 예제는 클래스를 이용해 React 컴포넌트를 만들어서 편리한 데코레이터를 이용해서 감쌀 수 있었지만, 함수를 이용해 React 컴포넌트를 만들 경우에는, <code>observer</code>를 함수로 사용해서 컴포넌트를 감싸야 한다.</p><iframe src="https://stackblitz.com/edit/mobx-with-react-2?embed=1&file=index.js" style="width:100%; height: 500px;"></iframe><h3 id="컴포넌트-내부-변수로-observable-사용하기"><a href="#컴포넌트-내부-변수로-observable-사용하기" class="headerlink" title="컴포넌트 내부 변수로 observable 사용하기"></a>컴포넌트 내부 변수로 <code>observable</code> 사용하기</h3><p>MobX를 React에 적용해서 좋은 점 중 하나는 더 이상 <code>setState</code>를 사용하지 않고도 컴포넌트에 내부 상태를 만들고, 변이시킬 수 있다는 점이다. 스토어를 새로 만들 필요도 없다. 그냥 컴포넌트 안에 Observable 값을 하나 선언해주기만 하면 끝이다.</p><iframe src="https://stackblitz.com/edit/mobx-with-react-3?embed=1&file=index.js" style="width:100%; height: 500px;"></iframe><p>코드를 보면 컴포넌트 안에 선언된 <code>count</code>라는 변수는 해당 예제에서 사실상 내부 상태로 활용되고 있는데, 순수 React만 사용해서 이런 걸 표현하려면 <code>state</code>를 활용해야 했다. MobX를 이용하면 내부상태를 표현할 때도 그냥 일반적인 클래스 사용하듯 너무 쉽게 코드를 짤 수 있다.</p><p>Michel Weststrate도 <code>setState</code>의 단점들과 그것을 MobX로 어떻게 해결했는지에 대해 <a href="https://blog.cloudboost.io/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" target="_blank" rel="noopener">글</a>을 남겼으니 참고하시기 바란다.</p><h2 id="lt-Provider-gt-와-inject"><a href="#lt-Provider-gt-와-inject" class="headerlink" title="&lt;Provider&gt;와 inject"></a><code>&lt;Provider&gt;</code>와 <code>inject</code></h2><p>MobX가 Redux처럼 단일 스토어를 권장하지는 않지만, 특별히 중복을 좋아하는 게 아니라면 어떤 하나의 데이터를 관리할 스토어를 여러 개 만들 필요는 없을 것이다. 이는 결국 스토어를 특정 컨텍스트에서만 초기화하도록 만드는데, React의 컴포넌트 프로퍼티로 스토어를 일일히 내려주려면 이만저만 귀찮은 것이 아닐 것이다. mobx-react 패키지는 이를 위해서 간단한 의존성 주입을 위한 문법 설탕을 제공한다. 그것이 바로 <code>&lt;Provider&gt;</code>와 <code>inject</code>이다.</p><iframe src="https://stackblitz.com/edit/mobx-with-react-4?embed=1&file=index.js" style="width:100%; height: 500px;"></iframe><p>예제 코드를 보면 특별히 <code>&lt;Counter&gt;</code> 컴포넌트에 프로퍼티를 선언해 준 것도 아닌데 스토어가 <code>this.props</code>에 들어와서 컴포넌트 내부에서 사용하고 있는 것을 볼 수 있다. <code>&lt;Counter&gt;</code> 상위에 <code>&lt;Provider&gt;</code>를 선언해주고, <code>inject</code>를 데코레이터로 사용해 간단히 의존성을 주입했다. <code>&lt;Provider&gt;</code>는 반드시 최상단에 위치하거나 부모일 필요는 없지만 의존성 주입이 필요한 컴포넌트보다는 상위에 존재해야 한다(즉, 조상이어야 한다). 그리고 컴포넌트의 상단에 <code>inject</code>로 필요한 의존성을 선언하기만 하면 된다.</p><p>주입될 수 있는 의존성은 반드시 MobX 스토어일 필요가 없다. JavaScript 기본 자료형이든 뭐든 넘길 수 있다. 다만 이 값은 더 이상 변경되지 않아야 하는 값이다. 값이 변경된다고 해서 새로운 값이 주입되지는 않는다.</p><p>또 하나의 주의할 점은 <code>@inject</code>가 <code>@observer</code>보다 상단에 위치해야만 한다는 것이다. 그러니까 <code>@observer</code>가 보다 안쪽의 데코레이터가 되어야 한다. 이것은 데코레이터가 아닌 함수 문법의 경우도 동일하다.</p><h2 id="성능-최적화"><a href="#성능-최적화" class="headerlink" title="성능 최적화"></a>성능 최적화</h2><p><code>observer</code>는 기본적으로 <code>render</code> 메소드에 <code>autorun</code>을 씌운 것이다보니, 조금만 잘못짜도 <code>render</code>가 비효율적으로 동작할 수 있게된다.</p><iframe src="https://stackblitz.com/edit/mobx-with-react-5?embed=1&file=index.js" style="width:100%; height: 500px;"></iframe><p>위의 예제에서는 1초가 지날때마다 <code>seconds</code> 값이 1번 변하고, <code>tenth</code> 값은 10번 변하므로 1초에 약 11번의 렌더링이 일어난다. 변하는 값을 뷰에 업데이트 해야하기 때문에 1초에 11번의 렌더는 사실 어쩔 수 없다. 하지만 렌더되는 영역은 좀 비효율적이다.</p><p><code>seconds</code> 값이 변했을 때, 진짜 렌더가 필요한 영역은 오직 28번째 줄에 있는 코드뿐인데, <code>&lt;Timer&gt;</code> 컴포넌트에서 렌더하는 모든 영역이 다시 렌더되고 있다. 이는 <code>tenth</code> 값이 변했을 떄도 마찬가지다. <code>tenth</code> 값이 변했을 때 <code>seconds</code> 값이 표현되는 뷰가 다시 렌더링되고, <code>seconds</code> 값이 변했을 떄 <code>tenth</code> 값이 표현되는 뷰가 다시 렌더링되는 것이다.</p><p>MobX에서는 이런 케이스를 위해서 컴포넌트를 최대한 잘게 쪼개라고 가이드한다. 진짜 필요한 부분만 다시 렌더링하도록 만들라는 것이다. 이제 아래의 개선된 버전을 보자.</p><iframe src="https://stackblitz.com/edit/mobx-with-react-6?embed=1&file=index.js" style="width:100%; height: 500px;"></iframe><p>개선된 버전에서는 더 이상 <code>&lt;Timer&gt;</code> 컴포넌트의 렌더 메소드가 <code>seconds</code>와 <code>tenth</code> 값의 영향을 받지 않는다. 따라서 <code>&lt;Timer&gt;</code>는 딱 1회만 렌더되는 것이다.</p><p>물론, 여전히 <code>&lt;SecondsTimer&gt;</code>와 <code>&lt;TenthTimer&gt;</code>는 수시로 렌더링되지만, 더 이상 그 값의 변화가 다른 컴포넌트의 렌더링에 영향을 미치지 않는다. 따라서 각 컴포넌트의 렌더링 횟수도 통째로 렌더링 되었을 때보다는 적다.</p><p>여기에 있는 예제는 굉장히 축소된 예제로, 실제로 렌더 비용이 높은 컴포넌트가 있는데 이 컴포넌트가 <code>&lt;input&gt;</code> 값 등에 의해 수시로 렌더링이 다시 된다면 그게 얼마나 끔찍하게 비효율적인지는 다들 공감할 수 있을 것이다.</p><p>이런 상황은 MobX를 사용하지 않더라도 충분히 일어날 수 있는 일이지만 MobX에서는 <code>render</code>가 암시적으로 일어나고, 일으키기가 매우 쉽기 때문에 MobX를 쓸 때 더 쉽게 범하는 실수가 된다.</p><p>이외에도 다른 성능 최적화 기법들이 있는데 <a href="https://mobx.js.org/best/react-performance.html" target="_blank" rel="noopener">이 링크</a>를 참고하기 바란다.</p><h2 id="사족"><a href="#사족" class="headerlink" title="사족"></a>사족</h2><p>mobx-react 자체가 그리 많은 API를 가지고 있지 않다보니 생각보다 어렵지 않게 MobX와 React를 같이 시작해볼 수 있을 것이다. 하지만 이것을 잘 사용하고, 디자인하는 것은 그냥 시작하는 것보다 훨씬 더 고차원의 어려움이 따른다. MobX는 꽤 자유로운 라이브러리다보니 위처럼 최적화에 실패한 케이스라던지, 잘못된 디자인의 스토어를 짜게 되는 경우도 생긴다. 설상가상으로 레퍼런스도 아직은 많이 부족한 편이다.</p><p>그렇기에 내가 실제로 지금 진행하는 프로젝트에서 처음 MobX를 접하고 일주일 정도는 스토어의 전체적인 디자인을 수시로 갈아엎었다. 지금은 대충 안정적으로 사용하고 있지만, 언제 또 갈아 엎게 될지 모르겠어서 불안하다. MobX에서도 이를 어느정도 인지하고 있는지, <a href="https://mobx.js.org/best/store.html" target="_blank" rel="noopener">Best Practice 문서</a>를 제공하고 있다. 실제 프로젝트에서 반드시 참고하기를 권한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/mobx-with-react.jpg&quot;/&gt;&lt;p&gt;이전 글에서는 React를 배제한 채로 MobX만 사용했었고, Angular 혹은 jQuery와 연계해서 사용할 수도 있지만 MobX는 React랑 함께 사용되는 게 가장 일
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="React" scheme="https://hyunseob.github.io/categories/JavaScript/React/"/>
    
    
      <category term="React" scheme="https://hyunseob.github.io/tags/React/"/>
    
      <category term="MobX" scheme="https://hyunseob.github.io/tags/MobX/"/>
    
      <category term="Reactive" scheme="https://hyunseob.github.io/tags/Reactive/"/>
    
  </entry>
  
  <entry>
    <title>Hello, MobX</title>
    <link href="https://hyunseob.github.io/2017/10/07/hello-mobx/"/>
    <id>https://hyunseob.github.io/2017/10/07/hello-mobx/</id>
    <published>2017-10-07T02:18:36.000Z</published>
    <updated>2018-12-31T10:15:02.263Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/mobx.png"/><blockquote><p>Simple, scalable state management</p></blockquote><p><a href="https://github.com/mobxjs/mobx" target="_blank" rel="noopener">MobX</a>는 프론트엔드를 위한 어플리케이션 상태 관리 라이브러리다. 주로 React와 함꼐 사용되며, 상태 관리 라이브러리라는 특성 때문에 종종 Redux와 비교된다. Redux가 함수형 아이디어를 적용했다면 MobX는 반응형 아이디어를 적용했다. MobX에서는 반응형 프로그래밍 패러다임에서 필수적으로 언급되는 <em>옵저버(Observer)</em> 패턴을 적극적으로 사용한다. 다만, MobX에서는 오직 상태(데이터)만 관찰 가능하며, 상태가 변경되었을 때 반응한다. 또한 상태를 변경시키는 것도 직접 해야한다. 한마디로 말해, <em>MobX는 상태를 Observable하게 관리할 수 있도록 돕는 라이브러리</em>다.</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>간단한 예제로 시작하자.</p><iframe src="https://stackblitz.com/edit/hello-mobx-1?embed=1&file=index.ts" style="width:100%; height: 500px;"></iframe><p>위의 예제에서는 <code>observable</code>이라는 메소드를 통해 특정 객체를 Observable 객체로 만들었다. MobX에서 Observable 객체는, 그 객체의 프로퍼티 값이 변경되었을 때 그 객체를 관찰하고 있는 Observer에게 변경된 값을 통지한다. 이 경우에는 <code>autorun</code>을 통해서 관찰하는 것이고, 그 내부의 익명함수가 바로 Observer에 해당한다. 따라서 이 코드를 동작시키면, 1초마다 <code>person.age</code>가 1씩 증가하고, 이 값은 변경되었기 때문에 관찰하는 <code>autorun</code> 내부 코드에 의해서 자동으로 값이 업데이트된다. 이것을 MobX에서는 <em>Reaction</em>이라고 부른다.</p><h2 id="API-Overview"><a href="#API-Overview" class="headerlink" title="API Overview"></a>API Overview</h2><p>위에서 짤막하게 언급한 몇몇 API와 더불어서 MobX의 개념을 알아보기 위해 중요한 API만 간단히 둘러본다. 이 글에서는 우선 React는 배제하고 MobX에서 기본적으로 제공하는 API만 다룬다. 또한 개념 위주로 알아보고 디테일한 건 설명하지 않겠다.</p><h3 id="observable"><a href="#observable" class="headerlink" title="(@)observable"></a>(@)observable</h3><p><code>observable</code>은 넘겨받은 객체나 값 등을 Observable하게 만든다. 주로 객체를 넘기거나 클래스의 내부에서 데코레이터로 사용하게 된다.</p><iframe src="https://stackblitz.com/edit/hello-mobx-2?embed=1&file=index.ts" style="width:100%; height: 500px;"></iframe><p>위의 예제처럼 데코레이터 문법을 활용할 수 있다면 간단히 <code>@observable</code>을 프로퍼티에 선언해줌으로써 Observable한 값으로 만들 수 있다. 예제를 실행시키면 나이 값은 1초마다 업데이트되지만 이름 값은 업데이트되지 않는 것을 확인해 볼 수 있다.</p><p><code>observable</code>을 사용하게 되면 프로퍼티를 읽거나 쓰는 것이 모두 값을 관찰하는 것과 연관된다. 즉, <code>person.age</code>같은 코드로 값을 얻는 것은 옵저버를 등록하고, 실제로 그 값을 관찰(observe)하는 행위가 된다. 반대로 <code>person.age = 10</code>같은 코드로 값을 할당하는 것은 그 값을 관찰하는 모든 옵저버들에게 통지(notify)하는 행위가 된다.</p><p>이게 가능한 이유는 <code>observable</code>로 만든 객체가 실제로 프로퍼티가 아닌 JavaScript의 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="noopener">Getter</a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="noopener">Setter</a>)를 사용하기 때문이다.</p><h3 id="computed"><a href="#computed" class="headerlink" title="(@)computed"></a>(@)computed</h3><p><code>computed</code>는 <code>observable</code>값이 파생되는, 특별히 계산된 결과가 필요한 경우에 사용한다. MobX의 개발자인 <a href="https://github.com/mweststrate" target="_blank" rel="noopener">Michel Weststrate</a>는 MobX를 스프레드시트에 비유하는 걸 좋아하는데, Observable 값이 스프레드시트에 있는 데이터이고, Computed는 일종의 수식이라는 것이다. 다음 예제를 통해 살펴보자.</p><iframe src="https://stackblitz.com/edit/hello-mobx-3?embed=1&file=index.ts" style="width:100%; height: 500px;"></iframe><p><code>computed</code>는 이렇게 Observable 값에 대해서 적절한 계산이 필요할 때 사용하는 API다. Observable 값이 변경되면 그 값이 파생되어 Computed 값도 변경되고 이렇게 변경되는 값 역시 참조할 수 있다.</p><p>그런데 이 코드는 조금 이상해보인다. 결과에서도 볼 수 있듯이, <code>@computed</code>를 쓰든 쓰지않든 별 차이없이 값은 양 쪽 모두 변경되고 있다. 그럼 <code>computed</code>는 왜 존재하는 걸까?</p><p>이 <a href="https://github.com/mobxjs/mobx/issues/161#issuecomment-196744152" target="_blank" rel="noopener">이슈</a>를 참고하면 해답을 구할 수 있다. 간단히 옮기면, 동작에는 큰 차이가 없지만 성능상 차이는 존재한다는 것이다. 위의 예제에서 <code>getArea</code>를 여러 번, 극단적으로 100번 정도 호출하는 경우를 상상해보자. <code>width</code> 혹은 <code>height</code> 값이 변경되는 경우 <code>getArea</code>가 100번 호출되고 그 안의 계산식 역시 100번 반복되고 이는 당연히 낭비다. 반대로 <code>@computed</code>를 사용했다면 계산 결과 값은 캐싱된다. 따라서 100번의 반복은 없고 <code>@computed</code> 내부의 동작이 무거울 수록 성능상 이점이 더 커진다.</p><p>Computed는 기본적으로 JavaScript의 Getter에만 사용할 수 있으며, 따라서 추가 인자를 받을 수가 없다. 입력 인자가 <code>this</code>로 제한되는 순수함수라고 생각하면 이해하기 편하다. (물론 순수함수는 아니다.)</p><h3 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h3><p><code>autorun</code>은 Observable 값이 파생된다는 점은 <code>computed</code>와 같지만, 용도는 전혀 다르다. 아까 위에서 Reaction에 대해서 언급한 적이 있을 것이다. 기본적으로 파생된 값을 가지고 View를 업데이트 한다거나 로그를 찍는다거나 하는, 사이드 이펙트를 내포하고 있는 동작을 MobX에서는 Reaction이라고 부른다. <code>autorun</code>은 Reaction을 하는 방법 중 하나다. React와 같이 쓰는 경우에는 다른 API로 Reaction을 할 수 있으므로 <code>autorun</code>을 사용할 일이 별로 없지만, React 없이 MobX만 사용하는 경우에는, <code>autorun</code>이 필수적이다. 그래서 앞에 등장한 모든 예제에 <code>autorun</code>이 등장했던 것이다.</p><p><code>autorun</code>에 넘긴 익명 함수는 참조하고 있는 Observable 값이 변할때마다 반복해서 실행된다. 위에서도 언급했지만 Observer에 해당하는 것이다.</p><h3 id="action"><a href="#action" class="headerlink" title="(@)action"></a>(@)action</h3><p><code>action</code>은 Observable 값을 변경하는(Setter)에 사용하는 API다. 기본적으로 MobX에서는 Observable 값을 변경하는 메소드에는 <code>action</code>을 달아줄 것을 권장하지만 쓰지 않아도 정상적으로 동작한다. 위의 예제들에서도 <code>action</code> 없이 값을 계속해서 업데이트해도 동작에는 문제가 없지 않는가?</p><p>그렇다면 자연스럽게 <code>action</code>은 또 무슨 이유로 사용해야 되는지 의문이 들 것이다. <code>computed</code>와 마찬가지로, <code>action</code>을 사용하는 이유도 성능이다. 간단한 예제를 통해 알아보자.</p><iframe src="https://stackblitz.com/edit/hello-mobx-4?embed=1&file=index.ts" style="width:100%; height: 500px;"></iframe><p>위의 예제에서는 <code>incWidthAndHeight</code>라는, 내부의 <code>width</code> 값과 <code>height</code> 값을 동시에 1씩 올리는 메소드를 만들었다. 그리고 내부 동작은 완벽히 같지만 그 함수의 <code>action</code> 버전도 만들었다. 1초에 한 번씩 메소드를 실행시키면서 Reaction 함수(<code>autorun</code>으로 감싸진 함수)가 각각 몇 번씩 실행되는지 볼 수 있게끔 했다. Result 탭에서 결과를 보면 알겠지만, <code>getArea()</code>의 출력결과는 같은 동시에, 각각의 Reaction 함수의 실행 횟수는 2배의 차이가 나는 것을 확인할 수 있다.</p><p>이는 <code>action</code> 없이 Observable 값을 업데이트 했을 떄는, <code>width</code>와 <code>height</code> 각각의 값이 업데이트 되는 시점에서 Reaction 함수가 호출되지만, <code>action</code>을 사용했을 때는 그 두 값이 모두 업데이트 된 뒤에야, Reaction 함수가 호출된다는 차이에서 기인한다. 이렇게 Observable 값을 업데이트하는 동작을 묶어 일괄 실행하고 모든 동작이 끝났을 때 통지하는 것을 MobX에서는 트랜잭션(Transaction)이라고 부른다. 개념은 조금 다르지만 데이터베이스의 그 용어와 같다.</p><p>이처럼 MobX에서는 트랜잭션을 사용하는 것과 사용하지 않는 것은 큰 성능차이를 불러일으킬 수 있기 때문에, 항상 Observable 값을 변경할 때마다 <code>action</code>을 강제할 수도 있다. 바로 <code>useStrict</code> 모드를 사용하는 것이다. <code>useStrict</code> 모드를 사용하면 Observable 값 변화에 반드시 <code>action</code>을 사용해야 한다.</p><blockquote><p>UPDATE: MobX 버전 4 이상에서는 <code>useStrict</code> API가 사라지고 <code>configure</code> API로 대체되었다. <a href="https://mobx.js.org/refguide/api.html#-enforceactions-boolean" target="_blank" rel="noopener">링크</a> 참조.</p></blockquote><h2 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap up"></a>Wrap up</h2><p><img src="/images/mobx-flow.png" alt="MobX Flow Diagram"></p><p>위의 다이어그램은 위에서 설명한 API의 생명 주기를 요약해서 나타내고 있다. Action으로 인한 상태(State) 변경은 곧, 계산 결과(Computed)를 업데이트한다. 계산 결과가 업데이트되면 곧 이를 구독하는 반응(Reaction)을 야기한다.</p><p>겨우 1주일 정도 써봤지만, 나는 MobX에 대해서, Redux에 비해서도 진입장벽이 낮고 쉽게 코드를 짜고 금방 사용할 수 있는데 비해서 제대로 활용하려면 애매하고 헷갈리는 부분이 많아 쉽지가 않다는 것을 느꼈다. 단순히 Best Practice를 찾은 뒤에 Copy &amp; Paste하는 방식만으로는 이해도 잘 안되고 한계가 금방 온다. 따라서 처음부터 라이브러리에 기본 개념에 대해서 숙지하고 넘어가는 것이 좋다. 그래서 이 글을 쓰고 있는 것이기도 하고.</p><p>MobX는 얼핏 보기에 뭔가 성능상 문제가 생길 것 같아보인다. 원래부터 우려가 많았는지, MobX에서는 이를 React와 비교하면서 굉장히 최적화가 잘 되어있다고 변호한다.</p><blockquote><p>React와 MobX는 모두 어플리케이션 개발에 있어서 겪는 일반적인 문제에 대해 굉장히 최적화된 특별한 해법을 제시합니다. React는 가상 DOM을 이용해서 DOM 변화를 감소시키는 최적의 렌더링 메커니즘을 제공합니다. MobX는 엄격하게 필요할 때만 업데이트 되는 반응적인 가상 의존성 상태 그래프를 이용해서 어플리케이션 상태를 React 컴포넌트와 동기화하는 최적의 메커니즘을 제공합니다.</p></blockquote><p>진실은 나도 모르지만, 아무튼 상당한 자신감이 있는 모양이다. 실제로도 이미 <a href="https://github.com/mobxjs/awesome-mobx/blob/master/USERS.md" target="_blank" rel="noopener">사용하고 있는 프로젝트</a>도 꽤 있고 검증은 확실히 된 상황이다. 물론 Redux에 비해서는 조금 갈 길이 멀어보이지만 일단은 응원하는 입장이다. 현재까지 단점이라고는 로고가 상당히 못 생겼다는 것과 레퍼런스가 별로 없다는 것 외에는 딱히 없었다.</p><p>다음 글: <a href="/2017/10/18/mobx-with-react/">MobX with React</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/mobx.png&quot;/&gt;&lt;blockquote&gt;
&lt;p&gt;Simple, scalable state management&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mobxjs/mobx&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="React" scheme="https://hyunseob.github.io/categories/JavaScript/React/"/>
    
    
      <category term="MobX" scheme="https://hyunseob.github.io/tags/MobX/"/>
    
      <category term="Reactive" scheme="https://hyunseob.github.io/tags/Reactive/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: Enum</title>
    <link href="https://hyunseob.github.io/2017/07/18/typescript-enums/"/>
    <id>https://hyunseob.github.io/2017/07/18/typescript-enums/</id>
    <published>2017-07-18T13:31:07.000Z</published>
    <updated>2018-12-31T10:15:02.277Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2017/01/14/typescript-generic/">TypeScript: 제네릭(Generic)</a></p><p>JavaScript를 쓰면서 느끼게 되는 아쉬운 점 하나는, Enum(Enumeration, 열거형)의 부재다. 사실 JavaScript 같은 동적 타입 언어에서 Enum이 없는 게 당연하지만, 유한하면서도 여러가지의 상태를 가질 수 있는 변수를 정의하고 싶은 경우, <code>boolean</code>으로는 해결할 수가 없기 때문에 종종 Enum의 필요성을 느끼기도 한다.</p><h2 id="기본적인-사용법"><a href="#기본적인-사용법" class="headerlink" title="기본적인 사용법"></a>기본적인 사용법</h2><p>TypeScript에서는 <code>enum</code>이라는 키워드로 Enum을 사용하는 것이 가능하다. 문법도 간단하다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  GREEN,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>선언을 한 뒤에,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setColor</span>(<span class="params">color: Color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">setColor(Color.RED);</span><br></pre></td></tr></table></figure><p>이렇게 사용하면 된다. Enum은 하나의 타입이기도 하지만, JavaScript 런타임에서도 사용되는 하나의 변수로 볼 수도 있다. JavaScript 런타임에서도 사용된다는 말은, 클래스처럼 컴파일 결과물이 존재한다는 것이다. 예를 들어, 위에서 선언한 <code>Color</code> 타입은 아래와 같이 컴파일 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Color;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Color</span>) </span>&#123;</span><br><span class="line">    Color[Color[<span class="string">"RED"</span>] = <span class="number">0</span>] = <span class="string">"RED"</span>;</span><br><span class="line">    Color[Color[<span class="string">"GREEN"</span>] = <span class="number">1</span>] = <span class="string">"GREEN"</span>;</span><br><span class="line">    Color[Color[<span class="string">"BLUE"</span>] = <span class="number">2</span>] = <span class="string">"BLUE"</span>;</span><br><span class="line">&#125;)(Color || (Color = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>컴파일 결과물이라 그런지 가독성이 나쁘다. 결과적으로 위의 코드애서 <code>Color</code>는 다음과 같은 객체가 된다고 보면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Color = &#123;</span><br><span class="line">  RED: <span class="number">0</span>,</span><br><span class="line">  GREEN: <span class="number">1</span>,</span><br><span class="line">  BLUE: <span class="number">2</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="string">'RED'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'GREEN'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'BLUE'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>enum</code> 키워드는 기본적으로 리버스 매핑(reverse mapping)을 지원한다. 리버스 매핑이란 키로 값을 얻을 수 있을 뿐만 아니라, 값으로도 키를 얻을 수 있는 방식을 말한다. 그렇기 때문에 위와 같은 형태로 객체가 생성된 것이다.</p><h2 id="선언과-값-초기화"><a href="#선언과-값-초기화" class="headerlink" title="선언과 값 초기화"></a>선언과 값 초기화</h2><p>앞에서 다룬대로, <code>enum</code>으로 만들어진 변수에는 내부적으로 값이 할당된다. 별도의 명시가 없다면 값은 0부터 시작해서 1씩 증가하는 형태로 할당된다. C언어에서 보았던 Enum과 비슷한 형태다. 반대로, 별도의 명시를 해준다면 원하는 값으로 초기화 할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED = <span class="number">10</span>,</span><br><span class="line">  GREEN = <span class="number">20</span>,</span><br><span class="line">  BLUE = RED + GREEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단한 연산자를 사용한 표현식으로도 초기화할 수 있다. 이 때 특이한 점은, 초기화할 용도로 사용된 표현식은 런타임이 아닌 컴파일 타임에 평가된다는 것이다. 위의 예제에서 <code>BLUE</code>에는 30이라는 값이 할당될 텐데, 이것이 컴파일 타임에 정해진다는 것이다. 물론 <code>enum</code> 내부에서 알 수 없는 외부 변수를 사용하는 경우에는 그냥 온전히 표현식이 유지된다.</p><p>또한, <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener">TypeScript Handbook</a>에도 나와있는 것처럼 Bitwise 연산자를 이용해서 일종의 플래그처럼 활용할 수도 있다. 하지만, 대개의 경우 숫자 값은 의미가 없으므로, DB에 값을 삽입할 때를 위해서 의미가 있는 문자열 값으로 초기화하고 싶은 경우도 있다. 그럴 때는 아래처럼 그냥 문자열 값을 선언해주면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED = <span class="string">'red'</span>,</span><br><span class="line">  GREEN = <span class="string">'green'</span>,</span><br><span class="line">  BLUE = <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실, 이 기능은 <a href="https://github.com/Microsoft/TypeScript/wiki/What&#39;s-new-in-TypeScript#string-enums" target="_blank" rel="noopener">TypeScript 2.4에서 새로 추가된 기능</a>으로 원래는 다음과 같이 조금 찜찜하게 초기화해야만 했다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 2.3 이하</span></span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED = &lt;<span class="built_in">any</span>&gt; <span class="string">'red'</span>,</span><br><span class="line">  GREEN = &lt;<span class="built_in">any</span>&gt; <span class="string">'green'</span>,</span><br><span class="line">  BLUE = &lt;<span class="built_in">any</span>&gt; <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;any&gt;</code>가 들어간 걸 빼면 큰 차이는 없어보이지만, 두 가지 방법에는 큰 차이점이 있다. 바로 리버스 매핑의 유무. 2.4 버전 이상에서 문자열로 Enum 값을 초기화 하는 경우, 리버스 먜핑을 지원하지 않는다. 즉,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Color[Color.RED]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>이런 결과가 나타난다는 것이다.</p><p>공식적인 이유는 찾지 못했는데, 아마 리버스 매핑을 지원한다면 Key와 Value가 충돌하는 문제를 회피하기 어려워서가 아닐까 한다. 2.3 버전에서는 리버스 매핑을 지원하는 것이 아니라, 어디까지나 문제를 우회해서 선언한 것이므로 충돌 문제는 개발자가 스스로 피해야 한다.</p><h2 id="const-enum"><a href="#const-enum" class="headerlink" title="const enum"></a><code>const enum</code></h2><p><code>enum</code> 키워드는 앞에 <code>const</code>와 함께 사용할 수도 있다. <code>const</code>와 함께 사용할 경우, Enum은 컴파일 결과물을 가지지 않는다. 예를 들면,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED = <span class="string">'red'</span>,</span><br><span class="line">  GREEN = <span class="string">'green'</span>,</span><br><span class="line">  BLUE = <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> red = Color.RED;</span><br></pre></td></tr></table></figure><p>이러한 코드가 있다고 할 때 컴파일 결과는,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red = <span class="string">"red"</span> <span class="comment">/* RED */</span>;</span><br></pre></td></tr></table></figure><p>이렇게 나타난다는 것이다. 즉, 그냥 Enum에서 정의한 변수들을 활용하는 경우 기존에 정의했던 값을 사용하기 때문에 문제가 없지만, 런타임에서 <code>Color</code>에 접근해 뭔가 할 수는 없게 된다. 이로 인해서 기존의 <code>enum</code>과는 달리 몇 가지 중요한 차이점이 나타나게 된다.</p><p>원래 <code>enum</code>으로 정의한 모든 변수들은 기본적으로 읽기 전용이지만, 간단한 트릭을 이용하면 런타임에서 쉽게 값을 변경할 수 있었다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Color <span class="keyword">as</span> <span class="built_in">any</span>).RED = <span class="string">'yellow'</span>;</span><br></pre></td></tr></table></figure><p>물론, 실제로 이렇게 위험한 코드를 짜는 경우는 거의 없겠지만. 아무튼 <code>const enum</code>을 사용한다면 이 문제를 근본적으로 회피할 수 있다. 애초에 런타임에 생기는 객체가 없기 때문에 수정할 대상 자체가 사라지는 것이다. 물론 이 경우에는 위 코드는 컴파일도 불가능하다. 이것이 첫 번째 차이점이다.</p><p>두 번째로, 리버스 매핑을 지원하지 않는다. 마찬가지로 리버스 매핑 문법 자체가 컴파일 에러가 난다. 애초에 리버스 매핑이 런타임에 존재하는 객체를 이용하는 것이므로 안되는 것이 당연한 것이지만.</p><p>세 번째로, 컴파일 타임에 평가할 수 없는 표현식으로 값을 할당할 수도 없게 된다. 이것을 간단히 예제로 설명하면,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> green = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED = <span class="number">10</span>,</span><br><span class="line">  BLUE = RED * <span class="number">2</span>,</span><br><span class="line">  GREEN = green <span class="comment">// ERROR: [ts] In 'const' enum declarations member initializer must be constant expression.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서는 <code>GREEN</code>을 선언할 때 컴파일 에러가 난다. <code>enum</code> 키워드의 바깥에서 정의한 변수가 표현식으로 사용되면 컴파일 에러가 나는 것이다. 물론, <code>RED</code>처럼 <code>enum</code> 키워드 내부에서 선언한 변수들은 잘 평가된다. 이 특징도 어찌보면 당연한 건데, 컴파일 타임에 평가하지 못한 표현식은 런타임에 평가할 수 밖에 없고, 그렇게 되면 항상 같은 값임을 보장할 수가 없기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2017/01/14/typescript-generic/&quot;&gt;TypeScript: 제네릭(Generic)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JavaScript를 쓰면서 느
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>AWS Lambda: Apex로 관리하기</title>
    <link href="https://hyunseob.github.io/2017/07/09/aws-lambda-with-apex/"/>
    <id>https://hyunseob.github.io/2017/07/09/aws-lambda-with-apex/</id>
    <published>2017-07-09T13:10:30.000Z</published>
    <updated>2018-12-31T10:15:02.254Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/aws-lambda-with-apex.png"/><p>이전 글: <a href="/2017/05/27/aws-lambda-easy-start/">AWS Lambda: 시작하기</a></p><p>Lambda를 처음 쓰기 시작했다면 코드를 웹 콘솔에서 직접 수정하거나, ZIP 파일을 통해 배포하고 관리해야하는 것이 불편하게 느껴질 수 있을 것이다. AWS SDK가 제공되고 있으니 이런 작업들을 자동화하는 도구를 직접 구현할 수도 있겠지만, 이미 잘 구현되어 사용할 수 있는 도구들이 있다. <a href="http://apex.run/" target="_blank" rel="noopener">Apex</a>와 <a href="https://serverless.com/" target="_blank" rel="noopener">Serverless Framework</a>가 바로 그것이다.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p>이번 글에서는 그 중 Apex에 대해서 다룬다. 사실 사용자 수는 Serverless Framework쪽이 더 많은 것으로 보이지만 필자는 아직 사용해 본 적이 없어서 비교 평가가 어렵다. 대신 이 <a href="https://www.quora.com/What-are-the-differences-between-the-various-AWS-serverless-frameworks-and-tools" target="_blank" rel="noopener">질답</a>을 참조하시길 바란다.</p><h2 id="시작하기"><a href="#시작하기" class="headerlink" title="시작하기"></a>시작하기</h2><p>먼저, <a href="https://github.com/aws/aws-cli" target="_blank" rel="noopener">AWS CLI</a>가 있는지 확인해보고, 없다면 설치하자.</p><p>Apex는 Go로 구현되어있으며 <code>curl</code>을 통해 내려받고 설치할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/apex/apex/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>사용하기 위해서는 당연히 AWS Credential이 필요하다. Credential은 여러가지 방법으로 전달할 수 있는데 여기서는 <code>~/.aws</code> 경로를 이용할 것이다. AWS CLI를 이용해서 새로운 프로필을 만든다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ aws configure --profile [name]</span><br><span class="line">AWS Access Key ID [None]: [your-access-key-id]</span><br><span class="line">AWS Secret Access Key [None]: [your-secret-access-key]</span><br><span class="line">Default region name [None]: [your-region-name]</span><br><span class="line">Default output format [None]: json</span><br></pre></td></tr></table></figure><p>참고로, Access Key ID와 Secret Access Key는 AWS IAM Console에서 얻을 수 있다. 만약 유저가 없다면 새로 등록하자. Apex에서 필요로 하는 IAM Policy는 <a href="http://apex.run/#minimum-iam-policy" target="_blank" rel="noopener">여기</a>를 참조하면 된다.</p><p>Credential 설정까지 마쳤으면 이제 Apex를 사용할 프로젝트의 디렉토리로 이동하자. 그 뒤에, <code>AWS_PROFILE</code> 환경 변수를 지정하고, <code>apex init</code>을 사용해서 프로젝트를 시작할 수 있다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> AWS_PROFILE=[name]</span><br><span class="line">$ apex init</span><br></pre></td></tr></table></figure><p>프로젝트 명까지 입력하면 이제 Apex를 사용해 디플로이 및 테스트를 할 환경이 갖춰진 것이다. 시험삼아 <code>apex deploy</code>를 입력하면 함수가 배포되는 것을 확인할 수 있다.</p><h2 id="대략적인-사용법"><a href="#대략적인-사용법" class="headerlink" title="대략적인 사용법"></a>대략적인 사용법</h2><p>Apex로 생성한 프로젝트의 대략적인 골격은 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─ functions</span><br><span class="line">│   ├─ function-a</span><br><span class="line">│   │   └─ index.js</span><br><span class="line">│   ├─ function-b</span><br><span class="line">│   │   └─ index.js</span><br><span class="line">│   └─ ...</span><br><span class="line">└─ project.json</span><br></pre></td></tr></table></figure><p><code>apex init</code>으로 <code>project.json</code> 파일과 <code>functions</code> 디렉토리가 생겼다. <code>project.json</code>은 프로젝트의 여러가지 설정 및 변수가 담기는 파일이며, <code>functions</code>는 실제 배포될 소스코드 파일이 위치할 디렉토리다.</p><p><code>functions</code> 디렉토리 아래에 위치하는 여러 디렉토리는 실제 배포되는 각각의 Lambda 함수다. 말하자면, 위의 디렉토리 구조에서 <code>function-a</code>와 <code>function-b</code>는 각각 하나의 함수이고, 그 아래에 위치한 <code>index.js</code>가 반영될 소스파일이다.</p><p>Apex는 몇 가지 유용한 명령어를 제공하는데, 실제로 프로젝트를 운영하면서 자주 사용하게 될 명령어는 많지 않다. 다음은 자주 사용하는 명령어에 대한 대략적인 설명이다.</p><ul><li><strong>apex build [function name]</strong>: Lambda에서 사용할 수 있는 ZIP파일을 빌드한다.</li><li><strong>apex deploy ?[function name]</strong>: 말 그대로 Lambda에 코드를 디플로이하는 명령이며, 내부적으로 <code>apex build</code>를 실행한 결과물을 디플로이한다.</li><li><strong>apex invoke [function name]</strong>: Lambda function을 실행하는 명령어다. 이 명령어는 로컬이 아니라 실제 Lambda에서 실행되므로 주의.</li><li><strong>apex logs [function name]</strong>: Lambda의 실행으로 찍힌 로그를 출력하는 명령어다. <code>console.log</code> 등으로 찍은 로그도 볼 수 있다.</li></ul><p>사실 <code>apex build</code> 빼고 나머지 세 가지의 명령어를 주로 사용하게 된다. 아까 <code>apex deploy</code>를 했었다면 이미 <code>hello</code>라는 이름의 함수가 배포되어 있을테니 <code>apex invoke</code> 명령어를 사용해보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apex invoke hello</span><br><span class="line">&#123;<span class="string">"hello"</span>:<span class="string">"world"</span>&#125;</span><br></pre></td></tr></table></figure><p>이번엔 <code>apex logs</code>를 사용해서 어떤 로그가 찍히는 지 확인해보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ apex logs hello</span><br><span class="line">/aws/lambda/apex-typescript-example_hello 2017-07-09T08:30:03.563Z      undefined       starting <span class="keyword">function</span></span><br><span class="line">/aws/lambda/apex-typescript-example_hello START RequestId: cdfd7251-6480-11e7-a35e-81de7320e51b Version: 1</span><br><span class="line">/aws/lambda/apex-typescript-example_hello 2017-07-09T08:30:03.565Z      cdfd7251-6480-11e7-a35e-81de7320e51b    processing event: &#123;&#125;</span><br><span class="line">/aws/lambda/apex-typescript-example_hello END RequestId: cdfd7251-6480-11e7-a35e-81de7320e51b</span><br><span class="line">/aws/lambda/apex-typescript-example_hello REPORT RequestId: cdfd7251-6480-11e7-a35e-81de7320e51b        Duration: 2.02 ms       Billed Duration: 100 ms        Memory Size: 128 MB      Max Memory Used: 18 MB</span><br></pre></td></tr></table></figure><p>아마도 크게 위와 다르지 않은 결과를 얻었을 것이다. 실제로 위의 명령어들만 잘 사용해도 기본적인 운영은 할 수 있다.</p><h2 id="프로젝트-구조-문제"><a href="#프로젝트-구조-문제" class="headerlink" title="프로젝트 구조 문제"></a>프로젝트 구조 문제</h2><p>실제 Node.js 프로젝트에서 외부 라이브러리 없이 단일 파일만으로 원하는 비즈니스 로직을 구성할 수 있는 가능성은 실질적으로 없다. 따라서 필연적으로 npm 패키지를 설치하고 참조하게 된다. 이 때, <code>package.json</code>파일과 <code>node_modules</code> 디렉토리는 대체 어디에 위치해야 하는가라는 고민이 생긴다. 뿐만 아니라, 여러 함수에서 공용으로 사용하는 소스코드가 있고, DRY 원칙을 깨고 싶지 않다면 이 소스코드는 어느 함수의 아래에 위치해야 하는가? 아까 잠깐 보았던 프로젝트의 골격을 다시 한 번 보자.</p><figure class="highlight plain"><figcaption><span>functions</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">│   ├─ function-a</span><br><span class="line">│   │   └─ index.js</span><br><span class="line">│   ├─ function-b</span><br><span class="line">│   │   └─ index.js</span><br><span class="line">│   └─ ...</span><br><span class="line">└─ project.json</span><br></pre></td></tr></table></figure><p>이상적인 구조는 공용 코드 및 <code>package.json</code>과 <code>node_modules</code>가 특정 함수 아래가 아니라 최상단 경로에 위치하는 것이다. 하지만 <code>node_modules</code>는 실제 배포될 소스코드에 포함되어야 하기 때문에 <code>node_modules</code>는 당연히 각각의 함수, 말하자면 <code>function-a</code> 아래에 위치할 수 밖에 없다고 생각했다.</p><p>그런데 문득, 공용 소스코드와 라이브러리, 그리고 거기에 의존성을 가지는 여러 개의 엔트리 파일이라는 구조. 이거 webpack에서 이미 많이 해본 것 아닌가? 하는 생각이 들었다. webpack을 사용하기로 마음을 먹고, “이 신박한 생각을 아무도 하지 못했겠지! 혹시 난 천재..?” 라는 생각을 하면서 찾아 본 결과, Apex에서 <a href="https://github.com/apex/apex/tree/master/_examples/babel-webpack2" target="_blank" rel="noopener">예제</a>까지 제공하는 것을 보고 자괴감에 빠졌다(…)</p><p>각설하고, Apex로 제대로 Lambda를 관리하기로 마음먹었다면 번들링은 선택이 아닌 필수라고 생각한다. 따라서 여기에서는 webpack을 이용해 프로젝트를 구성해 볼 것이다. babel을 이용한 예제는 위에 링크했으므로 여기에서는 TypeScript과 함께 번들링하는 예제를 다루겠다. (사실 거의 비슷하다.)</p><h2 id="프로젝트-구조-잡기"><a href="#프로젝트-구조-잡기" class="headerlink" title="프로젝트 구조 잡기"></a>프로젝트 구조 잡기</h2><p>번들링을 하기로 결정했으므로 이제 개발하는 원본 소스코드와 배포되는 소스코드가 달라지게 될 것이다. 따라서 프로젝트 구조에 약간의 변경을 주어야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├─ functions</span><br><span class="line">│   ├─ hello</span><br><span class="line">│   │  ├─ src</span><br><span class="line">│   │  │  └─ index.ts</span><br><span class="line">│   │  └─ lib</span><br><span class="line">│   └─ ...</span><br><span class="line">└─ project.json</span><br></pre></td></tr></table></figure><p>각각의 함수 아래에 <code>src</code>라는 이름의 디렉토리를 추가했고. 원본 파일을 새로 만든 디렉토리 아래에 위치시킨다. 기왕하는 김에 TypeScript 파일으로 변경해준다. 이제 webpack을 통해 이 파일을 빌드하고 그 결과물은 <code>lib</code> 디렉토리 아래에 들어갈 것이다. 다만 여기서 <code>lib</code> 디렉토리를 미리 만들어 줄 필요는 없다. webpack이 자동으로 만들어 줄 것이다.</p><p>함수 디렉토리 아래에 <code>index.js</code> 파일이 사라지면 Apex는 이를 파일이 없는 함수로 인식해 빌드할 때 오류를 뱉어낸다. 현재 디렉토리가 변경되었으므로 오류가 발생할 것이다. 따라서 <code>function.json</code> 파일을 함수 바로 아래에 추가한다.</p><script src="https://gist.github.com/HyunSeob/7e31907e30967a78ad2caa37af0b3152.js"></script><p>Apex는 몇 가지 Task에 대한 Hook을 제공한다. 지원하는 Task 중에는 빌드 전에 실행되는 Hook도 있는데, <code>apex deploy</code>를 실행하면 알아서 빌드가 진행되므로 디플로이 시 번들링을 자동화 할 수 있다. Hook은 <code>project.json</code>을 수정하면 되는데, 아래와 같이 설정한다.</p><script src="https://gist.github.com/HyunSeob/1491edadcd44338d10c2586e770178f1.js"></script><p><code>&quot;hooks&quot;</code>아래에 들어간 것들이 바로 Hook 설정이다. <code>&quot;build&quot;</code>는 ZIP 파일 생성 전에 실행되는 Hook이며, <code>&quot;clean&quot;</code>은 디플로이가 모두 끝난 시점에 실행되는 Hook이다. 보면 Hook이 실행되는 경로가 함수 디렉토리의 바로 아래라는 것을 짐작할 수 있을 것이다. <code>&quot;handler&quot;</code>에 대해서는 조금 아래에서 설명한다.</p><p>아직 <code>webpack.config.js</code> 파일을 만들지 않았다. 아래처럼 파일을 만들자. 참고로 여기서 사용될 npm 모듈들(webpack 및 loader들)은 별도로 설치하라고 언급하지 않을 것이다.</p><script src="https://gist.github.com/HyunSeob/f24056fdf2f15ed938d03d3e8cb14310.js"></script><p>중요한 부분만 설명하겠다. 일반적으로 webpack을 사용하는 이유와는 달리 Node.js에서 돌아갈 JS파일을 빌드해야하므로, Target을 <code>&quot;node&quot;</code>로 잡아준다. 그리고 생소한 <code>&quot;commonjs2&quot;</code>가 눈에 띄는데, 이는 Node.js에서 사용하는 <code>module.exports</code>를 포함하겠다는 것이다. 또한, webpack이 실행되는 위치가 각각의 함수 디렉토리의 아래 경로이므로 이 파일의 위치가 아닌 프로세스가 실행된 위치를 리턴하는 <code>process.cwd()</code>를 사용한다.</p><p>AWS SDK를 사용하는 경우, npm의 aws-sdk 모듈을 설치하지 않아도 Lambda에서는 기본적으로 런타임에 포함되어있으므로 <code>externals</code>에 적어주면 된다.</p><p>Uglify는 하면 좋고, 굳이 하지 않아도 된다. 필자는 브라우저에서 실행되는 파일이 아니므로 하지 않는다.</p><script src="https://gist.github.com/HyunSeob/4f6e62680a214f102398bb32ad695584.js"></script><p>이제 <code>tsconfig.json</code> 파일을 추가하고, <code>tslint.json</code> 파일도 적당한 룰을 붙여 추가하자.</p><p>완성된 프로젝트의 구조는 아래와 같아야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├─ functions</span><br><span class="line">│   ├─ hello</span><br><span class="line">│   │  ├─ src</span><br><span class="line">│   │  │  └─ index.ts</span><br><span class="line">│   │  └─ function.json</span><br><span class="line">│   └─ ...</span><br><span class="line">├─ node_modules</span><br><span class="line">├─ project.json</span><br><span class="line">├─ webpack.config.js</span><br><span class="line">├─ tsconfig.json</span><br><span class="line">├─ tslint.json</span><br><span class="line">└─ package.json</span><br></pre></td></tr></table></figure><p>이제 아까 확장자만 바꾸었던 TypeScript 파일을 수정해 줄 차례다.</p><script src="https://gist.github.com/HyunSeob/a4be501b5c279a4bd0745bf76a96f20e.js"></script><p>원래 생성했었던 <code>index.js</code> 파일과 비교해보자. 함수를 내보내는 방식이 <code>default</code>를 이용하는 것으로 바뀐 것을 확인할 수 있을 것이다. 이게 바로 위에 <code>project.json</code> 파일에서 <code>&quot;handler&quot;</code>를 <code>&quot;lib.default&quot;</code>라고 쓴 것에 해당한다. <code>lib</code> 디렉토리의 <code>index.js</code> 파일에서 내보내는 <code>default</code> 함수를 바라보게 한 것이다.</p><p>마침내 빌드가 잘 되는지 테스트를 해볼 시간이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apex build hello &gt; hello.zip</span><br></pre></td></tr></table></figure><p><code>hello.zip</code> 파일을 압축 풀고, <code>lib</code> 디렉토리의 <code>index.js</code> 파일을 확인해보면 빌드가 된 결과물을 확인할 수 있을 것이다. 잘 빌드가 되었다면 디플로이도 해보고 <code>apex invoke</code> 명령어를 이용해 테스트도 해보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apex deploy hello</span><br><span class="line">$ apex invoke hello</span><br></pre></td></tr></table></figure><p>여기까지 잘 끝냈다면 npm 모듈을 사용하기는 정말 쉽다. 시험삼아 저번 글에서도 사용했던 lodash를 설치하고 사용해보자. lodash를 설치한 뒤 <code>index.ts</code> 파일을 아래와 같이 수정한다.</p><script src="https://gist.github.com/HyunSeob/6d38a3c1e0053f373504ce75e8c4da55.js"></script><p>그리고 바로 다시 디플로이와 실행을 해보자. <code>rand</code>라는 프로퍼티에 랜덤하게 정수가 출력되면 성공이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이 일련의 과정은 사실 내가 회사에서 업무를 진행하면서 했던 작업들의 일부다. 진행하면서, webpack 같은 번들러없이 Apex로 Lambda를 관리하기는 좀 어렵겠다는 인상을 강하게 받았다. 하지만 한 번만 고생(?)해서 일단 구조를 잡아주고 나면, 이후 개발은 편하게 진행할 수 있다. 이 글에서는 다루지 않았지만, 개발하다보면 으레 필요해지는 멀티 스테이지도 필수라고 할 수 있는데, 이것을 포함해서 <a href="https://github.com/HyunSeob/apex-typescript-boilerplate" target="_blank" rel="noopener">apex-typescript-boilerplate</a>라는 이름의 저장소에 올라가 있으니 참고하시기 바란다.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Node.js 기준이며, Python은 또 다른 도구들이 있다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/aws-lambda-with-apex.png&quot;/&gt;&lt;p&gt;이전 글: &lt;a href=&quot;/2017/05/27/aws-lambda-easy-start/&quot;&gt;AWS Lambda: 시작하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lambda를 처음 쓰기
      
    
    </summary>
    
      <category term="Server" scheme="https://hyunseob.github.io/categories/Server/"/>
    
      <category term="AWS" scheme="https://hyunseob.github.io/categories/Server/AWS/"/>
    
    
      <category term="Node.js" scheme="https://hyunseob.github.io/tags/Node-js/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
      <category term="AWS" scheme="https://hyunseob.github.io/tags/AWS/"/>
    
      <category term="Apex" scheme="https://hyunseob.github.io/tags/Apex/"/>
    
      <category term="webpack" scheme="https://hyunseob.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>AWS Lambda: 가볍게 시작하기</title>
    <link href="https://hyunseob.github.io/2017/05/27/aws-lambda-easy-start/"/>
    <id>https://hyunseob.github.io/2017/05/27/aws-lambda-easy-start/</id>
    <published>2017-05-27T05:26:37.000Z</published>
    <updated>2018-12-31T10:15:02.253Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/aws-lambda-easy-start/logo.jpg"/><p>최근에 AWS Lambda를 좀 써볼만한 일이 생겨서 이래저래 삽질을 했다. 막상 시작하려니 내가 잘 모르는 분야라 부담스럽기도 해서 시도를 주저하고 있었는데, 해보고 나니 생각보다 어려운 편은 아니었다. 그 삽질의 결과를 공유해보고자 글을 남긴다.</p><h2 id="준비물"><a href="#준비물" class="headerlink" title="준비물"></a>준비물</h2><p>AWS Lambda를 쓰기 위해서는 당연히 AWS 계정이 필요하다. 또한, 모든 예제는 Node.js로 진행되기 때문에 Node.js에 대한 기본적인 이해가 필요하다.</p><h2 id="새로운-Lambda-함수-만들기"><a href="#새로운-Lambda-함수-만들기" class="headerlink" title="새로운 Lambda 함수 만들기"></a>새로운 Lambda 함수 만들기</h2><p>아래와 같은 절차를 밟아 새로운 Lambda 함수를 만들어 볼 수 있다.</p><p>1) AWS Lambda 콘솔에 들어간다.</p><p><img src="/images/aws-lambda-easy-start/lambda-console.png" alt="Lambda Console Screenshot"></p><p>2) <strong>Get Started Now</strong> 버튼을 클릭해 새로운 Lambda 함수를 만든다. 이미 Lambda 함수가 있는 경우 <strong>Create a Lambda function</strong>이라는 버튼을 통해서 만들 수 있다.</p><p><img src="/images/aws-lambda-easy-start/lambda-blueprint.png" alt="Lambda Blueprint Screenshot"></p><p>3) <strong>Blueprint</strong>는 미리 준비된 Lambda 함수의 환경 같은 것인데, 여기서는 <strong>Blank Function</strong>을 선택한다. 이 글에서 다루고 있는 예제는 그리 복잡하지 않으므로 Blank Function으로 충분하다.</p><p><img src="/images/aws-lambda-easy-start/lambda-trigger.png" alt="Lambda Trigger Screenshot"></p><p>4) <strong>Trigger</strong>는 아래에서 다시 다룰 것이다. 여기서는 선택하지 않은 채로 <strong>Next</strong> 버튼을 눌러 넘어간다.</p><p><img src="/images/aws-lambda-easy-start/configure-function.png" alt="Configure Function Screenshot"></p><p>5) <strong>Configure Function &gt; Name</strong>에 적절한 이름을 입력한다.</p><p><img src="/images/aws-lambda-easy-start/lambda-role.png" alt="Lambda Role Screenshot"></p><p>6) 아래로 내려 <strong>Lambda function handler and role &gt; Role</strong>에서 <strong>Create new role from template(s)</strong>를 선택한 뒤, <strong>Role name</strong>에 적절한 이름을 입력하고 <strong>Next</strong> 버튼을 눌러 넘어간다.</p><p>7) 마지막으로 <strong>Create Function</strong> 버튼을 눌러 함수를 만든다.</p><p>이렇게 해서 만들어진 Lambda 함수는 <strong>Test</strong> 버튼을 클릭하여 테스트 할 수 있다.</p><p>이제 입력으로 숫자를 하나 받아 그 숫자를 두 배로 곱해주는 함수를 만들어 보자. 코드는 아래와 같다.</p><script src="https://gist.github.com/HyunSeob/e2c31f6b018d4880bb396e31ef9d25f8.js"></script><p>함수 내부를 들여다보면 우리가 일반적으로 사용하는 함수와는 조금 다른 방식으로 함수를 사용하는 것을 볼 수 있다. 먼저, 입력 데이터는 함수의 매개변수가 아니라 <code>event</code>라는 매개변수의 프로퍼티로 전달된다. 즉, <code>event</code>의 프로퍼티가 실질적으로 기존 함수들의 매개변수 역할을 대신하는 것이다. 마찬가지로, <code>return</code>문이 아니라 매개변수로 넘어온 <code>callback</code>이라는 함수를 실행시킴으로서 결과 값을 출력한다. 물론 <code>return</code>문도 여전히 사용할 수 있지만 함수를 중간에 중단시키는 것 이외의 다른 역할은 하지 않는다.</p><p><code>context</code>는 Lambda 함수의 시스템에 관련된 정보를 속성으로 담고 있는 변수다. <code>context</code>의 프로퍼티 리스트는 <a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/nodejs-prog-model-context.html" target="_blank" rel="noopener">이 링크</a>에서 확인할 수 있다. 이 글에서는 <code>context</code> 변수를 다루지 않는다.</p><p>이제 만들어진 함수를 테스트할 차례다. <strong>Actions &gt; Configure test event</strong>를 누르면 <code>event</code>의 프로퍼티로 전달될 값을 편집할 수 있다.</p><p>여기서는 <code>event.num</code>이라는 값을 사용하므로 key로 <code>&quot;num&quot;</code>이라는 값을 가지는 JSON을 입력한뒤 <strong>Save and test</strong> 버튼을 누른다.</p><p>그럼 <code>Execution result: Succeeded</code> 라는 말과 함께 결과 값을 확인할 수 있을 것이다.</p><h2 id="API-Gateway-연동하기"><a href="#API-Gateway-연동하기" class="headerlink" title="API Gateway 연동하기"></a>API Gateway 연동하기</h2><p>이렇게 해서 만든 Lambda 함수는 현재로서는 별 가치가 없다. 내가 Test 버튼을 누를 때에만 동작하는 함수기 때문이다. <strong>Trigger</strong>를 지정해줘야만 제대로 된 Lambda 함수로서 기능할 수 있다. 설정할 수 있는 Trigger로는 다양한 종류가 있지만 가장 흔히 사용되는 것이 API Gateway 이므로 API Gateway와 연동하는 법을 소개한다.</p><p>먼저, 아래의 절차를 따라 API를 만들 수 있다.</p><p><img src="/images/aws-lambda-easy-start/api-gateway-console.png" alt="API Gateway Console Screenshot"></p><p>1) AWS API Gateway 콘솔로 진입해 <strong>Get Started</strong> 버튼을 누른다.</p><p><img src="/images/aws-lambda-easy-start/api-gateway-create.png" alt="API Gateway Create Screenshot"></p><p>2) <strong>Create new API &gt; New API</strong>를 선택하고, <strong>API name</strong>에 적당한 이름을 넣고 <strong>Create API</strong> 버튼을 눌러 API를 만든다.</p><p>API는 만들어졌지만 아직 Lambda와 연동되지는 않았다. Lambda와 연동하는 부분은 각 API의 Method이므로 새로운 메소드를 만들어 Lambda와 연동해야한다.</p><p><img src="/images/aws-lambda-easy-start/api-gateway-new-method.png" alt="API Gateway New Method Screenshot"></p><p>1) <strong>Actions &gt; Create method</strong> 버튼을 클릭하고 나온 Select Box에서 <strong>POST</strong> 메소드를 선택하고 체크를 눌러 메소드를 새로 만든다.</p><p><img src="/images/aws-lambda-easy-start/api-gateway-method-setup.png" alt="API Gateway Method Setup Screenshot"></p><p>2) <strong>Intergration type &gt; Lambda Function</strong>을 선택하고 <strong>Lambda Region</strong>을 아까 Lambda 함수를 만들었던 Region을 선택한다.</p><p>3) <strong>Lambda Function</strong>이라는 새로운 입력칸이 나오는데, 여기에서 아까 만들었던 Lambda 함수 이름을 입력한 뒤, <strong>Save</strong> 버튼을 누른다.</p><p>4) 그러면 API Gateway에 Lambda 함수를 호출할 수 있는 권한을 준다는 모달이 나오는데, 당연히 줘야 하므로 <strong>OK</strong>를 눌러 진행한다.</p><p>이제 만들어진 API를 테스트해보자. 왼쪽 위의 번개모양 <strong>Test</strong> 버튼을 누르면 테스트를 진행할 수 있다. <strong>Request Body</strong>에 아까 Lambda 함수를 테스트할 때 넣었던 값을 다시 입력한 뒤 <strong>Test</strong> 버튼을 누르면 동일한 값이 출력되는 것을 볼 수 있다.</p><p>다만, 아직까지는 HTTP Request를 통해 이 Lambda 함수를 실행시키지 못한다. HTTP Request를 통해 이 함수를 실행시키려면 API를 배포해야한다. 아래와 같은 절차를 따라 API를 배포한다.</p><p><img src="/images/aws-lambda-easy-start/api-gateway-deploy-api.png" alt="API Gateway Deploy API Screenshot"></p><p>1) <strong>Actions &gt; Deploy API</strong> 버튼을 클릭한다.</p><p><img src="/images/aws-lambda-easy-start/api-gateway-stage.png" alt="API Gateway Stage Screenshot"></p><p>2) <strong>Deployment Stage</strong>는 <strong>[New Stage]</strong>를 선택하고, <strong>Stage name</strong>을 적당히 입력한다.</p><p>3) <strong>Deploy</strong> 버튼을 눌러 Deploy 한다.</p><p>이제 상단에 Invoke URL이 표시되는 것을 볼 수 있다. 적당한 HTTP Request용 툴을 사용해서 해당 주소로 요청을 해보자.</p><p><img src="/images/aws-lambda-easy-start/postman.png" alt="Postman Screenshot"></p><p>여기서는 Postman을 사용했다. 정상적으로 응답이 도착했다면 API Gateway와의 연동이 끝난 것이다.</p><p>이 글에서는 API Gateway에 대해서 여기까지만 다루지만, 이외에도 API Gateway는 유용한 기능이 많다.</p><h2 id="npm-모듈-사용하기"><a href="#npm-모듈-사용하기" class="headerlink" title="npm 모듈 사용하기"></a>npm 모듈 사용하기</h2><p>AWS 콘솔에서도 직접 코드를 수정하거나 만들어 낼 수도 있지만, 이렇게 해서는 npm 모듈을 사용할 수도 없고 파일을 분할해서 관리할 수도 없다. Lambda는 이 부분을 보완하기 위해서 ZIP 파일을 업로드하거나 S3에서 파일을 불러오는 선택지도 제시하고 있다. 이 글에서는 ZIP 파일을 업로드하는 부분에 대해서만 다룰 것이다.</p><p>방법은 간단하다. 필요한 파일을 모두 포함한 채로 ZIP 파일을 만들어 그걸 업로드하기만 하면 된다.</p><p>여기서는 Lambda 함수의 요구사항을 조금 바꿔, 숫자 하나를 입력받으면 그만큼의 길이의 자연수 배열을 만들어서 돌려주는 함수를 만들 것이다.</p><p>이 요구사항을 만족시키기 위해서 <a href="https://lodash.com/docs/4.17.10#range" target="_blank" rel="noopener">Lodash의 range</a>함수를 사용한다. 따라서 먼저 Lodash를 인스톨한 뒤, <code>index.js</code> 파일에 아래와 같이 <code>handler</code> 함수를 작성하면 된다.</p><script src="https://gist.github.com/HyunSeob/9d50d0a6c464071bd34ed983f5f08439.js"></script><p>Lodash를 import 한다는 것을 제외하면 전에 작성했었던 함수와 구조적으로 크게 다르지 않다. 이제 설치된 <code>node_modules</code>와 함께 <code>index.js</code> 파일을 ZIP 파일로 묶어서 Lambda에 업로드 하기만 하면 모든 절차가 끝난다. ZIP 파일의 이름은 상관없으나, JavaScript 엔트리 파일은 이름이 <code>index.js</code>여야 한다.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p><p><img src="/images/aws-lambda-easy-start/lambda-upload-zip.png" alt="Lambda Upload ZIP Screenshot"></p><p>AWS Lambda로 돌아가서 <strong>Code entry type</strong>을 <strong>Upload a ZIP file</strong>로 변경하고 만들어진 ZIP 파일을 올린다. 그 뒤 <strong>Save and tes</strong> 버튼을 클릭하여 테스트도 해보자. 실수가 없다면, 테스트 결과는 의도한대로 배열을 돌려줄 것이다.</p><h2 id="S3-접근하기"><a href="#S3-접근하기" class="headerlink" title="S3 접근하기"></a>S3 접근하기</h2><p>Node.js에서 AWS에 접근하기 위해서는 <a href="https://github.com/aws/aws-sdk-js" target="_blank" rel="noopener">aws-sdk</a> 모듈을 사용해야 한다. AWS Lambda의 Node.js 런타임에는 이 모듈이 기본적으로 설치되어 있으므로 추가로 설치할 필요없이, 바로 사용할 수 있다.</p><p>여기서는 Lambda 함수에 파일 이름과 파일 내용을 포함해서 요청하면 그 내용대로 S3에 파일을 만드는 함수를 작성한다. 함수의 구현은 아래와 같다.</p><script src="https://gist.github.com/HyunSeob/3a809febbfc44eba55e4cb7618080261.js"></script><p><code>s3.putObject()</code>라는 함수의 콜백에서 <code>callback()</code> 함수를 호출해서 에러를 전달하는 것을 볼 수 있을 것이다. 에러가 발생하는 경우 저렇게 <code>callback()</code> 함수의 첫 번째 인자로 에러 객체를 넘기면 에러가 출력된다.</p><p>여기서는 이미 버킷이 만들어져 있는 경우를 가정하고 있다. <code>BUCKET_NAME</code>이라는 상수를 각자의 버킷에 맞춰 수정한 뒤 다시 ZIP 파일을 업로드해 테스트해보자. 테스트를 실행하면 <code>Access Denied</code> 에러와 함께 실패할 것이다.</p><p>Lambda 함수는 기본적으로 S3에 접근할 권한이 주어져있지 않다. 그렇기 때문에 S3에 쓰기를 하니 에러가 나는 것이다. 이를 해결하기 위해서는 S3 쓰기 권한을 얻어야 하고, 권한을 얻기 위해서는 Role을 설정해야 한다.</p><p>Lambda에서 S3에 쓰기 권한을 주는 Role은 미리 템플릿으로 정의되어 있지 않으므로 직접 만들어야 한다. AWS IAM 콘솔에 들어간 뒤 아래와 같은 절차를 밟아서 Role을 만들면 된다.</p><p><img src="/images/aws-lambda-easy-start/iam-create-role.png" alt="IAM Create Role Screenshot"></p><p>1) <strong>Roles &gt; Create new role</strong>을 클릭한 뒤,</p><p><img src="/images/aws-lambda-easy-start/iam-select-role-type.png" alt="IAM Select Role Type Screenshot"></p><p>2) <strong>Select role type &gt; AWS Lambda</strong>를 선택한다.</p><p><img src="/images/aws-lambda-easy-start/iam-attach-policy.png" alt="IAM Attach Policy Screenshot"></p><p>3) <strong>Policy Name</strong>이 <strong>AWSLambdaExecute</strong>인 정책을 찾아 선택한 후 다음 스텝으로 넘어간다.</p><p>4) 이름을 짓고 <strong>Create role</strong> 버튼을 클릭해 Role을 만든다.</p><p>Role을 만든 뒤에는 다시 Lambda 콘솔로 돌아와서 <strong>Configuration &gt; Role</strong>에서 <strong>Choose an existing role</strong>을 선택한 뒤, <strong>Existing role</strong>에서 방금 만든 Role을 선택하고 저장하면 된다. 저장한 뒤, 알맞는 테스트 데이터를 입력해 테스트해보면 아까와 같은 권한 에러가 나지 않고 성공하는 것을 볼 수 있다. S3 버킷에서 실제로 파일이 작성되었는지도 확인해보자.</p><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>코드를 수정하고, ZIP 파일을 올리는 과정을 몇 번 반복하다 보면 조금 귀찮아지고, 이런 것들을 좀 더 편하게 할 수 있는 방법을 찾게 된다. 물론 이미 Setup이나 Deploy를 돕는 툴이 나와있다. Node.js를 지원하는 것으로는 <a href="https://www.npmjs.com/package/node-lambda" target="_blank" rel="noopener">node-lambda</a>와 <a href="http://apex.run/" target="_blank" rel="noopener">Apex</a>라는 툴이 있는데 node-lambda는 단일 함수만 관리할 경우 큰 불편없이 사용할 수 있지만, 여러개의 함수를 관리하기는 좀 버겁다. Apex는 여러 개의 함수를 관리하는 데 특화되어 있고, 사용자의 수도 훨씬 많다. 다음 글에서는 Apex의 기본적인 사용법과 더불어, TypeScript로 된 코드베이스에서 Deploy하는 법을 다룬다.</p><p>다음 글: <a href="/2017/07/09/aws-lambda-with-apex/">AWS Lambda: Apex로 관리하기</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><strong>Configuration &gt; Handler</strong> 항목을 수정하면 바꿀 수 있다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/aws-lambda-easy-start/logo.jpg&quot;/&gt;&lt;p&gt;최근에 AWS Lambda를 좀 써볼만한 일이 생겨서 이래저래 삽질을 했다. 막상 시작하려니 내가 잘 모르는 분야라 부담스럽기도 해서 시도를 주저하고 있었
      
    
    </summary>
    
      <category term="Server" scheme="https://hyunseob.github.io/categories/Server/"/>
    
      <category term="AWS" scheme="https://hyunseob.github.io/categories/Server/AWS/"/>
    
    
      <category term="Node.js" scheme="https://hyunseob.github.io/tags/Node-js/"/>
    
      <category term="AWS" scheme="https://hyunseob.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>webpack2 입문 가이드</title>
    <link href="https://hyunseob.github.io/2017/03/21/webpack2-beginners-guide/"/>
    <id>https://hyunseob.github.io/2017/03/21/webpack2-beginners-guide/</id>
    <published>2017-03-21T12:24:09.000Z</published>
    <updated>2018-12-31T10:15:02.283Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/webpack2.png"/><p>이 글은 webpack을 다루어 보지 않은 사람들을 위한 가이드다. 다만 webpack2를 기준으로 하며, 기본적인 웹 지식(CommonJS, ES2015 등)은 알고있다고 가정한다.</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack은 JavaScript 모듈 번들러(Bundler)다. 번들러는 말 그대로 번들링을 하는 도구를 말한다. 그러면 번들링은 뭘까? webpack 공식 페이지에 있는 그림을 보면 이해에 도움이 될 것이다.</p><p><img src="/images/what-bundler-do.svg" alt="번들러가 하는일"></p><p>webpack은 별도의 파일로 분리되어 있는 JavaScript 모듈들을 의존성을 통해 하나 혹은 여러 개의 파일로 묶는다. 이것을 번들링이라고 한다. 여기에 여러가지 설정을 더하면 CSS나 이미지도 JavaScript 파일로 번들링할 수 있다.</p><p>다른 번들러로는 browserify, rollup.js 등이 있다. 하지만 요즘 프론트엔드 세계에서는 webpack으로 대세가 굳어진 느낌이다.</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world!"></a>Hello, world!</h2><p>먼저 webpack을 가지고 놀기 위한 놀이터 디렉토리를 만들자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir webpack-playground &amp;&amp; <span class="built_in">cd</span> webpack-playground</span><br></pre></td></tr></table></figure><p>다음으로, webpack을 설치한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add webpack --dev</span><br></pre></td></tr></table></figure><p><a href="https://yarnpkg.com/lang/en/" target="_blank" rel="noopener">yarn</a>이 없다면 npm을 사용해서 설치해도 되지만 package.json이 없기 때문에 <code>npm init</code>이 선행되어야 한다.</p><p>또한 글로벌로 설치해서 CLI를 사용해도 되지만 어차피 실제 협업 환경에서는 로컬로 설치한뒤 npm 스크립트를 이용하는 경우가 일반적이므로 로컬 설치를 권장한다.</p><p>그 다음으로는 webpack이 로드할 모듈을 구현한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'Hello'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure><p>모듈을 만들어놓기만 하고 쓰지 않는다면 아무 소용이 없다. 위의 모듈을 사용하는 코드를 작성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line"><span class="keyword">var</span> world = <span class="built_in">require</span>(<span class="string">'./world'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(hello + <span class="string">', '</span> + world + <span class="string">'!'</span>);</span><br></pre></td></tr></table></figure><p>평소에 Node.js를 자주 사용해서 CommonJS에 익숙하다면 위의 코드가 어떻게 동작할지 잘 알고 있을 것이다. <code>hello</code> 변수는 아까 구현한 hello.js를 로드하므로 <code>&#39;Hello&#39;</code>라는 문자열이 되고, <code>world</code> 역시 마찬가지다.</p><p>이제 파일을 번들링하기 위해서 npm 스크립트를 써준뒤, 사용한다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack entry.js bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^2.2.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 상태에서 아래의 명령어를 입력한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn build <span class="comment"># 혹은 npm run build</span></span><br></pre></td></tr></table></figure><p>bundle.js라는 파일이 생겼음을 확인할 수 있다. 이제 이 파일을 HTML 파일에서 로드하면 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 HTML 파일을 웹 브라우저에서 열어보면 <code>Hello, world!</code>라는 문자열이 출력되는 것을 확인할 수 있다.</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>CLI만 이용해서 webpack을 사용할 수도 있지만 명령어가 금방 복잡해지고 한계가 생기므로 설정 파일을 사용하는 것이 일반적이다.</p><p>webpack의 설정파일은 복잡하기로 악명이 높지만.. 늘 그렇듯이 처음에는 단순하게 시작할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'entry'</span>: <span class="string">'./entry.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>여기까지 왔다면 이 설정파일이 이해 안될 분은 없으리라 생각한다. 정말 최소한의 설정만 해놓은 파일이다. 물론 아래에서 계속해서 덩치가 커질 예정이지만 일단 이 설정파일만 가지고도 번들링을 할 수 있다.</p><p>설정파일을 만들었다면 <code>webpack</code>이라는 명령어만 쳐도 파일을 번들링할 수 있다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^2.2.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stylesheet"><a href="#Stylesheet" class="headerlink" title="Stylesheet"></a>Stylesheet</h2><p>webpack은 Stylesheet도 JavaScript 파일로 번들링할 수 있다. 물론 CSS는 CommonJS 규격에 맞지 않지만, 자체적인 <code>@import</code> 문도 존재하므로 모듈로 볼 수 있고, 번들링할 수 있는 대상이다.</p><p>webpack에서 CSS를 번들링하는 방법으로 크게 두 가지가 있다. 첫 번째로는 HTML의 <code>&lt;style&gt;</code> 태그 안에 CSS를 직접 쑤셔넣는 방법. 두 번째로는 별도의 엔트리 포인트를 만들어서 또 하나의 CSS 파일로 빌드하는 방법. 두 가지 방법 모두 장단이 있으나 이 글에서는 첫 번째 방법만을 소개한다. 만약 두 번째 방법에 대해서 궁금하다면 <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/" target="_blank" rel="noopener">이 링크</a>를 참조.</p><p><a href="https://github.com/webpack-contrib/style-loader" target="_blank" rel="noopener">style-loader</a>는 정확히 위에 설명한 첫 번째 방식으로 동작하는 로더(Loader)다. 우선 사용하기 위해서 style-loader와 css-loader를 설치하자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add style-loader css-loader --dev</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack-contrib/css-loader" target="_blank" rel="noopener">css-loader</a>는 CSS의 <code>@import</code>나 <code>url()</code>문을 CommonJS의 <code>require</code> 처럼 해석할 수 있도록 만들어주는 로더다. CSS를 번들링 하기 위해서는 기본적으로 이 두 가지 로더를 사용해야 한다.</p><p>먼저, 로더를 사용하려면 설정파일을 수정해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'entry'</span>: <span class="string">'./entry.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">         test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">'style-loader'</span>,</span><br><span class="line">           <span class="string">'css-loader'</span></span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>module</code> 프로퍼티 아래에 약간의 설정을 추가했다. 간단하게 설명하면 <code>.css</code> 확장자로 끝나는 파일을 로드하는 경우 css-loader와 style-loader를 거치도록 하겠다는 의미다. 같은 파일에 대해서 로더는 아래쪽부터 순서대로 동작한다.</p><p>이제 불러올 CSS를 작성한다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* text.css */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* common.css */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'text.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 CSS를 일반적인 CommonJS 모듈 사용하듯이 불러오면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./common.css'</span>);</span><br><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line"><span class="keyword">var</span> world = <span class="built_in">require</span>(<span class="string">'./world'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(hello + <span class="string">', '</span> + world + <span class="string">'!'</span>);</span><br></pre></td></tr></table></figure><p>웹 브라우저에서 새로고침을 해보면 스타일이 적용된 것을 확인할 수 있다. 특히, 개발자 도구를 켜서 <code>&lt;style&gt;</code> 태그 안에 CSS가 들어간 것을 확인해보자.</p><h2 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h2><p>IE환경을 지원하면서도 ES2015를 쓰기 위해서는 babel 같은 트랜스파일러(Transpiler)가 필수다. babel은 단독으로도 사용 가능하지만 webpack과 함꼐 사용하면 더 편리하다. webpack에서는 ES2015 JavaScript를 <a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a>에 통과시켜서 ES5 이하의 JavaScript로 만든다.</p><p>먼저 babel-loader를 사용하기 위해서 먼저 babel-loader를 설치한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add babel-loader babel-core babel-preset-env --dev</span><br></pre></td></tr></table></figure><p>webpack의 설정도 바꿔야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [[</span><br><span class="line">            <span class="string">'env'</span>, &#123;</span><br><span class="line">              targets: &#123;</span><br><span class="line">                browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>설명을 하고 넘어가야 할 것 같다. 먼저, babel을 사용하기 위해서는 preset을 설치해야 한다. 그 중 <a href="https://github.com/babel/babel-preset-env" target="_blank" rel="noopener">babel-preset-env</a>는 설정된 환경에 알맞게 preset을 자동으로 설정해준다. 이 라이브러리를 사용하기 위해서 <code>presets</code> 라는 속성을 사용해서 환경을 설정할 수 있다. 위의 파일에서 설정된 환경은 브라우저 별로 최신의 두 개 버전만을 고려하는 환경이다. 지원하는 브라우저의 리스트는 <a href="http://browserl.ist/?q=last+2+versions" target="_blank" rel="noopener">이 곳</a>에서 확인할 수 있다.</p><p>이제부터 프로젝트에 포함된 모든 <code>.js</code> 확장자 파일은 babel-loader를 거치면서 ES5로 트랜스파일된다. 코드를 ES2015로 변경하여 테스트 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'Hello'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// world.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./common.css'</span>;</span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./hello'</span>;</span><br><span class="line"><span class="keyword">import</span> world <span class="keyword">from</span> <span class="string">'./world'</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">`<span class="subst">$&#123;hello&#125;</span>, <span class="subst">$&#123;world&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure><p>빌드를 뒤 결과를 보면, ES5로 컴파일 된 것을 볼 수 있다.</p><h2 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h2><p>webpack은 번들러지만 JavaScript 파일을 로드하기 때문에 Lint 작업도 수행할 수 있다. Linter로는 <a href="https://eslint.org/" target="_blank" rel="noopener">ESLint</a>를 사용한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add eslint-loader --dev</span><br></pre></td></tr></table></figure><p>ESLint가 글로벌 설치되어있는 상태라면 ESLint의 CLI를 사용하여 쉽게 룰을 생성할 수도 있다. 여기서는 AirBnb 기본 룰을 사용한다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eslint --init</span><br></pre></td></tr></table></figure><p>혹은 다음의 룰을 <code>.eslintrc.js</code> 라는 이름의 파일로 저장한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"airbnb-base"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"import"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">      <span class="string">"browser"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ESLint를 돌리기 위해서는 eslint-loader를 webpack 설정 파일에 추가해야 한다. 빌드된 파일을 Lint하는 건 소용없으므로 반드시 babel보다 먼저 eslint를 거치도록 만들어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>그리고 바로 <code>enforce</code> 속성이 그 역할을 한다. 이 속성을 <code>&#39;pre&#39;</code>로 지정하면 JavaScript 파일들이 babel-loader보다 먼저 eslint-loader를 거치게 된다.</p><p>ESLint가 제대로 동작하는 지 확인해보기 위해서, 코드를 추가한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./common.css'</span>;</span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./hello'</span>;</span><br><span class="line"><span class="keyword">import</span> world <span class="keyword">from</span> <span class="string">'./world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 에러가 발생할 것이다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">`<span class="subst">$&#123;hello&#125;</span>, <span class="subst">$&#123;world&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure><p>제대로 설정했다면 아래처럼 에러가 표시될 것이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error  Unexpected var, use <span class="built_in">let</span> or const instead  no-var</span><br><span class="line">error  <span class="string">'a'</span> is assigned a value but never used    no-unused-vars</span><br></pre></td></tr></table></figure><h2 id="npm-모듈-사용하기"><a href="#npm-모듈-사용하기" class="headerlink" title="npm 모듈 사용하기"></a>npm 모듈 사용하기</h2><p>webpack은 CommonJS 방식의 모듈 로드를 지원하므로, npm 모듈을 브라우저에서 그대로 사용할 수 있다. 여기서는 유명한 JavaScript 라이브러리인 <a href="https://lodash.com/" target="_blank" rel="noopener">Lodash</a>를 사용할 것이다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add lodash</span><br></pre></td></tr></table></figure><p>이제 Lodash의 <code>random</code> 함수를 사용하기 위해서 다음과 같이 코드를 수정한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">from</span> <span class="string">'lodash/random'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./common.css'</span>;</span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./hello'</span>;</span><br><span class="line"><span class="keyword">import</span> world <span class="keyword">from</span> <span class="string">'./world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">`<span class="subst">$&#123;hello&#125;</span>, <span class="subst">$&#123;world&#125;</span>!`</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">`Random: <span class="subst">$&#123;random(<span class="number">0</span>, <span class="number">100</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>빌드하고 브라우저에서 확인해보면 새로고침할 때마다 랜덤한 숫자가 노출되는 것을 확인할 수 있다.</p><p>사족으로, Lodash는 스크립트 용량이 워낙 크기 때문에 <code>import {random} from &#39;lodash&#39;;</code> 같은 식으로 로드하면 Lodash의 완전한 구현을 번들링한다. 따라서 번들링된 스크립트 크기도 매우 커진다. 그러므로 별도의 엔트리 파일을 로드해서 스크립트 사이즈를 최적화하자.</p><p>또한, webpack2 에서는 스크립트 사이즈 최적화 기법으로 <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">Tree Shaking</a>을 사용할 수 있다. 직접 짠 코드는 Tree Shaking을 사용하면 되지만, 다른 라이브러리를 불러와서 사용할 때는 Tree Shaking이 안되는 경우가 있으므로 항상 별도의 엔트리 파일을 포함하는 방법을 찾아보자. Tree Shaking에 대해서는 나중에 별도의 글로 쓸 예정이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>webpack2의 베타가 끝내고 정식 버전도 릴리즈된지 꽤 시간이 흘렀지만 게으름으로 마이그레이션을 차일피일 미루다가, 최근에야 webpack2를 사용하게 되었다. 일찍이 블로그에 <a href="/2016/04/03/webpack-practical-guide/">webpack 실전 가이드</a>라는 글을 쓴 적이 있는데, 이 글은 webpack2를 다루지 않으며, 오래된 정보<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>를 담은 글임에도 아직 많은 사람들이 해당 글로 유입되고 있기 때문에 내용상 거의 중복되지만 이 글을 새로 작성하게 되었다.</p><p>여기에 사용된 코드는 GitHub 레포지토리 <a href="https://github.com/HyunSeob/webpack-guide" target="_blank" rel="noopener">webpack-guide</a>에 올라가 있으니 참고하시기 바란다.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">물론 그래봤자 1년도 채 안됐다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/webpack2.png&quot;/&gt;&lt;p&gt;이 글은 webpack을 다루어 보지 않은 사람들을 위한 가이드다. 다만 webpack2를 기준으로 하며, 기본적인 웹 지식(CommonJS, ES2015 등)은 알고있다고 가정한다.&lt;/
      
    
    </summary>
    
      <category term="FrontEnd" scheme="https://hyunseob.github.io/categories/FrontEnd/"/>
    
    
      <category term="ES2015" scheme="https://hyunseob.github.io/tags/ES2015/"/>
    
      <category term="webpack" scheme="https://hyunseob.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>개발자라면, 블로그</title>
    <link href="https://hyunseob.github.io/2017/02/26/blog-for-developers/"/>
    <id>https://hyunseob.github.io/2017/02/26/blog-for-developers/</id>
    <published>2017-02-26T04:59:26.000Z</published>
    <updated>2018-12-31T10:15:02.254Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/blog-for-developers.jpg"/><p>지난 금요일(17.02.24), 9XD에서 “개발자라면, 블로그”라는 주제로 발표를 했다. 원래는 발표자료만 올리려다가 스피치 빼고 발표자료만 보면 무슨 소린지 이해가 잘 안 될 수 있다 싶어서 블로그에 부연설명을 덧붙여 올린다.</p><p>참고로, 나는 블로그를 시작한 것도, 개발자를 직업으로 갖게 된 것도 2년이 되지 않은 사람이다. 이 블로그 글을 보는 사람 중에는 분명 나와는 비교도 안 될 정도로 오랜 기간 블로그를 운영하시고 더욱 뛰어나신 분도 있을 것이다. 이 발표는 블로그를 시작하지 않은 사람들을 청자로 생각하였다는 점을 염두해 두시면 감사하겠다.</p><p><iframe src="//www.slideshare.net/slideshow/embed_code/key/9Zw2mH96auREEW" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; margin-left: auto; margin-right: auto; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/hyunseoblee7/ss-72566564" title="개발자라면, 블로그" target="_blank">개발자라면, 블로그</a> </strong> from <strong><a href="//www.slideshare.net/hyunseoblee7" target="_blank">Hyun Seob Lee</a></strong> </div></p><h2 id="블로그와-전문성"><a href="#블로그와-전문성" class="headerlink" title="블로그와 전문성"></a>블로그와 전문성</h2><p>나는 블로그가 전문성을 드러내기 가장 쉬운(효율적인) 수단이라고 생각한다. 전문성을 습득하는 것 자체는 개발자로서 당연히 해야하고, 시간이 흐르면 자연스럽게 하게 되지만, 그것을 외부에 노출하는 건 쉽지 않은 일이다.</p><p>기술의 발전으로 인터넷에는 이제 텍스트 외에도 전문성을 드러낼 수 있는 많은 수단이 있다. 개발자로서의 전문성을 드러내는 데는 오픈 소스 기여만한 것이 또 없을 것이고, YouTube에 동영상 강좌나 자신의 오피니언을 촬영해서 올릴 수도 있고, 팟캐스트를 만들어서 음성으로서 지식과 전문성을 뽐낼 수도 있다. 하지만 언급한 방법들은 모두 시간과 비용이 많이 들면서도, 글에 비해서 많은 사람들에게 닿지 않는다.</p><p>SNS는 글 공유에 특화된 매체이지만 반대로 검색에는 약하다는 단점이 있다. 개발하면서 당연히 구글을 사용하게 되는 개발자들에게는 치명적이다. 하지만 그것보다 나쁜 점은 SNS에서는 글을 쓰는데 자유도가 낮고, 그 때문에 전문성있는 글을 쓰기에 한계가 분명하다는 것이다.</p><p>따라서 나는 전문성을 드러내는 데 있어서는 블로그가 가장 효율적인 수단이라고 생각한다. 블로그에 글 쓰는 것도 결코 쉽지는 않지만 비용이 적게 드는 축에 속하고, SNS와 결합하면 내가 원할 때도 정보를 제공할 수 있으며, 검색에도 쉽게 노출할 수 있기 때문에 독자가 원할 때 정보를 제공하는 것도 충분히 가능하다.</p><h2 id="왜-해야하는가"><a href="#왜-해야하는가" class="headerlink" title="왜 해야하는가?"></a>왜 해야하는가?</h2><p>너무 당연한 소리지만, 블로그는 내가 하는 것이다. 자기 스스로가 중심인 매체다. 이것은 블로그를 자기 스스로를 브랜딩하기 위한 목적으로도 사용할 수 있다는 의미다.</p><p>나는 스스로 동기부여가 약한 편이고 외부적 요인에 의해서 동기부여를 강하게 받는 사람이다. 그래서 나는 블로그를 통한 스스로의 성장도 중요하게 생각하지만, 블로그가 강력한 브랜딩이 된다는 사실에 더 큰 매력을 느낀다. 실제로 내가 그 브랜딩으로 이득을 본 사람이기도 하고. 따라서 나는 사실 개발자라면 블로그를 해야하는 것이 아니라, 전문가라면 블로그를 해야한다고 믿는다.</p><h2 id="블로그를-하기-전의-걱정"><a href="#블로그를-하기-전의-걱정" class="headerlink" title="블로그를 하기 전의 걱정"></a>블로그를 하기 전의 걱정</h2><p>다양한 개발자 분들과 블로그에 대해서 얘기를 해보면 흔히 접할 수 있는 걱정이있다. “에이 나같은 게 무슨 블로그를..” 같은 걱정들. 자신의 전문성이 떨어진다고 생각하는 것이다. 하지만 전문성이 떨어진다고 해서 블로그를 하지 않을 이유는 없다. 아까 한 말과 상반되는 것 같지만, 블로그가 개인의 브랜딩 요소에 있어서 실질적으로 도움되는 것은 전문성보다는 자기계발의지에 가깝다. 블로그는 하는 것만으로도 전문성 여부와는 관계 없이 브랜딩에 도움이 된다. 또한 블로그 글을 쓰면서 자신의 전문성도 성장하고, 분명 자신의 수준보다도 낮은 사람도 있기에 남들에게도 충분히 도움이 된다. 오히려, 전문성이 부족하기 때문에 블로그를 시작해야 한다고 말하고 싶다.</p><p>자기 자신이 게으르다고 생각해서 쉽게 시작하지 못하는 사람도 있다. 게으름은 상대적인 표현이라서 요즘 사람들은 대부분 자신이 게으르다고 생각하는 것 같다. 이 글을 쓰는 나조차도 스스로 게으르다고 생각하는 편이다. 사실 게으르다고 생각하는 것 자체가 심리적으로 불편하다는 사실을 내포하고 있으므로, 역설적으로 자기계발의지가 있다고 할 수도 있다. 블로그를 하지 않는 건 그 사람이 게을러서가 아니라 시작하지 않아서이다. 때문에 가벼운 마음으로 블로그를 시작했으면 좋겠다. 지금 당장 미디엄이나 텀블러에 접속해서 글쓰기를 누르면 된다. 시작이 반이다.</p><h2 id="어떻게-해야하는가"><a href="#어떻게-해야하는가" class="headerlink" title="어떻게 해야하는가?"></a>어떻게 해야하는가?</h2><p>내가 발표 떄 언급했던 항목은 다음과 같다.</p><ul><li>RSS를 반드시 만들자.</li><li>Facebook 페이지를 곁들이면 좋다. 아니면 유저계정을 페이지처럼 활용하자.</li><li>블로그 개발경험도 나쁘지 않다. 하지만 주객전도를 피하자.</li><li>단순 스크랩 방식의 블로그는 지양하자.</li><li>글을 쓴 이유나 컨텍스트를 서술해서 최대한 독자를 배려하자.</li><li>자기가 아는 개발 그룹에 모두 공유하는 등, 너무 많은 공유는 피하자.</li><li>웬만하면 네이버 블로그는 쓰지말자.</li><li>~Hexo에 <a href="https://github.com/HyunSeob/hexo-theme-overdose" target="_blank" rel="noopener">Overdose</a> 테마를 씌우고 별을 찍자.~</li></ul><p>네이버 블로그를 피하자는 의견은, 대부분의 개발자가 구글을 중심으로 검색하기 때문이다. 사실 네이버가 구글 검색결과에 잘 잡히기만 한다면 안 될 이유가 없다. 요즘에 모바일 페이지가 구글 검색결과에 잡히기는 하던데, 이 경우에도 PC 사용자 입장에서는 경험이 좋지 않으므로 이 방법도 좋지 않다. 물론 경우에 따라 네이버 검색량이 많은 블로그는 네이버에서 블로그를 하면 좋다. 요컨대, 가장 많은 검색이 일어날 곳을 대상으로 블로그 서비스를 결정하면 된다는 것이다.</p><h2 id="발표-후-소감"><a href="#발표-후-소감" class="headerlink" title="발표 후 소감"></a>발표 후 소감</h2><p>개인적으로 개발자 밋업(혹은 컨퍼런스)에서 발표를 한 것은 처음이다. 사실 9XD가 참가하기 너무 어려워서<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, 9XD 좀 가보자 하고 발표를 한 건데 좋은 경험이 되었다. 물론 준비하는 게 좀 힘들긴 했는데 그만큼 얻은 게 많았다. 뭐 그렇다고 내가 발표를 딱히 잘 하지는 않았지만, 재미있었다.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">9XD 참가신청은 거의 수강신청급이다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/blog-for-developers.jpg&quot;/&gt;&lt;p&gt;지난 금요일(17.02.24), 9XD에서 “개발자라면, 블로그”라는 주제로 발표를 했다. 원래는 발표자료만 올리려다가 스피치 빼고 발표자료만 보면 무슨 소린지 이해가
      
    
    </summary>
    
      <category term="Opinion" scheme="https://hyunseob.github.io/categories/Opinion/"/>
    
    
      <category term="Blog" scheme="https://hyunseob.github.io/tags/Blog/"/>
    
      <category term="Opinion" scheme="https://hyunseob.github.io/tags/Opinion/"/>
    
  </entry>
  
  <entry>
    <title>나의 커맨드라인 인터페이스</title>
    <link href="https://hyunseob.github.io/2017/02/05/my-command-line-interface/"/>
    <id>https://hyunseob.github.io/2017/02/05/my-command-line-interface/</id>
    <published>2017-02-05T08:27:08.000Z</published>
    <updated>2018-12-31T10:15:02.271Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/my-command-line-interface/my-command-line-interface.png"/><p>웹 개발자라면 커맨드라인 인터페이스를 이용해 처리해야하는 일들이 종종 있다. 나는 CLI를 잘 못 쓰는 편이라서 딱히 하드한 설정을 사용하는 건 아니지만 맥에 새로 CLI 환경을 세팅하면서 은근히 여러가지 신경 쓸 거리가 많아서 정리도 한 번 할 겸해서 내 환경을 포스팅 해본다.</p><h2 id="터미널"><a href="#터미널" class="headerlink" title="터미널"></a>터미널</h2><p>맥의 기본 터미널 앱을 사용한다. iTerm2를 추천하는 경우가 많은데 좋은 앱임에는 분명하지만 나는 인터페이스가 안 이쁘면 잘 안 쓴다. 즉, 이걸 쓰는 건 그냥 취향이다. 기본 맥 터미널도 꽤 잘 만들어졌고, 여태까지 특별히 불편함을 느낀 일은 없었다. iTerm2보다는 Electron 기반 터미널인 Hyper의 한글 지원을 기다리고 있는데 언제 제대로 될런지..</p><h3 id="터미널-테마"><a href="#터미널-테마" class="headerlink" title="터미널 테마"></a>터미널 테마</h3><p><a href="https://draculatheme.com/" target="_blank" rel="noopener">Dracular 테마</a>가 나온 이후로 나는 가능한 모든 프로그램(Alfred, Atom, WebStorm)을 Dracular 테마로 변경하고 있다. 터미널도 예외는 아니다.</p><h3 id="폰트"><a href="#폰트" class="headerlink" title="폰트"></a>폰트</h3><p><a href="https://github.com/powerline/fonts/tree/master/UbuntuMono" target="_blank" rel="noopener">Ubuntu Mono derivative Powerline</a>이라는 폰트를 사용한다. 밑에서 다시 언급하겠지만 내가 사용하는 zsh 테마가 Powerline을 사용하기 때문에 Powerline을 지원하는 폰트를 사용해야하고, 그 중에 Ubuntu Mono를 선택했다.</p><h2 id="셸-인터페이스-Shell-interface"><a href="#셸-인터페이스-Shell-interface" class="headerlink" title="셸 인터페이스(Shell interface)"></a>셸 인터페이스(Shell interface)</h2><p>따로 설명을 따로 할 필요가 없을 정도로 유명한 조합, zsh + oh my zsh 를 사용하고 있다.</p><h3 id="zsh-테마"><a href="#zsh-테마" class="headerlink" title="zsh 테마"></a>zsh 테마</h3><p><a href="https://github.com/caiogondim/bullet-train.zsh" target="_blank" rel="noopener">Bullet Train</a>이라는 테마를 사용하고 있다. 내장된 테마가 아니기 때문에 별도의 설치가 필요하다. Bullet Train을 선택한 이유는, 커맨드 라인에 많은 정보를 표시하는 경우 다른 테마들은 커서가 오른쪽으로 쏠리면서 커서 위치가 일관적이지 않은데, Bullet Train은 많은 정보를 표시하면서도 커서가 개행된 위치에 있기 때문에 항상 커서 위치가 같기 때문이다. 물론 예쁘기도 하고.</p><h3 id="zsh-플러그인"><a href="#zsh-플러그인" class="headerlink" title="zsh 플러그인"></a>zsh 플러그인</h3><h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh autosuggestions"></a><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh autosuggestions</a></h4><p><img src="/images/my-command-line-interface/autosuggestions.gif" alt="zsh autosuggestions plugin"></p><p>전에 한 동료분이 fish를 사용했었는데, 가장 충격적이었던 게 커맨드 자동완성이었다. 나는 zsh에서도 이런 기능을 사용할 수 있는지 찾아보기 시작했고 역시나 플러그인이 있었다. fish를 사용해본적이 없어서 fish의 그것보다 강력한지 약한지는 모르겠으나 쓸만하다. 커맨드 history 기반으로 커맨드를 추천해주는 것 같은데, 사용한 적이 없는 커맨드라면 자동완성이 되지 않지만 자주 사용하는 커맨드의 경우 쉽게 자동완성할 수 있다. 실제로 생산성이 올라가기 때문에 강력 추천하는 플러그인이다.</p><h4 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></h4><p>이 플러그인도 fish의 기능으로부터 영감을 받은 플러그인이다. 커맨드라인에서 명령어를 입력할 때 문법 강조를 해준다. 예쁨이 쬐끔 향상되는 효과가 있다.</p><h4 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a><a href="https://github.com/wting/autojump" target="_blank" rel="noopener">autojump</a></h4><p><img src="/images/my-command-line-interface/autojump.gif" alt="zsh automjump plugin"></p><p>유명한 플러그인. 원래는 <code>cd</code>를 여러 번 쳐서 옮겨다닐 디렉토리를 <code>j</code> 한 방으로 옮겨갈 수 있다. 가본 적 없는 디렉토리는 바로 옮겨갈 수 없지만, 대개 디렉토리를 옮기는 경우는 이미 가본 적 있는 디렉토리를 여러 번 방문하게 되는 경우이므로 활용할 기회가 잦다. 위에 언급한 zsh-autosuggestion과 같이 활용한다면 대부분의 디렉토리 이동을 타이핑 몇 번으로 처리할 수 있다. 속도도 느리지 않다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/my-command-line-interface/my-command-line-interface.png&quot;/&gt;&lt;p&gt;웹 개발자라면 커맨드라인 인터페이스를 이용해 처리해야하는 일들이 종종 있다. 나는 CLI를 잘 못 쓰는 편이라
      
    
    </summary>
    
      <category term="Tool" scheme="https://hyunseob.github.io/categories/Tool/"/>
    
    
      <category term="Tool" scheme="https://hyunseob.github.io/tags/Tool/"/>
    
      <category term="CLI" scheme="https://hyunseob.github.io/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript: 제네릭(Generic)</title>
    <link href="https://hyunseob.github.io/2017/01/14/typescript-generic/"/>
    <id>https://hyunseob.github.io/2017/01/14/typescript-generic/</id>
    <published>2017-01-14T14:51:23.000Z</published>
    <updated>2018-12-31T10:15:02.279Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/11/18/typescript-function/">TypeScript: 함수(Function)</a></p><p>제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다.</p><p>제네릭은 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다. Java나 C++ 등의 정적 타입 언어에서는 함수 및 클래스를 선언하는 시점에서 매개변수 혹은 리턴 타입을 정의해야하기 때문에 기본적으로는 특정 타입을 위해 만들어진 클래스나 함수를 다른 타입을 위해 재사용할 수가 없다. 때문에 제네릭을 통해 함수와 클래스의 범용적인 사용을 가능케 한다.</p><p>JavaScript는 원래 타입 선언이 필요하지 않고, 그렇기에 특정 타입을 위해 만들어진 클래스나 함수도 타입 에러를 런타임에서 일으킬 뿐이다. 코드를 실행시키기 전까지는 함수와 클래스가 모든 타입에 대응한다. 그렇기 때문에 JavaScript에서는 제네릭이란 말을 들을 일이 없다.</p><p>정적 타입 언어에서도 이렇게 특정 타입을 위해 만들어진 함수 혹은 클래스를 보다 범용적으로 재사용하기 위한 요구가 있기 때문에 제네릭이라는 프로그래밍 기법이 생긴 게 아닐까한다. TypeScript도 마찬가지로 정적 타입 언어이기 때문에, 기본적으로 타입을 정의한 함수 혹은 클래스는 모두 다른 타입에 재사용할 수 없다. 제네릭을 사용하지 않는다면 말이다.</p><h2 id="제네릭을-사용하는-이유"><a href="#제네릭을-사용하는-이유" class="headerlink" title="제네릭을 사용하는 이유"></a>제네릭을 사용하는 이유</h2><p>제네릭을 유용하게 사용할 수 있는 경우로는 자료구조가 있다. 다음과 같이 스택 자료구조를 TypeScript로 구현한다고 가정하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line">  <span class="keyword">private</span> data: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">  contructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  push(item: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러가지 방법으로 구현할 수 있겠지만, 스택 같은 자료구조는 대개 범용적인 타입을 수용할 수 있도록 만들어진다. 따라서 TypeScript에서는 위와 같이 <code>any</code>를 이용하여 구현할 수 있는 것이 가장 쉬운 방법이다.</p><p>하지만 <code>any</code>를 이용하여 구현하면 저장하고 있는 자료의 타입이 모두 같지 않다는 문제점이 생긴다. 따라서 위의 스택에서 자료를 추출하는 경우 런타임에서 항상 타입 검사를 해줘야 한다는 것이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="string">'a'</span>);</span><br><span class="line">stack.pop().substring(<span class="number">0</span>) <span class="comment">// 'a'</span></span><br><span class="line">stack.pop().substring(<span class="number">0</span>) <span class="comment">// Throw TypeError</span></span><br></pre></td></tr></table></figure><p>그렇다고 자료형을 보장하기 위해 항상 <code>number</code> 타입의 변수만 받을 수 있도록 하면, 범용성이 떨어지게 된다.</p><p>물론 상속으로도 이를 처리할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumberStack <span class="keyword">extends</span> Stack &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(item: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 상속을 사용하는 경우에는 자료형을 하나 추가할 때마다 구태여 클래스를 추가하고 중복되는 코드를 양산해야하기 때문에 번거롭기는 마찬가지다.</p><p>이런 경우에 유용하게 사용할 수 있는 것이 제네릭이다.</p><h2 id="제네릭의-문법"><a href="#제네릭의-문법" class="headerlink" title="제네릭의 문법"></a>제네릭의 문법</h2><h3 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h3><p>스택 자료구조를 제네릭으로 다시 구현하면 다음과 같은 형태를 띌 것이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> data: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  push(item: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 식별자 선언부에 <code>&lt;T&gt;</code>라는 못보던 문법이 추가된 것을 확인할 수 있다. 제네릭을 사용하겠다는 의미로 꺽쇠(Angle brackets)를 넣고 그 안에 타입으로 사용되는 식별자를 집어넣는다.</p><p><code>T</code>는 Type의 약자로 다른 언어에서도 제네릭을 선언할 때 관용적으로 많이 사용된다. 이 부분에는 식별자로 사용할 수 있는 것이라면 무엇이든 들어갈 수 있다. 이를테면 <code>$</code>나 <code>_</code>도 가능하다는 의미다. 하지만 대개의 경우 <code>T</code>를 사용한다. 여기에서 <code>T</code>를 타입 변수(Type variables)라고 한다.</p><p>이렇게해서 클래스에서 제네릭을 사용하겠다고 선언한 경우 <code>T</code>는 해당 클래스에서 사용할 수 있는 특정한 타입이 된다.</p><p>사용법은 아래와 같다. 그저 생성자를 호출하여 객체를 만들 때 <code>T</code>로 사용될 타입을 지정해주기만 하면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> stringStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">numberStack.push(<span class="number">1</span>);</span><br><span class="line">stringStack.push(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>이제 각 스택은 항상 생성할 때 선언한 타입만을 저장하고 리턴한다. 이렇게 하면 컴파일러가 리턴하는 타입을 알 수 있게 되므로 에디터에서 자동 완성을 사용할 수 있게 되므로 생산성 향상에도 기여한다는 장점이 있다.</p><p>다만 타입은 컴파일 단계에서 검사하는 것이므로 런타임에서는 막을 수 없다. 이를테면,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numberStack.push(<span class="string">''</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br></pre></td></tr></table></figure><p>이런<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 코드는 컴파일 단계의 타입 체크를 우회하므로 막을 수 없다.</p><h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><p>배열을 입력으로 받아 그 배열의 첫번째 요소를 출력하는(<code>lodash.head()</code> 같은) 함수를 구현해야 한다고 가정하자. 제네릭을 사용하지 않는 경우 이렇게 짜게 될 것이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 마찬가지로 어떤 타입의 배열이라도 받을 수 있기 때문에 리턴하게 되는 타입이 무엇인지 알 수 없다. 제네릭을 이용하면 다음과 같이 간단하게 구현할 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>추가된 것은 클래스와 동일하게 함수 식별자 옆에 들어가는 <code>&lt;T&gt;</code>이다. 마찬가지로 이 함수 내에서 <code>T</code>는 특정한 타입으로 취급된다.</p><p>마찬가지로 사용할 때는 함수를 호출할 때 제네릭 문법으로 타입을 정해주기만 하면 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="두-개-이상의-타입-변수"><a href="#두-개-이상의-타입-변수" class="headerlink" title="두 개 이상의 타입 변수"></a>두 개 이상의 타입 변수</h2><p>제네릭 함수나 클래스에서는 두 개 이상의 타입 변수도 사용할 수 있다. 다음과 같이 두 가지 변수를 받아 쌍으로 만들어 반환하는 함수를 구현해야 한다고 가정하자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPair</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): [ <span class="title">any</span>, <span class="title">any</span> ] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [ a, b ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>입력되는 두 가지의 변수의 타입이 다르다고 가정할 경우 두 가지의 타입 변수가 필요하게 된다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">a: T, b: U</span>): [ <span class="title">T</span>, <span class="title">U</span> ] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [ a, b ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>제네릭을 사용하면 위와 같은 형태로 구현할 수 있다. 꺽쇠 안에 <code>T</code>와 <code>U</code> 두 가지의 타입 변수가 보일 것이다. 아까 관용적으로 <code>T</code>를 사용한다고 말했는데, 그 뒤로는 알파벳 순서대로 사용하면 된다. 반복문에서 관용적으로 인덱스 변수로 <code>i</code>, <code>j</code>를 사용하는 것과 비슷하다.</p><p>함수 사용법은 아래와 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toPair&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">'1'</span>, <span class="number">1</span>); <span class="comment">// [ '1', 1 ]</span></span><br><span class="line">toPair&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// [ 1, 1 ]</span></span><br></pre></td></tr></table></figure><h2 id="상속된-타입-변수"><a href="#상속된-타입-변수" class="headerlink" title="상속된 타입 변수"></a>상속된 타입 변수</h2><p>타입 변수는 기존에 사용하고 있는 타입을 상속할 수도 있다. 이 점을 이용하면 입력 받을 변수의 타입을 제한할 수 있다. 또한 에디터가 해당 타입의 메소드나 프로퍼티를 예측할 수 있으므로 자동 완성이 된다.</p><p>이것과 여러 개의 타입 변수를 사용해 응용하면 아래와 같은 코드를 짤 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirst</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Stack</span>&lt;<span class="title">U</span>&gt;, <span class="title">U</span>&gt;(<span class="params">container: T</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> item = container.pop();</span><br><span class="line">  container.push(item);</span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getFirst</code>는 입력받은 스택의 첫번째 요소를 반환하는 함수다. 사용시에는 아래처럼 사용하면 된다. 만약 첫 번째 타입으로 스택, 혹은 스택을 상속한 타입이 아닌 다른 타입을 사용하면 에러가 발생한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getFirst&lt;Stack&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>)(numberStack);</span><br><span class="line">getFirst&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;(<span class="number">1</span>); <span class="comment">// Type 'number' does not satisfy the constraint 'Stack&lt;number&gt;'.</span></span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">하지만 실제로 TypeScript를 실서비스에 적용하다보면 이러한 코드를 어쩔 수 없이 짜게되는 경우가 좀 있다. 물론 지양해야 한다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/images/typescript.png&quot;/&gt;&lt;p&gt;이전 글 - &lt;a href=&quot;/2016/11/18/typescript-function/&quot;&gt;TypeScript: 함수(Function)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;제네릭은 Java 등의 정적 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://hyunseob.github.io/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/categories/JavaScript/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://hyunseob.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Flexbox 활용사례 모음: Solved by Flexbox</title>
    <link href="https://hyunseob.github.io/2017/01/09/solved-by-flexbox/"/>
    <id>https://hyunseob.github.io/2017/01/09/solved-by-flexbox/</id>
    <published>2017-01-09T14:41:24.000Z</published>
    <updated>2018-12-31T10:15:02.272Z</updated>
    
    <content type="html"><![CDATA[<img src="https://hyunseob.github.io/solved-by-flexbox-kr/images/vertical-centering.jpg"/><p><a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener">Flexbox</a>는 웹페이지에서 다양한 레이아웃을 만들기 위해서 쓸 수 있는 최신 CSS 기능이다. 사실 지금까지 CSS를 이용해서 레이아웃을 만드는 것이 그리 간단한 일은 아니었다. 수직 중앙 정렬은 잘 알려진 문제 중 하나다. 물론 지금까지 해결방법이 없었던 것은 아니지만 대개는 CSS Hack을 사용해야 하므로 코드가 직관적이지 않았으며, 쓸데없는 속성을 사용해야만 했다. 게다가 어떤 때에는 JavaScript를 사용해야 이런 문제를 해결할 수 있었다. 이런 수 많은 레이아웃 문제를 해결하기 위해 나온 스펙이 Flexbox다. Flexbox는 직관적인 코드를 제공하면서도 원하는 기능을 쉽게 구현할 수 있도록 만들어준다.</p><h2 id="좋은-거-나도-아는데-IE는-어쩔껴"><a href="#좋은-거-나도-아는데-IE는-어쩔껴" class="headerlink" title="좋은 거 나도 아는데, IE는 어쩔껴?"></a>좋은 거 나도 아는데, IE는 어쩔껴?</h2><p><a href="http://caniuse.com/#search=flexbox" target="_blank" rel="noopener">Can I use</a>를 보면 모던 브라우저는 완벽하게 지원하고 있지만 당연하게도 IE쪽에 문제가 있다. IE9 이하의 버전은 지원하지도 않으며 그나마 10부터는 지원을 하고있지만 많은 버그를 안고있다는 문제가 있다. Flexbox 제대로 프로덕션에서 사용하려면 IE9 이하는 대응을 포기하고, 추가적으로 크로스 브라우징을 위한 호환 코드가 필요하다. 많은 한국 사이트들은 아직도 IE9는 커녕, IE8 혹은 그 이하까지 대응해야하기 때문에 지금 당장 사용하는 것은 사실상 불가할 수도 있다.</p><p>그럼에도 Flexbox는 근시일내에 다가올 것이다. 매년 브라우저 사용률은 변화하고 있고, 분명 1년 전에 제작된 사이트들과 현재 제작되는 사이트들이 지원을 요구하는 브라우저 목록이 달라졌다. 나조차도 당장 얼마 전 새로 제작하게 된 사이트가 IE9 이하의 구버전을 대응하지 않기로 하면서, 원한다면 얼마든지 Flexbox를 사용할 수 있었다. 아쉽게도, 내가 Flexbox를 잘 몰랐고, 때문에 Flexbox를 사용해 개발하면 브라우저 호환성을 보장하기가 어려웠다(두려웠다). 결국 기존의 방식을 고수하여 개발을 했다. 웹 개발자로서 미래를 미리 준비하지 않는다면 나처럼 안타까운 상황이 발생할 수 있다.</p><h2 id="Solved-by-Flexbox"><a href="#Solved-by-Flexbox" class="headerlink" title="Solved by Flexbox"></a>Solved by Flexbox</h2><p>Solved by Flexbox는 Flexbox의 활용사례를 알아볼 수 있는 모음집이다. 잘 알려진 어려운 레이아웃 이슈들에 대해 다루며 그것을 Flexbox로 어떻게 해결할 수 있는지를 보기 쉽게 알려준다. 내가 약 1년 전에 번역한 <a href="/2016/02/21/how-to-become-a-great-frontend-engineer/">탁월한 프론트엔드 엔지니어</a>의 저자인 <a href="https://github.com/philipwalton" target="_blank" rel="noopener">Philip Walton</a>의 가장 핫한 프로젝트다. 번역이 필요할 정도로 그리 어려운 내용을 다루고 있지는 않지만 개인 공부 목적으로 번역을 시작했다. 코드가 <a href="https://en.bem.info/" target="_blank" rel="noopener">BEM</a> 스타일의 컴포넌트 단위로 잘 만들어져있기 때문에 실제 프로젝트에 접목해서 사용하기에도 좋다. Flexbox에 관심이 있으신 분은 꼭 한 번 참고해보시고 오역이나 더 매끄러운 번역은 <a href="https://github.com/HyunSeob/solved-by-flexbox-kr" target="_blank" rel="noopener">레포지토리</a>에 PR을 날려주시면 감사하겠다.</p><ul><li><a href="https://philipwalton.github.io/solved-by-flexbox/" target="_blank" rel="noopener">원문</a></li><li><a href="https://hyunseob.github.io/solved-by-flexbox-kr/">한국어 번역</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://hyunseob.github.io/solved-by-flexbox-kr/images/vertical-centering.jpg&quot;/&gt;&lt;p&gt;&lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot; 
      
    
    </summary>
    
      <category term="CSS" scheme="https://hyunseob.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://hyunseob.github.io/tags/CSS/"/>
    
      <category term="Translate" scheme="https://hyunseob.github.io/tags/Translate/"/>
    
  </entry>
  
</feed>
