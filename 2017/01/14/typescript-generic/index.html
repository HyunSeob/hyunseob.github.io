<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>TypeScript: 제네릭(Generic) | DailyEngineering</title><link rel="stylesheet" href="/libs/spoqa-han-sans-kr/css/SpoqaHanSans-kr.css"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://hyunseob.github.io/2017/01/14/typescript-generic/"/>
<meta name="description" content="이전 글 - TypeScript: 함수(Function) 제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다. 제네릭은 어떠한 클래스 혹은…">
<meta name="keywords" content="TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript: 제네릭(Generic)">
<meta property="og:url" content="https://hyunseob.github.io/2017/01/14/typescript-generic/">
<meta property="og:site_name" content="DailyEngineering">
<meta property="og:description" content="이전 글 - TypeScript: 함수(Function) 제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다. 제네릭은 어떠한 클래스 혹은…">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://hyunseob.github.io/images/typescript.png">
<meta property="og:updated_time" content="2018-12-31T10:15:02.279Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript: 제네릭(Generic)">
<meta name="twitter:description" content="이전 글 - TypeScript: 함수(Function) 제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다. 제네릭은 어떠한 클래스 혹은…">
<meta name="twitter:image" content="https://hyunseob.github.io/images/typescript.png">
<meta name="twitter:creator" content="@HyunSeob_">
<meta property="fb:app_id" content="https:&#x2F;&#x2F;www.facebook.com&#x2F;hyunseob.lee.7"><meta property="article:author" content="https://www.facebook.com/hyunseob.lee.7"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2017-01-14 23:51:23"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="HyunSeob"><link rel="icon" href="/images/icon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="DailyEngineering"><meta name="google-site-verification" content="mMu6SM0h7dcqHRQMonyssDlALM7KLAr5HQHDQEL0yRU"><meta name="naver-site-verification" content="3ef8fdf091c71d652b72f4fe73b191c2246127f6"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-72857127-1', 'auto');
ga('send', 'pageview');</script></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/icon.png" alt="DailyEngineering"><span class="menu__item__link--brand__label">DailyEngineering</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/resume">Resume</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">TypeScript: 제네릭(Generic)</h1><div class="article__meta"><time class="article__meta__time" datetime="2017-01-14T14:51:23.000Z" itemprop="datePublished">2017-01-14 23:51:23</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/JavaScript/">JavaScript</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/JavaScript/TypeScript/">TypeScript</a></div></div><div class="article__contents"><img src="/images/typescript.png"/><p>이전 글 - <a href="/2016/11/18/typescript-function/">TypeScript: 함수(Function)</a></p>
<p>제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다.</p>
<p>제네릭은 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다. Java나 C++ 등의 정적 타입 언어에서는 함수 및 클래스를 선언하는 시점에서 매개변수 혹은 리턴 타입을 정의해야하기 때문에 기본적으로는 특정 타입을 위해 만들어진 클래스나 함수를 다른 타입을 위해 재사용할 수가 없다. 때문에 제네릭을 통해 함수와 클래스의 범용적인 사용을 가능케 한다.</p>
<p>JavaScript는 원래 타입 선언이 필요하지 않고, 그렇기에 특정 타입을 위해 만들어진 클래스나 함수도 타입 에러를 런타임에서 일으킬 뿐이다. 코드를 실행시키기 전까지는 함수와 클래스가 모든 타입에 대응한다. 그렇기 때문에 JavaScript에서는 제네릭이란 말을 들을 일이 없다.</p>
<p>정적 타입 언어에서도 이렇게 특정 타입을 위해 만들어진 함수 혹은 클래스를 보다 범용적으로 재사용하기 위한 요구가 있기 때문에 제네릭이라는 프로그래밍 기법이 생긴 게 아닐까한다. TypeScript도 마찬가지로 정적 타입 언어이기 때문에, 기본적으로 타입을 정의한 함수 혹은 클래스는 모두 다른 타입에 재사용할 수 없다. 제네릭을 사용하지 않는다면 말이다.</p>
<h2 id="제네릭을-사용하는-이유"><a href="#제네릭을-사용하는-이유" class="headerlink" title="제네릭을 사용하는 이유"></a>제네릭을 사용하는 이유</h2><p>제네릭을 유용하게 사용할 수 있는 경우로는 자료구조가 있다. 다음과 같이 스택 자료구조를 TypeScript로 구현한다고 가정하자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line">  <span class="keyword">private</span> data: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">  contructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  push(item: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>여러가지 방법으로 구현할 수 있겠지만, 스택 같은 자료구조는 대개 범용적인 타입을 수용할 수 있도록 만들어진다. 따라서 TypeScript에서는 위와 같이 <code>any</code>를 이용하여 구현할 수 있는 것이 가장 쉬운 방법이다.</p>
<p>하지만 <code>any</code>를 이용하여 구현하면 저장하고 있는 자료의 타입이 모두 같지 않다는 문제점이 생긴다. 따라서 위의 스택에서 자료를 추출하는 경우 런타임에서 항상 타입 검사를 해줘야 한다는 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="string">'a'</span>);</span><br><span class="line">stack.pop().substring(<span class="number">0</span>) <span class="comment">// 'a'</span></span><br><span class="line">stack.pop().substring(<span class="number">0</span>) <span class="comment">// Throw TypeError</span></span><br></pre></td></tr></table></figure>
<p>그렇다고 자료형을 보장하기 위해 항상 <code>number</code> 타입의 변수만 받을 수 있도록 하면, 범용성이 떨어지게 된다.</p>
<p>물론 상속으로도 이를 처리할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NumberStack <span class="keyword">extends</span> Stack &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(item: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 상속을 사용하는 경우에는 자료형을 하나 추가할 때마다 구태여 클래스를 추가하고 중복되는 코드를 양산해야하기 때문에 번거롭기는 마찬가지다.</p>
<p>이런 경우에 유용하게 사용할 수 있는 것이 제네릭이다.</p>
<h2 id="제네릭의-문법"><a href="#제네릭의-문법" class="headerlink" title="제네릭의 문법"></a>제네릭의 문법</h2><h3 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h3><p>스택 자료구조를 제네릭으로 다시 구현하면 다음과 같은 형태를 띌 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> data: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  push(item: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>클래스 식별자 선언부에 <code>&lt;T&gt;</code>라는 못보던 문법이 추가된 것을 확인할 수 있다. 제네릭을 사용하겠다는 의미로 꺽쇠(Angle brackets)를 넣고 그 안에 타입으로 사용되는 식별자를 집어넣는다.</p>
<p><code>T</code>는 Type의 약자로 다른 언어에서도 제네릭을 선언할 때 관용적으로 많이 사용된다. 이 부분에는 식별자로 사용할 수 있는 것이라면 무엇이든 들어갈 수 있다. 이를테면 <code>$</code>나 <code>_</code>도 가능하다는 의미다. 하지만 대개의 경우 <code>T</code>를 사용한다. 여기에서 <code>T</code>를 타입 변수(Type variables)라고 한다.</p>
<p>이렇게해서 클래스에서 제네릭을 사용하겠다고 선언한 경우 <code>T</code>는 해당 클래스에서 사용할 수 있는 특정한 타입이 된다.</p>
<p>사용법은 아래와 같다. 그저 생성자를 호출하여 객체를 만들 때 <code>T</code>로 사용될 타입을 지정해주기만 하면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> stringStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">numberStack.push(<span class="number">1</span>);</span><br><span class="line">stringStack.push(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>이제 각 스택은 항상 생성할 때 선언한 타입만을 저장하고 리턴한다. 이렇게 하면 컴파일러가 리턴하는 타입을 알 수 있게 되므로 에디터에서 자동 완성을 사용할 수 있게 되므로 생산성 향상에도 기여한다는 장점이 있다.</p>
<p>다만 타입은 컴파일 단계에서 검사하는 것이므로 런타임에서는 막을 수 없다. 이를테면,</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numberStack.push(<span class="string">''</span> <span class="keyword">as</span> <span class="built_in">any</span>);</span><br></pre></td></tr></table></figure>
<p>이런<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 코드는 컴파일 단계의 타입 체크를 우회하므로 막을 수 없다.</p>
<h3 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h3><p>배열을 입력으로 받아 그 배열의 첫번째 요소를 출력하는(<code>lodash.head()</code> 같은) 함수를 구현해야 한다고 가정하자. 제네릭을 사용하지 않는 경우 이렇게 짜게 될 것이다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드는 마찬가지로 어떤 타입의 배열이라도 받을 수 있기 때문에 리턴하게 되는 타입이 무엇인지 알 수 없다. 제네릭을 이용하면 다음과 같이 간단하게 구현할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>추가된 것은 클래스와 동일하게 함수 식별자 옆에 들어가는 <code>&lt;T&gt;</code>이다. 마찬가지로 이 함수 내에서 <code>T</code>는 특정한 타입으로 취급된다.</p>
<p>마찬가지로 사용할 때는 함수를 호출할 때 제네릭 문법으로 타입을 정해주기만 하면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="두-개-이상의-타입-변수"><a href="#두-개-이상의-타입-변수" class="headerlink" title="두 개 이상의 타입 변수"></a>두 개 이상의 타입 변수</h2><p>제네릭 함수나 클래스에서는 두 개 이상의 타입 변수도 사용할 수 있다. 다음과 같이 두 가지 변수를 받아 쌍으로 만들어 반환하는 함수를 구현해야 한다고 가정하자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPair</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): [ <span class="title">any</span>, <span class="title">any</span> ] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [ a, b ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>입력되는 두 가지의 변수의 타입이 다르다고 가정할 경우 두 가지의 타입 변수가 필요하게 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">a: T, b: U</span>): [ <span class="title">T</span>, <span class="title">U</span> ] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [ a, b ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>제네릭을 사용하면 위와 같은 형태로 구현할 수 있다. 꺽쇠 안에 <code>T</code>와 <code>U</code> 두 가지의 타입 변수가 보일 것이다. 아까 관용적으로 <code>T</code>를 사용한다고 말했는데, 그 뒤로는 알파벳 순서대로 사용하면 된다. 반복문에서 관용적으로 인덱스 변수로 <code>i</code>, <code>j</code>를 사용하는 것과 비슷하다.</p>
<p>함수 사용법은 아래와 같다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toPair&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">'1'</span>, <span class="number">1</span>); <span class="comment">// [ '1', 1 ]</span></span><br><span class="line">toPair&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// [ 1, 1 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="상속된-타입-변수"><a href="#상속된-타입-변수" class="headerlink" title="상속된 타입 변수"></a>상속된 타입 변수</h2><p>타입 변수는 기존에 사용하고 있는 타입을 상속할 수도 있다. 이 점을 이용하면 입력 받을 변수의 타입을 제한할 수 있다. 또한 에디터가 해당 타입의 메소드나 프로퍼티를 예측할 수 있으므로 자동 완성이 된다.</p>
<p>이것과 여러 개의 타입 변수를 사용해 응용하면 아래와 같은 코드를 짤 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirst</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Stack</span>&lt;<span class="title">U</span>&gt;, <span class="title">U</span>&gt;(<span class="params">container: T</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> item = container.pop();</span><br><span class="line">  container.push(item);</span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getFirst</code>는 입력받은 스택의 첫번째 요소를 반환하는 함수다. 사용시에는 아래처럼 사용하면 된다. 만약 첫 번째 타입으로 스택, 혹은 스택을 상속한 타입이 아닌 다른 타입을 사용하면 에러가 발생한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getFirst&lt;Stack&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>)(numberStack);</span><br><span class="line">getFirst&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;(<span class="number">1</span>); <span class="comment">// Type 'number' does not satisfy the constraint 'Stack&lt;number&gt;'.</span></span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">하지만 실제로 TypeScript를 실서비스에 적용하다보면 이러한 코드를 어쩔 수 없이 짜게되는 경우가 좀 있다. 물론 지양해야 한다.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div></div><div class="article__tags"><a class="article__tags__item" href="/tags/TypeScript/">TypeScript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/84420953b2e0a28e39fbba241a8b680a" alt="HyunSeob"><a class="article__author__link" href="/resume" title="About HyunSeob" rel="author">HyunSeob</a><p class="article__author__desc">저만이 쓸 수 있는 글을 쓰도록 노력하겠습니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/HyunSeob" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.facebook.com/hyunseob.lee.7" title="facebook" target="_blank"><i class="fa fa-facebook"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/in/hyunseoblee/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="https://www.instagram.com/hyunseob.lee/" title="instagram" target="_blank"><i class="fa fa-instagram"></i></a><a class="article__author__socials__item" href="https://twitter.com/HyunSeob_" title="twitter" target="_blank"><i class="fa fa-twitter"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="HyunSeob"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//dailyengineering.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-12-31T10:15:02.279Z"><meta itemprop="articleBody" content="이전 글 - TypeScript: 함수(Function)
제네릭은 Java 등의 정적 타입 언어를 사용하던 사람에게는 익숙한 단어일지도 모르겠다. 그러나 JavaScript를 사용해왔던 개발자에게는 그렇지 않다.
제네릭은 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다. Java나 C++..."><meta itemprop="url" content="https://hyunseob.github.io/2017/01/14/typescript-generic/"><meta itemprop="mainEntityOfPage" content="https://hyunseob.github.io/2017/01/14/typescript-generic/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="DailyEngineering"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://hyunseob.github.io/images/icon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://hyunseob.github.io/images/typescript.png"><meta itemprop="url" content="https://hyunseob.github.io/images/typescript.png"><meta itemprop="width" content="1200"><meta itemprop="height" content="630"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2017/07/18/typescript-enums/"><div class="related-posts__item__background" style="background-image:url('/images/typescript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">TypeScript: Enum</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2016/09/25/typescript-introduction/"><div class="related-posts__item__background" style="background-image:url('/images/typescript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">TypeScript: 소개</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2017/12/12/typescript-type-inteference-and-type-assertion/"><div class="related-posts__item__background" style="background-image:url('/images/typescript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">TypeScript: 타입 추론과 타입 단언</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2019/12/31/2019-year-in-review/">2019년 돌아보기</a></li><li class="recent-posts__item"><a href="/2019/06/02/react-component-the-right-way/">컴포넌트 제대로 만들기</a></li><li class="recent-posts__item"><a href="/2019/05/26/google-io-2019-day-3/">Google I/O 2019: Day 3 후기</a></li><li class="recent-posts__item"><a href="/2019/05/12/google-io-2019-day-2/">Google I/O 2019: Day 2 후기</a></li><li class="recent-posts__item"><a href="/2019/05/09/google-io-2019-day-1/">Google I/O 2019: Day 1 후기</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Tag cloud</h3><div class="tag-cloud"><a href="/tags/AWS/" style="font-size: 0.88rem;">AWS</a> <a href="/tags/Agile/" style="font-size: 0.75rem;">Agile</a> <a href="/tags/Angular2/" style="font-size: 0.75rem;">Angular2</a> <a href="/tags/AngularJS/" style="font-size: 1.13rem;">AngularJS</a> <a href="/tags/Apex/" style="font-size: 0.75rem;">Apex</a> <a href="/tags/Attitude/" style="font-size: 0.75rem;">Attitude</a> <a href="/tags/Blog/" style="font-size: 1rem;">Blog</a> <a href="/tags/Build/" style="font-size: 0.75rem;">Build</a> <a href="/tags/CLI/" style="font-size: 0.75rem;">CLI</a> <a href="/tags/CSS/" style="font-size: 0.75rem;">CSS</a> <a href="/tags/Closure/" style="font-size: 0.88rem;">Closure</a> <a href="/tags/CoffeeScript/" style="font-size: 0.88rem;">CoffeeScript</a> <a href="/tags/ComputerScience/" style="font-size: 0.75rem;">ComputerScience</a> <a href="/tags/DOM/" style="font-size: 0.88rem;">DOM</a> <a href="/tags/DesignPattern/" style="font-size: 0.75rem;">DesignPattern</a> <a href="/tags/Deview/" style="font-size: 0.75rem;">Deview</a> <a href="/tags/ES2015/" style="font-size: 1.25rem;">ES2015</a> <a href="/tags/ESLint/" style="font-size: 0.75rem;">ESLint</a> <a href="/tags/Electron/" style="font-size: 0.75rem;">Electron</a> <a href="/tags/Functional/" style="font-size: 0.75rem;">Functional</a> <a href="/tags/GDG/" style="font-size: 1rem;">GDG</a> <a href="/tags/Google-I-O/" style="font-size: 1rem;">Google I/O</a> <a href="/tags/GraphQL/" style="font-size: 0.75rem;">GraphQL</a> <a href="/tags/Hexo/" style="font-size: 0.75rem;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 1.5rem;">JavaScript</a> <a href="/tags/Log/" style="font-size: 1.25rem;">Log</a> <a href="/tags/MobX/" style="font-size: 0.88rem;">MobX</a> <a href="/tags/Node-js/" style="font-size: 1.25rem;">Node.js</a> <a href="/tags/ORM/" style="font-size: 0.75rem;">ORM</a> <a href="/tags/Opinion/" style="font-size: 1.13rem;">Opinion</a> <a href="/tags/Promise/" style="font-size: 0.75rem;">Promise</a> <a href="/tags/Q-js/" style="font-size: 0.75rem;">Q.js</a> <a href="/tags/React/" style="font-size: 1.38rem;">React</a> <a href="/tags/Reactive/" style="font-size: 0.88rem;">Reactive</a> <a href="/tags/ReactiveX/" style="font-size: 0.75rem;">ReactiveX</a> <a href="/tags/RxJS/" style="font-size: 0.75rem;">RxJS</a> <a href="/tags/Sequelize-js/" style="font-size: 0.75rem;">Sequelize.js</a> <a href="/tags/Storybook/" style="font-size: 0.75rem;">Storybook</a> <a href="/tags/Terminology/" style="font-size: 0.75rem;">Terminology</a> <a href="/tags/Testing/" style="font-size: 0.75rem;">Testing</a> <a href="/tags/Tool/" style="font-size: 0.75rem;">Tool</a> <a href="/tags/Translate/" style="font-size: 1.25rem;">Translate</a> <a href="/tags/Tutorial/" style="font-size: 1.13rem;">Tutorial</a> <a href="/tags/TypeScript/" style="font-size: 1.5rem;">TypeScript</a> <a href="/tags/Year-in-review/" style="font-size: 1rem;">Year in review</a> <a href="/tags/babel/" style="font-size: 0.75rem;">babel</a> <a href="/tags/jQuery/" style="font-size: 1rem;">jQuery</a> <a href="/tags/lodash/" style="font-size: 0.88rem;">lodash</a> <a href="/tags/underscore-js/" style="font-size: 1rem;">underscore.js</a> <a href="/tags/webpack/" style="font-size: 1rem;">webpack</a></div></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/">ComputerScience</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FrontEnd/">FrontEnd</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">28</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/AngularJS/">AngularJS</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Basic/">Basic</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/DesignPattern/">DesignPattern</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ES2015/">ES2015</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/React/">React</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/RxJS/">RxJS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/TypeScript/">TypeScript</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/lodash-underscore/">lodash/underscore</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Log/">Log</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Opinion/">Opinion</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Server/AWS/">AWS</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2019 HyunSeob<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><!--[if lt IE 10]><script src="/js/classList.min.js"></script><![endif]--><script src="/js/index.min.js"></script></body></html>