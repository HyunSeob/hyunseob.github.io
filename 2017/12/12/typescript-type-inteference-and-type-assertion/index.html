<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>TypeScript: 타입 추론과 타입 단언 | DailyEngineering</title><link rel="stylesheet" href="/libs/spoqa-han-sans-kr/css/SpoqaHanSans-kr.css"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/"/>
<meta name="description" content="TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이 있을 때 타입을 정의하는 일은 정적 타이핑 환경에서는 피할 수…">
<meta name="keywords" content="TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript: 타입 추론과 타입 단언">
<meta property="og:url" content="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/">
<meta property="og:site_name" content="DailyEngineering">
<meta property="og:description" content="TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이 있을 때 타입을 정의하는 일은 정적 타이핑 환경에서는 피할 수…">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://hyunseob.github.io/images/typescript.png">
<meta property="og:updated_time" content="2018-12-31T10:15:02.280Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript: 타입 추론과 타입 단언">
<meta name="twitter:description" content="TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이 있을 때 타입을 정의하는 일은 정적 타이핑 환경에서는 피할 수…">
<meta name="twitter:image" content="https://hyunseob.github.io/images/typescript.png">
<meta name="twitter:creator" content="@HyunSeob_">
<meta property="fb:app_id" content="https:&#x2F;&#x2F;www.facebook.com&#x2F;hyunseob.lee.7"><meta property="article:author" content="https://www.facebook.com/hyunseob.lee.7"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2017-12-12 22:11:24"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="HyunSeob"><link rel="icon" href="/images/icon.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="DailyEngineering"><meta name="google-site-verification" content="mMu6SM0h7dcqHRQMonyssDlALM7KLAr5HQHDQEL0yRU"><meta name="naver-site-verification" content="3ef8fdf091c71d652b72f4fe73b191c2246127f6"><script>(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-72857127-1', 'auto');
ga('send', 'pageview');</script></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/icon.png" alt="DailyEngineering"><span class="menu__item__link--brand__label">DailyEngineering</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/resume">Resume</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">TypeScript: 타입 추론과 타입 단언</h1><div class="article__meta"><time class="article__meta__time" datetime="2017-12-12T13:11:24.000Z" itemprop="datePublished">2017-12-12 22:11:24</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/JavaScript/">JavaScript</a><span class="article__meta__categories__separator">></span><a class="article__meta__categories__item" href="/categories/JavaScript/TypeScript/">TypeScript</a></div></div><div class="article__contents"><img src="/images/typescript.png"/><p>TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이 있을 때 타입을 정의하는 일은 정적 타이핑 환경에서는 피할 수 없는 문제지만 타입 선언에 대한 압박은 타입 추론이 얼마나 잘 되느냐에 따라 그 정도가 매우 다르다.</p>
<p>전통적인 정적 타입 언어에서는 모든 변수나 파라미터, 프로퍼티 등의 타입을 모두 선언해야하기 때문에, 타입 추론 같은 기능이 필요없다. 하지만 TypeScript 에서는 모든 변수에 항상 타입을 선언할 필요가 없으므로 컴파일러가 타입 추론을 잘해주기만 해도 타입 선언 비용이 상당히 줄어든다.</p>
<h2 id="타입-추론-Type-Inference"><a href="#타입-추론-Type-Inference" class="headerlink" title="타입 추론(Type Inference)"></a>타입 추론(Type Inference)</h2><p>타입 추론의 기본적인 동작을 간단한 예제를 통해서 알아보자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="literal">true</span>, <span class="number">1</span>];</span><br><span class="line">bool = <span class="number">1</span>; <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
<p>위의 예제에서 각 변수의 타입은 적절하게 추론되므로 다시 사용할 때 Type Safe 하게 사용할 수 있다. <code>bool</code>의 타입은 <code>boolean</code>으로 추론되므로 <code>number</code> 타입인 <code>1</code>을 할당하려고 하면 에러가 발생한다. <code>arr</code> 변수는 <code>number[]</code>, 즉 <code>number</code> 타입의 배열로 추론된다. 이 때 배열의 길이는 항상 고정이 아닌 것으로 추론한다. 즉, 투플이 아니다. 아래의 <code>tuple</code> 변수도 마찬가지로 배열로 추론된다. 만약 투플로 사용하고 싶다면 별 수 없이 타입 선언을 해주어야 한다. 다만 배열의 요소가 각각 <code>boolean</code>과 <code>number</code>이기에 최종적으로 추론되는 타입은 <code>boolean</code>과 <code>number</code>의 <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" target="_blank" rel="noopener">유니온</a> 타입의 배열, 코드로 나타내면 <code>(boolean | number)[]</code>이다.</p>
<p>여기에서 배열에서 사용된 요소들의 타입을 각각 추론하여 유니온 타입으로 만들어 내는 방식을 TypeScirpt 에서는 <a href="https://www.typescriptlang.org/docs/handbook/type-inference.html#best-common-type" target="_blank" rel="noopener">Best common type</a>이라고 부른다.</p>
<h3 id="Best-common-type"><a href="#Best-common-type" class="headerlink" title="Best common type"></a>Best common type</h3><p>Best common type 은 말 그대로 가장 일반적인 타입이다. 여러가지 자료형이 배열 내부에서 사용되고 있을 때, 그 여러가지 자료형을 포괄할 수 있는 가장 일반적인 자료형을 추론하는 것이다. 그 결과로 위의 예제에서는 <code>true</code>와 <code>1</code>을 포괄할 수 있는 자료형인, <code>(boolean | number)</code>가 추론된 것이다.</p>
<p>Best common type 은 대부분의 경우에 유니온 타입으로 추론되지만 예외적인 케이스도 몇 가지 있다. 먼저 특정 클래스가 다른 클래스를 상속한 경우.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  foo = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="keyword">new</span> Parent(), <span class="keyword">new</span> Child()];</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 <code>arr</code> 변수의 타입은 <code>Parent[]</code>로 추론된다. <code>Parent</code> 타입이 <code>Child</code> 타입을 포괄할 수 있는 타입이므로 그렇게 추론되는 것이다. 하지만 다음의 예제에서는 조금 다르다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  foo = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child1 <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  bar = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child2 <span class="keyword">extends</span> Parent &#123;</span><br><span class="line">  baz = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="keyword">new</span> Child1(), <span class="keyword">new</span> Child2()];</span><br></pre></td></tr></table></figure>
<p>여기에서도 분명 <code>Parent</code> 타입은 <code>Child1</code> 타입과 <code>Child2</code> 타입을 포괄할 수 있는 타입이다. 따라서 마찬가지로 <code>Parent[]</code>로 타입이 추론되는 것이 타당해 보이지만, 실제로는 다시 유니온 타입으로, <code>(Child1 | Child2)[]</code>로 추론된다. 이유는 모르겠지만 아마 약간의 기술적인 어려움이 있는 것이 아닐까 예상된다.</p>
<p>함수가 상황에 따라 여러가지 타입의 값들을 리턴하는 경우에서도 리턴 값이 위와 동일한 룰을 따라 추론된다. 다만 상수를 리턴하면 그 값 자체가 타입으로 인식되는 리터럴 타입으로 추론된다.</p>
<h2 id="타입-단언-Type-Assertion"><a href="#타입-단언-Type-Assertion" class="headerlink" title="타입 단언(Type Assertion)"></a>타입 단언(Type Assertion)</h2><p>TypeScript 의 타입 추론 기능은 매우 강력하지만 어쩔 수 없는 한계가 존재한다. 타입 단언은 TypeScript 컴파일러가 타입을 실제 런타임에 존재할 변수의 타입과 다르게 추론하거나 너무 보수적으로 추론하는 경우에 프로그래머가 수동으로 컴파일러한테 특정 변수에 대해 타입 힌트를 주는 것이다.</p>
<p>다음 예제를 살펴보자.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Character &#123;</span><br><span class="line">  hp: <span class="built_in">number</span>;</span><br><span class="line">  runAway() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  isWizard() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  isWarrior() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Wizard <span class="keyword">extends</span> Character &#123;</span><br><span class="line">  fireBall() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Warrior <span class="keyword">extends</span> Character &#123;</span><br><span class="line">  attack() &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    character.fireBall(); <span class="comment">// Property 'fireBall' does not exist on type 'Character'.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    character.attack(); <span class="comment">// Property 'attack' does not exist on type 'Character'.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 코드는 컴파일 에러를 낸다. <code>Character</code> 클래스에는 <code>fireBall</code>, <code>attack</code> 메소드가 선언조차 되어있지 않기 때문이다. 하지만 프로그래머 입장에서 바라보면 <code>isWizard</code>라는 메소드를 통해 확실히 그 캐릭터가 <code>Wizard</code> 인스턴스라는 걸 보장할 수 있다면, <code>if</code> 블록 안에서는 당연히 <code>fireBall</code>이라는 메소드를 사용할 수 있어야 한다.</p>
<p>이 때, 타입 단언으로 적절한 타입을 다시 선언해줄 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    (character <span class="keyword">as</span> Wizard).fireBall(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    (character <span class="keyword">as</span> Warrior).attack(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 변수가 실제로 Wizard 인스턴스가 아니더라도 <code>as</code> 키워드를 통해서 타입 단언을 해줄 수 있기 때문에, 타입 단언은 주의해서 사용해야 한다. 실제로도 <code>as any</code> 라는 치트키로 대부분의 컴파일 에러를 해결할 수 있다. 하지만 이런 키워드가 코드 베이스에 득시글 거릴 수록 TypeScript 를 사용해서 얻는 장점이 점차 사라져가기 때문에, 기왕 TypeScript 를 사용하기로 마음 먹었다면 <code>as</code>와 <code>any</code>는 가능한 적게 사용하는 것이 좋다. 물론, 아예 사용하지 않기는 어렵다.</p>
<h3 id="타입-단언이-타입-캐스팅이-아닌-이유"><a href="#타입-단언이-타입-캐스팅이-아닌-이유" class="headerlink" title="타입 단언이 타입 캐스팅이 아닌 이유"></a>타입 단언이 타입 캐스팅이 아닌 이유</h3><p>타입 단언은 타입을 변경한다는 사실 때문에 타입 캐스팅과 비슷하게 느껴질 수 있다. 타입 단언이 타입 캐스팅이라고 불리지 않는 이유는 런타임에 영향을 미치지 않기 때문이다. 타입 캐스팅은 컴파일타임과 런타임에서 모두 타입을 변경시키지만 타입 단언은 오직 컴파일타임에서만 타입을 변경시킨다.</p>
<h3 id="lt-Type-gt-vs-as-Type"><a href="#lt-Type-gt-vs-as-Type" class="headerlink" title="&lt;Type&gt; vs as Type"></a><code>&lt;Type&gt;</code> vs <code>as Type</code></h3><p>타입 단언 문법은 <code>&lt;Type&gt;</code> 과 <code>as Type</code> 으로 두 종류다. 아래처럼 사용할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;Wizard&gt;character).fireBall();</span><br><span class="line">(character <span class="keyword">as</span> Wizard).fireBall();</span><br></pre></td></tr></table></figure>
<p>그냥 보기에는 <code>&lt;Type&gt;</code> 키워드가 좀 더 깔끔해보이지만, 대개 <code>as Type</code> 키워드가 추천된다. React 와 React 에서 빼놓을 수 없는 문법인 JSX 를 사용하는 경우 <code>&lt;Type&gt;</code> 키워드는 JSX 의 문법과 겹치기 때문에 불편한 면이 있다.</p>
<h3 id="타입-가드-Type-Guard"><a href="#타입-가드-Type-Guard" class="headerlink" title="타입 가드(Type Guard)"></a>타입 가드(Type Guard)</h3><p>타입 가드는 타입 단언을 좀 더 깔끔하게 할 수 있도록 도와준다. 앞서 타입 단언에서 소개한 예제에서는 <code>isWizard</code>라는 메소드로 해당 인스턴스가 해당 타입이라는 사실을 확정했다. 하지만 이건 런타임에서만 알 수 있는 사실이고 TypeScript 컴파일러는 알 수 없었다. 타입 가드는 이러한 런타임에서의 타입 체크를 컴파일러에게 알려주는 기능이다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Character &#123;</span><br><span class="line">  isWizard(): <span class="keyword">this</span> is Wizard &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> Wizard;</span><br><span class="line">  &#125;</span><br><span class="line">  isWarrior(): <span class="keyword">this</span> is Warrior &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> Warrior;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이런식으로 런타임에서 실제 타입검사를 하는 메소드의 리턴타입으로 <code>{variable} is {Type}</code> 같은 문법을 사용해 선언해주면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    character.fireBall(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    character.attack(); <span class="comment">// Pass</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 별도의 타입 단언 문법 없이도 <code>if</code> 블록 안에서 <code>character</code>가 <code>Wizard</code>나 <code>Warrior</code>로 잘 추론된다. 그리고 사실 <code>instanceof</code> 와 <code>typeof</code> 같은 오퍼레이터가 일종의 타입 가드이기도 하다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    val.toFixed(); <span class="comment">// Pass, val은 number 타입으로 추론</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Union 타입에서 `number`는 이미 통과했으므로 자동으로 `string`으로 추론됨</span></span><br><span class="line">    val.toLowerCase(); <span class="comment">// Pass, val은 string 타입으로 추론</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="사족-타입-선언은-언제하는가"><a href="#사족-타입-선언은-언제하는가" class="headerlink" title="사족: 타입 선언은 언제하는가?"></a>사족: 타입 선언은 언제하는가?</h2><p>별도의 선언이 없어도 추론이 잘 되는 경우에는 타입 선언을 하지 않고, 그렇지 않은 경우에만 선언하는 것이 편리하고 자연스럽다. 예를 들면,</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex: <span class="built_in">RegExp</span> = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/pattern/</span>);</span><br></pre></td></tr></table></figure>
<p>위와 같은 상황에서 <code>: RegExp</code> 라는 코드는 불필요한 선언으로 간주하고 지운다. 하지만 다음처럼 변수 생성과 동시에 값을 할당하지 않는 경우,</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="literal">null</span>;</span><br><span class="line">regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/pattern/</span>);</span><br></pre></td></tr></table></figure>
<p>이런 상황에서는 <code>regex</code> 변수의 타입 추론이 제대로 되지 않으므로 타입을 같이 선언해준다.</p>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/TypeScript/">TypeScript</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="https://www.gravatar.com/avatar/84420953b2e0a28e39fbba241a8b680a" alt="HyunSeob"><a class="article__author__link" href="/resume" title="About HyunSeob" rel="author">HyunSeob</a><p class="article__author__desc">저만이 쓸 수 있는 글을 쓰도록 노력하겠습니다.</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/HyunSeob" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.facebook.com/hyunseob.lee.7" title="facebook" target="_blank"><i class="fa fa-facebook"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/in/hyunseoblee/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="https://www.instagram.com/hyunseob.lee/" title="instagram" target="_blank"><i class="fa fa-instagram"></i></a><a class="article__author__socials__item" href="https://twitter.com/HyunSeob_" title="twitter" target="_blank"><i class="fa fa-twitter"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="HyunSeob"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//dailyengineering.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-12-31T10:15:02.280Z"><meta itemprop="articleBody" content="TypeScript 를 도입하기가 망설여지는 이유 중 하나는 매번 일일이 변수를 선언할 때마다 타입을 선언해야하고 필요한 타입을 정의해야하는 비용에 대한 걱정일 것이다. 필요한 타입이 있을 때 타입을 정의하는 일은 정적 타이핑 환경에서는 피할 수 없는 문제지만 타입 선언에 대한 압박은 타입 추론이 얼마나 잘 되느냐에 따라 그 정도가 매우..."><meta itemprop="url" content="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/"><meta itemprop="mainEntityOfPage" content="https://hyunseob.github.io/2017/12/12/typescript-type-inteference-and-type-assertion/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="DailyEngineering"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://hyunseob.github.io/images/icon.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="https://hyunseob.github.io/images/typescript.png"><meta itemprop="url" content="https://hyunseob.github.io/images/typescript.png"><meta itemprop="width" content="1200"><meta itemprop="height" content="630"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2016/10/17/typescript-class/"><div class="related-posts__item__background" style="background-image:url('/images/typescript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">TypeScript: 클래스(Class)</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2017/07/18/typescript-enums/"><div class="related-posts__item__background" style="background-image:url('/images/typescript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">TypeScript: Enum</span></a></div><div class="related-posts__item__wrapper"><a class="related-posts__item" href="/2016/09/25/typescript-introduction/"><div class="related-posts__item__background" style="background-image:url('/images/typescript.png');"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">TypeScript: 소개</span></a></div></section></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2019/05/26/google-io-2019-day-3/">Google I/O 2019: Day 3 후기</a></li><li class="recent-posts__item"><a href="/2019/05/12/google-io-2019-day-2/">Google I/O 2019: Day 2 후기</a></li><li class="recent-posts__item"><a href="/2019/05/09/google-io-2019-day-1/">Google I/O 2019: Day 1 후기</a></li><li class="recent-posts__item"><a href="/2018/12/31/2018-year-in-review/">2018년 돌아보기</a></li><li class="recent-posts__item"><a href="/2018/11/27/typescript-at-google/">[번역] TypeScript at Google</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Tag cloud</h3><div class="tag-cloud"><a href="/tags/AWS/" style="font-size: 0.9rem;">AWS</a> <a href="/tags/Agile/" style="font-size: 0.75rem;">Agile</a> <a href="/tags/Angular2/" style="font-size: 0.75rem;">Angular2</a> <a href="/tags/AngularJS/" style="font-size: 1.2rem;">AngularJS</a> <a href="/tags/Apex/" style="font-size: 0.75rem;">Apex</a> <a href="/tags/Attitude/" style="font-size: 0.75rem;">Attitude</a> <a href="/tags/Blog/" style="font-size: 1.05rem;">Blog</a> <a href="/tags/Build/" style="font-size: 0.75rem;">Build</a> <a href="/tags/CLI/" style="font-size: 0.75rem;">CLI</a> <a href="/tags/CSS/" style="font-size: 0.75rem;">CSS</a> <a href="/tags/Closure/" style="font-size: 0.9rem;">Closure</a> <a href="/tags/CoffeeScript/" style="font-size: 0.9rem;">CoffeeScript</a> <a href="/tags/ComputerScience/" style="font-size: 0.75rem;">ComputerScience</a> <a href="/tags/DOM/" style="font-size: 0.9rem;">DOM</a> <a href="/tags/DesignPattern/" style="font-size: 0.75rem;">DesignPattern</a> <a href="/tags/Deview/" style="font-size: 0.75rem;">Deview</a> <a href="/tags/ES2015/" style="font-size: 1.35rem;">ES2015</a> <a href="/tags/ESLint/" style="font-size: 0.75rem;">ESLint</a> <a href="/tags/Electron/" style="font-size: 0.75rem;">Electron</a> <a href="/tags/Functional/" style="font-size: 0.75rem;">Functional</a> <a href="/tags/GDG/" style="font-size: 1.05rem;">GDG</a> <a href="/tags/Google-I-O/" style="font-size: 1.05rem;">Google I/O</a> <a href="/tags/GraphQL/" style="font-size: 0.75rem;">GraphQL</a> <a href="/tags/Hexo/" style="font-size: 0.75rem;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 1.5rem;">JavaScript</a> <a href="/tags/Log/" style="font-size: 1.35rem;">Log</a> <a href="/tags/MobX/" style="font-size: 0.9rem;">MobX</a> <a href="/tags/Node-js/" style="font-size: 1.35rem;">Node.js</a> <a href="/tags/ORM/" style="font-size: 0.75rem;">ORM</a> <a href="/tags/Opinion/" style="font-size: 1.2rem;">Opinion</a> <a href="/tags/Promise/" style="font-size: 0.75rem;">Promise</a> <a href="/tags/Q-js/" style="font-size: 0.75rem;">Q.js</a> <a href="/tags/React/" style="font-size: 1.35rem;">React</a> <a href="/tags/Reactive/" style="font-size: 0.9rem;">Reactive</a> <a href="/tags/ReactiveX/" style="font-size: 0.75rem;">ReactiveX</a> <a href="/tags/RxJS/" style="font-size: 0.75rem;">RxJS</a> <a href="/tags/Sequelize-js/" style="font-size: 0.75rem;">Sequelize.js</a> <a href="/tags/Storybook/" style="font-size: 0.75rem;">Storybook</a> <a href="/tags/Terminology/" style="font-size: 0.75rem;">Terminology</a> <a href="/tags/Testing/" style="font-size: 0.75rem;">Testing</a> <a href="/tags/Tool/" style="font-size: 0.75rem;">Tool</a> <a href="/tags/Translate/" style="font-size: 1.35rem;">Translate</a> <a href="/tags/Tutorial/" style="font-size: 1.2rem;">Tutorial</a> <a href="/tags/TypeScript/" style="font-size: 1.5rem;">TypeScript</a> <a href="/tags/Year-in-review/" style="font-size: 0.9rem;">Year in review</a> <a href="/tags/babel/" style="font-size: 0.75rem;">babel</a> <a href="/tags/jQuery/" style="font-size: 1.05rem;">jQuery</a> <a href="/tags/lodash/" style="font-size: 0.9rem;">lodash</a> <a href="/tags/underscore-js/" style="font-size: 1.05rem;">underscore.js</a> <a href="/tags/webpack/" style="font-size: 1.05rem;">webpack</a></div></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/">ComputerScience</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FrontEnd/">FrontEnd</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">27</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/AngularJS/">AngularJS</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Basic/">Basic</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/DesignPattern/">DesignPattern</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ES2015/">ES2015</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/React/">React</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/RxJS/">RxJS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/TypeScript/">TypeScript</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/lodash-underscore/">lodash/underscore</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Log/">Log</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Opinion/">Opinion</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Server/">Server</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Server/AWS/">AWS</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2019 HyunSeob<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><!--[if lt IE 10]><script src="/js/classList.min.js"></script><![endif]--><script src="/js/index.min.js"></script></body></html>